---
title: "基于到墙壁距离测量的定位"
# author: "Zehua"
date: "2024-05-06T16:25:17+01:00"
lastmod: "2024-11-17T17:12:35+08:00"
lang: "zh"
draft: false
summary: "卡尔曼滤波"
description: ""
tags: ["信号处理","卡尔曼滤波"]
# categories: "posts"
#cover:
    #image: "img/signal.png"
# comments: true
# hideMeta: false
searchHidden: true
# ShowBreadCrumbs: true
# ShowReadingTime: false

---









**问题**



我们考虑一个假设为点的机器人，其位置为 $x = (x_1, x_2)$。它通过测量到三个墙的距离来确定位置，如下图所示。第 $i$ 面墙由两个点 $a(i)$ 和 $b(i)$ 确定的直线表示。

机器人到第 $i$ 墙的距离定义为：
$$
d(i) = \det(u(i), x - a(i)) + \beta_i
$$
其中
$$
u(i) = \frac{b(i) - a(i)}{|b(i) - a(i)|}
$$


每个距离的测量值都带有一个误差 $\beta_i$，该误差是中心化的，具有单位方差，并且所有误差彼此独立。在进行任何测量之前，机器人认为它的位置为 $\bar{x} = (1, 2)$，并且假设与之相关联的协方差矩阵为 $100 \cdot I$。



要求：根据 $a(i)$、$b(i)$ 和 $d(i)$ 的数据，估计机器人的位置，以及基于无偏线性正交估计器，计算误差的协方差矩阵。



<img src="/img/kalman/exo_11_1.png" alt="exo_11_1.png" width="70%"/>

<img src="/img/kalman/exo_11_2.png" alt="exo_11_2.png" width="40%"/>

理论计算
$$
d(i) = \det(u(i), x - a(i)) + \beta_i
$$

$$
= \det\left(u(i), \begin{bmatrix} x_1 \\\\ x_2 \end{bmatrix} - \begin{bmatrix} a_1(i) \\\\ a_2(i) \end{bmatrix}\right) + \beta_i
$$

因为:
$$
u(i) = \begin{bmatrix} u_1(i) \\\\ u_2(i) \end{bmatrix}, \quad x = \begin{bmatrix} x_1 \\\\ x_2 \end{bmatrix}, \quad a(i) = \begin{bmatrix} a_1(i) \\\\ a_2(i) \end{bmatrix}
$$

$$
d(i) = \det\left(\begin{bmatrix} u_1(i) \\\\ u_2(i) \end{bmatrix}, \begin{bmatrix} x_1 \\\\ x_2 \end{bmatrix} - \begin{bmatrix} a_1(i) \\\\ a_2(i) \end{bmatrix}\right) + \beta_i
$$

$$
d(i) = \det\left(\begin{bmatrix} u_1(i) & x_1 - a_1(i) \\\\ u_2(i) & x_2 - a_2(i) \end{bmatrix}\right) + \beta_i
$$

因此:
$$
d(i) = u_1(i) \cdot \left(x_2 - a_2(i)\right) - u_2(i) \cdot \left(x_1 - a_1(i)\right) + \beta_i
$$
我们想要找到以下形式
$$
y_i = C_i x_i + \beta_i
$$

$$
d(i) = u_1(i) x_2 - u_1(i) a_2(i) - u_2(i) x_1 + u_2(i) a_1(i) + \beta_i
$$

$$
d(i) + u_1(i) a_2(i) - u_2(i) a_1(i) = u_1(i) x_2 - u_2(i) x_1 + \beta_i
$$

$$
d(i) + u_1(i) a_2(i) - u_2(i) a_1(i) =  \begin{bmatrix} -u_2(i) & u_1x(i) \end{bmatrix} \begin{bmatrix} x_1 \\\\ x_2 \end{bmatrix} + \beta(i)
$$

$$
y(i) = C(i) x + \beta(i)
$$

其中:
$$
y(i) =  d(i) + \begin{bmatrix} a_2(i) & -a_1(i) \end{bmatrix} 
\begin{bmatrix} u_1(i) \\\\ u_2(i) \end{bmatrix} = d_2(i)
$$
通过这种方式，我们可以获得对应于卡尔曼滤波器关键参数的矩阵，然后我们使用 MATLAB 代码来解决问题。

```matlab
clear all; clc; 
% 定义墙壁端点的坐标
a = [2 15 3;
     1 5 12]; % 墙壁A的端点坐标
 
b = [15 3 2;
     5 12 1]; % 墙壁B的端点坐标

d = [2; 5; 4]; % 测量的距离向量

u = [0; 0];

C = [-u(2), u(1); 
     -u(2), u(1); 
     -u(2), u(1)]; 

d2 = [0; 0; 0]; 
xbar = [1; 2]; % 初始位置

% 绘制墙壁
figure;
plot([2, 15], [1, 5], 'black', 'LineWidth', 2); 

hold on;

plot([15, 3], [5, 12], 'black', 'LineWidth', 2); 
hold on;

plot([3, 2], [12, 1], 'black', 'LineWidth', 2); 
hold on;

% 计算矩阵C和向量d2
for i = 1:3
    u = (b(:, i) - a(:, i)) / norm(b(:, i) - a(:, i)); % 计算墙壁的单位向量
    C(i, :) = [-u(2), u(1)]; % 更新矩阵C
    d2(i) = [a(2, i),-a(1, i)]*u; % 更新向量d2
end

y = d + d2; % 计算y
G0 = 100 * eye(2, 2); 
u1 = 0; % 输入为零
Galpha = 0; % 无噪声
Gbeta = eye(3, 3); % 计算噪声的协方差矩阵

% 使用卡尔曼滤波器进行位置估计
[x1, G1, xup1, Gup1] = kalman(xbar, G0, u1, y(1), Galpha, Gbeta(1, 1), eye(2, 2), C(1, :));
draw_ellipse(xup1, Gup1, 0.9, 'g', 1.5); hold on;

[x2, G2, xup2, Gup2] = kalman(x1, G1, u1, y(2), Galpha, Gbeta(2, 2), eye(2, 2), C(2, :));
draw_ellipse(xup2, Gup2, 0.9, 'r', 1.5); hold on;

[x3, G3, xup3, Gup3] = kalman(x2, G2, u1, y(3), Galpha, Gbeta(3, 3), eye(2, 2), C(3, :));
% 绘制卡尔曼滤波器修正后的位置估计椭圆
draw_ellipse(xup3, Gup3, 0.9, 'b', 1.5); hold on;

legend({'墙壁A', '墙壁B', '墙壁C', '第1次', '第2次', '第3次'}, 'Location', 'northeast');

axis equal; 
title('位置估计'); 
```

```matlab
function draw_ellipse(wbar,Gw,eta,color,linewidth)

if (exist('linewidth')==0), linewidth=1;
end
if (exist('color')==0), color='black';
end

s = 0:0.01:2*pi;
a = sqrt(-2*log(1-eta));
w = wbar+a*sqrtm(Gw)*[cos(s); sin(s)];
plot(w(1,:), w(2,:),color,'LineWidth',linewidth)
end
```

```matlab
function [x1, G1, xup, Gup] = kalman(x0, G0, u, y, Galpha, Gbeta, A, C)
    S = C * G0 * C' + Gbeta;
    K = G0 * C'* inv(S);
    ytilde = y - C * x0;
    xup = x0 + K * ytilde;  
    Gup = G0 - K * C * G0;
    x1 = A * xup + u;
    G1 = A * Gup * A' + Galpha;
end

```

![TP_exo_11](/img/kalman/TP_exo_11.png)

在代码中，在初始化变量之后，我们首先绘制了墙壁。然后，利用理论上计算的线性表达式，我们可以计算 $y(i)$ 和 $C(i)$。接下来，使用卡尔曼滤波器进行了三次更新，每次更新使用在上一次更新中获得的参数。最后，通过绘制置信椭圆，可以观察到第一次对汽车位置的迭代并不精确，但第三次对汽车位置的迭代已经相当精确。

我们得到的最终位置 $x$ 是：
$$
X_3 = \begin{bmatrix} 6.2420 \\\\ 4.3446 \end{bmatrix}
$$
计算得到的误差协方差矩阵是：
$$
Gup_3 = \begin{bmatrix} 0.746 & -0.028 \\\\ -0.028 & 0.597 \end{bmatrix}
$$
