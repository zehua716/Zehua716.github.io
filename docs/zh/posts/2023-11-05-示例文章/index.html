<!DOCTYPE html>
<html lang="zh" dir="ltr">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>示例文章 | PaperMod 中文</title>
<meta name="keywords" content="">
<meta name="description" content="图像恢复   &mdash;   TP1
图像反卷积：Wiener-Hunt 方法
主要针对图像去模糊问题，即从模糊(带噪)图像中恢复清晰图像。这属于逆问题的范畴，一半出现在处理真实测量系统时。由于每个测量系统（如温度计、CCD相机、光谱仪等）都受到基础物理学的限制，比如有限精度、有限动态范围、非零响应时间等。这意味着测得的量或多或少都有扭曲。因此这部分是对感兴趣物理量的某种扭曲程度的度量。
大多数情况下，测量系统直接给出的测量数据通常具有足够的精度和鲁棒性。但是，也存在测量结果不准确的情况。为了解决精度问题，或者说至少部分地优化它，已经开发了特殊的信号和图像处理技术。在接下来的内容中，我们将通过一个简单的例子来展示此类方法。
我们有一张未聚焦的图像。这种情况下，点的图像实际上会是一个斑点。捕获的图像将会因为模糊而受损，因为它是由真实图像中每个点生成的斑点的叠加结果。
描述这种转换的最简单模型是线性不变滤波器，即卷积。
在上面的示意图中，$x_{n,m}$ 代表真实或原始图像，$y_{n,m}$ 代表观测到的图像，或者更确切地说，是我们通过相机拍到的未聚焦图像。添加分量 $b_{n,m}$ 是为了考虑测量和建模误差。
描述测量过程的方程(二维)如下：
$$
y_{n,m} = \sum_{p=-P}^{P} \sum_{q=-Q}^{Q} h_{p,q} x_{n-p,m-q} &#43; b_{n,m}
$$
$y_{n,m}$ 是对于每个观测到的像素 $(n, m)$。在这个公式中，$P$ 和 $Q$ 是给定的整数。
注意，滤波器通常来说都是低通滤波器，这就意味着它们无法准确地在输出中再现输入信号或图像中的所有分量，因为高频分量要么被强烈衰减，要么完全被拒绝，这也就是为什么 &lsquo;&lsquo;恢复真实信号&rsquo;&lsquo;或者说&rsquo;&lsquo;图像的逆问题&rsquo;&rsquo; 是如此困难：必须恢复那些要么完全不存在、要么“错误”观测到的高频分量。
在下面的例子中，我们用线性方法来解决图像反卷积问题。这些线性方法依赖于最小二乘准则，并结合了二次惩罚。我们先介绍其理论部分，包括这些准则及其最小化器。此外，展示背后的技术细节，并提出了一种基于循环近似的方法，以实现快速的数值计算。
1. 一维反卷积
为了简化理论概念，我们先讨论在一维情况下的信号反卷积。这种简化情况允许对反卷积问题的分析更加深入，同时更容易掌握概念和思路。随后再引入二维情况，并将其视为一维情况的扩展。Matlab 实现部分仅涉及二维情况。
1.1 一维建模
在一维情况下，(1) 中给出的观测模型变为：
$$
y_n = \sum_{p=-P}^{P} h_p x_{n-p} &#43; b_n
$$
如果我们有 $N$ 个样本，可以将相应的 $N$ 个方程写成矩阵形式：
$$
\mathbf{y} = \mathbf{H} \mathbf{x} &#43; \mathbf{b}
$$


向量 $\mathbf{y}$ 包含了所有的 $N$ 个观测值（在二维情况下，它将包含模糊的图像）。">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="https://zehua716.github.io/zh/posts/2023-11-05-%E7%A4%BA%E4%BE%8B%E6%96%87%E7%AB%A0/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.1b02b89634cb203c0adb2529fde6c2ef5d9909695eb3a05043bdefba6e2b892b.css" integrity="sha256-GwK4ljTLIDwK2yUp/ebC712ZCWles6BQQ73vum4riSs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zehua716.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zehua716.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zehua716.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zehua716.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zehua716.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://zehua716.github.io/zh/posts/2023-11-05-%E7%A4%BA%E4%BE%8B%E6%96%87%E7%AB%A0/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
    integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
    integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
    integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    }); 
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet"><meta property="og:title" content="示例文章" />
<meta property="og:description" content="图像恢复   &mdash;   TP1
图像反卷积：Wiener-Hunt 方法
主要针对图像去模糊问题，即从模糊(带噪)图像中恢复清晰图像。这属于逆问题的范畴，一半出现在处理真实测量系统时。由于每个测量系统（如温度计、CCD相机、光谱仪等）都受到基础物理学的限制，比如有限精度、有限动态范围、非零响应时间等。这意味着测得的量或多或少都有扭曲。因此这部分是对感兴趣物理量的某种扭曲程度的度量。
大多数情况下，测量系统直接给出的测量数据通常具有足够的精度和鲁棒性。但是，也存在测量结果不准确的情况。为了解决精度问题，或者说至少部分地优化它，已经开发了特殊的信号和图像处理技术。在接下来的内容中，我们将通过一个简单的例子来展示此类方法。
我们有一张未聚焦的图像。这种情况下，点的图像实际上会是一个斑点。捕获的图像将会因为模糊而受损，因为它是由真实图像中每个点生成的斑点的叠加结果。
描述这种转换的最简单模型是线性不变滤波器，即卷积。
在上面的示意图中，$x_{n,m}$ 代表真实或原始图像，$y_{n,m}$ 代表观测到的图像，或者更确切地说，是我们通过相机拍到的未聚焦图像。添加分量 $b_{n,m}$ 是为了考虑测量和建模误差。
描述测量过程的方程(二维)如下：
$$
y_{n,m} = \sum_{p=-P}^{P} \sum_{q=-Q}^{Q} h_{p,q} x_{n-p,m-q} &#43; b_{n,m}
$$
$y_{n,m}$ 是对于每个观测到的像素 $(n, m)$。在这个公式中，$P$ 和 $Q$ 是给定的整数。
注意，滤波器通常来说都是低通滤波器，这就意味着它们无法准确地在输出中再现输入信号或图像中的所有分量，因为高频分量要么被强烈衰减，要么完全被拒绝，这也就是为什么 &lsquo;&lsquo;恢复真实信号&rsquo;&lsquo;或者说&rsquo;&lsquo;图像的逆问题&rsquo;&rsquo; 是如此困难：必须恢复那些要么完全不存在、要么“错误”观测到的高频分量。
在下面的例子中，我们用线性方法来解决图像反卷积问题。这些线性方法依赖于最小二乘准则，并结合了二次惩罚。我们先介绍其理论部分，包括这些准则及其最小化器。此外，展示背后的技术细节，并提出了一种基于循环近似的方法，以实现快速的数值计算。
1. 一维反卷积
为了简化理论概念，我们先讨论在一维情况下的信号反卷积。这种简化情况允许对反卷积问题的分析更加深入，同时更容易掌握概念和思路。随后再引入二维情况，并将其视为一维情况的扩展。Matlab 实现部分仅涉及二维情况。
1.1 一维建模
在一维情况下，(1) 中给出的观测模型变为：
$$
y_n = \sum_{p=-P}^{P} h_p x_{n-p} &#43; b_n
$$
如果我们有 $N$ 个样本，可以将相应的 $N$ 个方程写成矩阵形式：
$$
\mathbf{y} = \mathbf{H} \mathbf{x} &#43; \mathbf{b}
$$


向量 $\mathbf{y}$ 包含了所有的 $N$ 个观测值（在二维情况下，它将包含模糊的图像）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zehua716.github.io/zh/posts/2023-11-05-%E7%A4%BA%E4%BE%8B%E6%96%87%E7%AB%A0/" />
<meta property="og:image" content="https://zehua716.github.io/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-11-05T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://zehua716.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="示例文章"/>
<meta name="twitter:description" content="图像恢复   &mdash;   TP1
图像反卷积：Wiener-Hunt 方法
主要针对图像去模糊问题，即从模糊(带噪)图像中恢复清晰图像。这属于逆问题的范畴，一半出现在处理真实测量系统时。由于每个测量系统（如温度计、CCD相机、光谱仪等）都受到基础物理学的限制，比如有限精度、有限动态范围、非零响应时间等。这意味着测得的量或多或少都有扭曲。因此这部分是对感兴趣物理量的某种扭曲程度的度量。
大多数情况下，测量系统直接给出的测量数据通常具有足够的精度和鲁棒性。但是，也存在测量结果不准确的情况。为了解决精度问题，或者说至少部分地优化它，已经开发了特殊的信号和图像处理技术。在接下来的内容中，我们将通过一个简单的例子来展示此类方法。
我们有一张未聚焦的图像。这种情况下，点的图像实际上会是一个斑点。捕获的图像将会因为模糊而受损，因为它是由真实图像中每个点生成的斑点的叠加结果。
描述这种转换的最简单模型是线性不变滤波器，即卷积。
在上面的示意图中，$x_{n,m}$ 代表真实或原始图像，$y_{n,m}$ 代表观测到的图像，或者更确切地说，是我们通过相机拍到的未聚焦图像。添加分量 $b_{n,m}$ 是为了考虑测量和建模误差。
描述测量过程的方程(二维)如下：
$$
y_{n,m} = \sum_{p=-P}^{P} \sum_{q=-Q}^{Q} h_{p,q} x_{n-p,m-q} &#43; b_{n,m}
$$
$y_{n,m}$ 是对于每个观测到的像素 $(n, m)$。在这个公式中，$P$ 和 $Q$ 是给定的整数。
注意，滤波器通常来说都是低通滤波器，这就意味着它们无法准确地在输出中再现输入信号或图像中的所有分量，因为高频分量要么被强烈衰减，要么完全被拒绝，这也就是为什么 &lsquo;&lsquo;恢复真实信号&rsquo;&lsquo;或者说&rsquo;&lsquo;图像的逆问题&rsquo;&rsquo; 是如此困难：必须恢复那些要么完全不存在、要么“错误”观测到的高频分量。
在下面的例子中，我们用线性方法来解决图像反卷积问题。这些线性方法依赖于最小二乘准则，并结合了二次惩罚。我们先介绍其理论部分，包括这些准则及其最小化器。此外，展示背后的技术细节，并提出了一种基于循环近似的方法，以实现快速的数值计算。
1. 一维反卷积
为了简化理论概念，我们先讨论在一维情况下的信号反卷积。这种简化情况允许对反卷积问题的分析更加深入，同时更容易掌握概念和思路。随后再引入二维情况，并将其视为一维情况的扩展。Matlab 实现部分仅涉及二维情况。
1.1 一维建模
在一维情况下，(1) 中给出的观测模型变为：
$$
y_n = \sum_{p=-P}^{P} h_p x_{n-p} &#43; b_n
$$
如果我们有 $N$ 个样本，可以将相应的 $N$ 个方程写成矩阵形式：
$$
\mathbf{y} = \mathbf{H} \mathbf{x} &#43; \mathbf{b}
$$


向量 $\mathbf{y}$ 包含了所有的 $N$ 个观测值（在二维情况下，它将包含模糊的图像）。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://zehua716.github.io/zh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "示例文章",
      "item": "https://zehua716.github.io/zh/posts/2023-11-05-%E7%A4%BA%E4%BE%8B%E6%96%87%E7%AB%A0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "示例文章",
  "name": "示例文章",
  "description": "图像恢复 \u0026mdash; TP1 图像反卷积：Wiener-Hunt 方法 主要针对图像去模糊问题，即从模糊(带噪)图像中恢复清晰图像。这属于逆问题的范畴，一半出现在处理真实测量系统时。由于每个测量系统（如温度计、CCD相机、光谱仪等）都受到基础物理学的限制，比如有限精度、有限动态范围、非零响应时间等。这意味着测得的量或多或少都有扭曲。因此这部分是对感兴趣物理量的某种扭曲程度的度量。\n大多数情况下，测量系统直接给出的测量数据通常具有足够的精度和鲁棒性。但是，也存在测量结果不准确的情况。为了解决精度问题，或者说至少部分地优化它，已经开发了特殊的信号和图像处理技术。在接下来的内容中，我们将通过一个简单的例子来展示此类方法。\n我们有一张未聚焦的图像。这种情况下，点的图像实际上会是一个斑点。捕获的图像将会因为模糊而受损，因为它是由真实图像中每个点生成的斑点的叠加结果。\n描述这种转换的最简单模型是线性不变滤波器，即卷积。\n在上面的示意图中，$x_{n,m}$ 代表真实或原始图像，$y_{n,m}$ 代表观测到的图像，或者更确切地说，是我们通过相机拍到的未聚焦图像。添加分量 $b_{n,m}$ 是为了考虑测量和建模误差。\n描述测量过程的方程(二维)如下： $$ y_{n,m} = \\sum_{p=-P}^{P} \\sum_{q=-Q}^{Q} h_{p,q} x_{n-p,m-q} + b_{n,m} $$ $y_{n,m}$ 是对于每个观测到的像素 $(n, m)$。在这个公式中，$P$ 和 $Q$ 是给定的整数。\n注意，滤波器通常来说都是低通滤波器，这就意味着它们无法准确地在输出中再现输入信号或图像中的所有分量，因为高频分量要么被强烈衰减，要么完全被拒绝，这也就是为什么 \u0026lsquo;\u0026lsquo;恢复真实信号\u0026rsquo;\u0026lsquo;或者说\u0026rsquo;\u0026lsquo;图像的逆问题\u0026rsquo;\u0026rsquo; 是如此困难：必须恢复那些要么完全不存在、要么“错误”观测到的高频分量。\n在下面的例子中，我们用线性方法来解决图像反卷积问题。这些线性方法依赖于最小二乘准则，并结合了二次惩罚。我们先介绍其理论部分，包括这些准则及其最小化器。此外，展示背后的技术细节，并提出了一种基于循环近似的方法，以实现快速的数值计算。\n1. 一维反卷积 为了简化理论概念，我们先讨论在一维情况下的信号反卷积。这种简化情况允许对反卷积问题的分析更加深入，同时更容易掌握概念和思路。随后再引入二维情况，并将其视为一维情况的扩展。Matlab 实现部分仅涉及二维情况。\n1.1 一维建模 在一维情况下，(1) 中给出的观测模型变为：\n$$ y_n = \\sum_{p=-P}^{P} h_p x_{n-p} + b_n $$\n如果我们有 $N$ 个样本，可以将相应的 $N$ 个方程写成矩阵形式： $$ \\mathbf{y} = \\mathbf{H} \\mathbf{x} + \\mathbf{b} $$\n向量 $\\mathbf{y}$ 包含了所有的 $N$ 个观测值（在二维情况下，它将包含模糊的图像）。\n",
  "keywords": [
    
  ],
  "articleBody": "图像恢复 — TP1 图像反卷积：Wiener-Hunt 方法 主要针对图像去模糊问题，即从模糊(带噪)图像中恢复清晰图像。这属于逆问题的范畴，一半出现在处理真实测量系统时。由于每个测量系统（如温度计、CCD相机、光谱仪等）都受到基础物理学的限制，比如有限精度、有限动态范围、非零响应时间等。这意味着测得的量或多或少都有扭曲。因此这部分是对感兴趣物理量的某种扭曲程度的度量。\n大多数情况下，测量系统直接给出的测量数据通常具有足够的精度和鲁棒性。但是，也存在测量结果不准确的情况。为了解决精度问题，或者说至少部分地优化它，已经开发了特殊的信号和图像处理技术。在接下来的内容中，我们将通过一个简单的例子来展示此类方法。\n我们有一张未聚焦的图像。这种情况下，点的图像实际上会是一个斑点。捕获的图像将会因为模糊而受损，因为它是由真实图像中每个点生成的斑点的叠加结果。\n描述这种转换的最简单模型是线性不变滤波器，即卷积。\n在上面的示意图中，$x_{n,m}$ 代表真实或原始图像，$y_{n,m}$ 代表观测到的图像，或者更确切地说，是我们通过相机拍到的未聚焦图像。添加分量 $b_{n,m}$ 是为了考虑测量和建模误差。\n描述测量过程的方程(二维)如下： $$ y_{n,m} = \\sum_{p=-P}^{P} \\sum_{q=-Q}^{Q} h_{p,q} x_{n-p,m-q} + b_{n,m} $$ $y_{n,m}$ 是对于每个观测到的像素 $(n, m)$。在这个公式中，$P$ 和 $Q$ 是给定的整数。\n注意，滤波器通常来说都是低通滤波器，这就意味着它们无法准确地在输出中再现输入信号或图像中的所有分量，因为高频分量要么被强烈衰减，要么完全被拒绝，这也就是为什么 ‘‘恢复真实信号’‘或者说’‘图像的逆问题’’ 是如此困难：必须恢复那些要么完全不存在、要么“错误”观测到的高频分量。\n在下面的例子中，我们用线性方法来解决图像反卷积问题。这些线性方法依赖于最小二乘准则，并结合了二次惩罚。我们先介绍其理论部分，包括这些准则及其最小化器。此外，展示背后的技术细节，并提出了一种基于循环近似的方法，以实现快速的数值计算。\n1. 一维反卷积 为了简化理论概念，我们先讨论在一维情况下的信号反卷积。这种简化情况允许对反卷积问题的分析更加深入，同时更容易掌握概念和思路。随后再引入二维情况，并将其视为一维情况的扩展。Matlab 实现部分仅涉及二维情况。\n1.1 一维建模 在一维情况下，(1) 中给出的观测模型变为：\n$$ y_n = \\sum_{p=-P}^{P} h_p x_{n-p} + b_n $$\n如果我们有 $N$ 个样本，可以将相应的 $N$ 个方程写成矩阵形式： $$ \\mathbf{y} = \\mathbf{H} \\mathbf{x} + \\mathbf{b} $$\n向量 $\\mathbf{y}$ 包含了所有的 $N$ 个观测值（在二维情况下，它将包含模糊的图像）。\n向量 $\\mathbf{x}$ 包含了恢复信号或图像的样本，而 $\\mathbf{b}$ 是噪声样本。\n矩阵 $\\mathbf{H}$，称为模糊矩阵，具有以下经典结构：\n$$ H = \\begin{bmatrix} h_P \u0026 \\cdots \u0026 h_0 \u0026 \\cdots \u0026 h_{-P} \u0026 0 \u0026 0 \u0026 0 \u0026 \\cdots \\\\ 0 \u0026 h_P \u0026 \\cdots \u0026 h_0 \u0026 \\cdots \u0026 h_{-P} \u0026 0 \u0026 0 \u0026 \\cdots \\\\ 0 \u0026 0 \u0026 h_P \u0026 \\cdots \u0026 h_0 \u0026 \\cdots \u0026 h_{-P} \u0026 0 \u0026 \\cdots \\\\ 0 \u0026 0 \u0026 0 \u0026 h_P \u0026 \\cdots \u0026 h_0 \u0026 \\cdots \u0026 h_{-P} \u0026 \\cdots \\\\ \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \\end{bmatrix} $$\n$\\mathbf{H}$ 是一个 $N \\times N$ 的方阵，并且具有 Toeplitz 结构。 因此，信号反卷积问题可以重新表述为: 在已知观测信号 $\\mathbf{y}$ 并知道卷积矩阵 $H$ 的情况下，估计向量 $\\mathbf{x}$\n1.2 带惩罚的最小二乘法 提出的重建策略 (损失函数) 是一种带惩罚的最小二乘法。它包含两个部分：\n一个重构损失项，用于量化恢复信号 $\\mathbf{x}$ 与观测信号 $\\mathbf{y}$ 进行重新卷积后的相似性，从而确保恢复的信号与观测信号一致。 一个惩罚项，用于限制恢复信号的连续样本之间的差异，确保其具有一定的规则性结构。 该准则采用以下表达式：\n$$ J_{\\text{PLS}}(x) = | y - Hx |^2 + \\mu | Dx |^2 = (y - Hx)^t (y - Hx) + \\mu x^t D^t D x $$\n其中，$D$ 是阶数为 1，大小为 $(N - 1) \\times N$ 的差分矩阵，定义如下：\n$$ D = \\begin{bmatrix} \\cdots \u0026 -1 \u0026 1 \u0026 0 \u0026 0 \u0026 \\cdots \\ \\cdots \u0026 0 \u0026 -1 \u0026 1 \u0026 0 \u0026 \\cdots \\ \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \\ \\cdots \u0026 0 \u0026 0 \u0026 -1 \u0026 1 \u0026 \\cdots \\end{bmatrix} $$\n带惩罚的最小二乘准则的最小化器为： $$ \\hat{x} = (H^t H + \\mu D^t D)^{-1} H^t y $$\n证明: $$ \\hat{x} = (H^T H + \\mu D^T D)^{-1} H^T y $$ 我们已知损失准则为: $$ J_{PLS}(x) = (y - Hx)^T(y - Hx) + \\mu x^T D^T Dx $$\n$$ J_{PLS}(x) = y^T y - 2x^T H^T y + x^T H^T H x + \\mu x^T D^T D x $$\n求偏导为0: $$ \\frac{\\partial J_{PLS}(x)}{\\partial x} = -2H^T y + 2H^T H x + 2\\mu D^T D x = 0 $$\n$$ (H^T H + \\mu D^T D) x = H^T y $$\n$$ \\hat{x} = (H^T H + \\mu D^T D)^{-1} H^T y $$\n特殊情况：\n在特定情况下 $\\mu = 0$ 时准则和最小化器的结果表达式变为 $ J_{PLS}(x) = |y - Hx|^2$\n最小化器方程为： $$ H^T H x = H^T y $$\n$$ \\hat{x} = (H^T H)^{-1} H^T y $$\n此时准则变为经典的最小二乘问题，没有正则化项，也就是说，模型仅考虑最小化观测值与预测值之间的误差，而不会惩罚解的复杂度或平滑性。其解是经典的 最小二乘解。\n1.2.1 循环近似 回到公式 (9) ，我们已知矩阵 $H^T H + \\mu D^T D$ 的大小为 $N \\times N$，当 $N$ 很大时，这种反演在计算上非常昂贵甚至不可行。\n比如说在处理图像时，比如对于 $1000 \\times 1000$ 的图像，矩阵的大小为 $10^6 \\times 10^6$ ，计算不了。在三维情况下，更复杂。\n因此为了计算 $\\hat{x}$，有几种方法可以克服这种大计算量的困难。\n下面我们考虑使用循环矩阵的特性，因为我们可以用对角矩阵来 “替换” 公式 (9) 中的矩阵 (通过快速傅里叶变换 FFT 可以将循环矩阵 “转化”为对角矩阵)。因此，使用对角矩阵进行计算时，乘法或反演等矩阵运算的复杂度将大大降低。\n但是，这需要先将矩阵 $H$ 和 $D$ 近似为循环矩阵 $\\tilde{H}$ 和 $\\tilde{D}$。\n循环近似涉及修改矩阵的右上角和/或左下角部分，使其具有循环结构。这种近似的核心假设是信号或图像在开始和结束部分是周期性的，即信号的末尾与开头相连接，形成一个环状结构。\n循环卷积矩阵 $\\tilde{H}$ 和 $\\tilde{D}$ 在傅里叶基下可以轻松对角化： $$ \\tilde{H} = F^T \\Lambda_h F \\quad \\text{和} \\quad \\tilde{D} = F^T \\Lambda_d F $$ 矩阵 $\\Lambda_h$ 是对角矩阵，其对角线上元素是 $H$ 的特征值。\n特征值可以通过对矩阵 $H$ 第一行进行快速傅里叶变换（FFT）获得，即计算脉冲响应的 N 点 FFT，这些响应代表频率响应的样本。\n同样适用于矩阵 $\\tilde{D}$ 及其特征值，其中将脉冲响应替换为 $[-1, 1]$。\n通过在 (9) 中用 (18) 代替，并使用简单的矩阵操作，可以得到： $$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h} + \\mu \\Lambda_{d}^{\\dagger} \\Lambda_{d})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n证明：\n补充知识: $\\tilde{H}$ 是一个实矩阵，因此其复共轭等于它本身，$\\tilde{H} = \\tilde{H}^T$ 。 $\\tilde{D}$ 同理\n在近似为循环矩阵后，公式 (15) 变为: $$ \\hat{x} = (\\tilde{H}^{T}\\tilde{H} + \\mu \\tilde{D}^{T}\\tilde{D})^{-1}\\tilde{H}^{T}y $$ 其中: $\\tilde{H} = F^T \\Lambda_h F$ 且 $ \\tilde{D} = F^T \\Lambda_d F$ 将其带入上述公式，得: $$ \\hat{x} = ((F^{T}\\Lambda_{h}F)^{T}(F^{T}\\Lambda_{h}F) + \\mu (F^{T}\\Lambda_{d}F)^{T}(F^{T}\\Lambda_{d}F))^{-1}(F^{T}\\Lambda_{h}F)^{T}y $$ 因为傅里叶矩阵 $F$ 是一个正交矩阵，具有 $F F^{T} = I$ 的性质，即 $F^{T} = F^{-1}$\n并且我们有 $(F^{T}\\Lambda_{h}F)^{T} = F^{T}\\Lambda_{h}^{T}F$ 以及 $(F^{T}\\Lambda_{d}F)^{T} = F^{T}\\Lambda_{d}^{T}F$\n所以: $$ \\hat{x} = (F^{T}\\Lambda_{h}^{T}\\Lambda_{h}F + \\mu F^{T}\\Lambda_{d}^{T}\\Lambda_{d}F)^{-1} F^{T}\\Lambda_{h}^{T}F y $$\n$$ \\hat{x} = F^{T}(\\Lambda_{h}^{T}\\Lambda_{h} + \\mu \\Lambda_{d}^{T}\\Lambda_{d})^{-1} \\Lambda_{h}^{T}F y $$\n$$ 令\\quad \\overset{\\circ}{\\hat{x}} = F \\hat{x}, \\quad \\overset{\\circ}{y} = F y $$\n那么: $$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h} + \\mu \\Lambda_{d}^{\\dagger} \\Lambda_{d})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$ 特殊情况：\n当 $\\mu = 0$ 时，正则化项消失，公式简化为： $$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$ 这意味着我们仅仅执行了经典的 Wiener 去卷积，没有考虑图像的正则化。 $$ \\hat{x} = (\\tilde{H}^{T}\\tilde{H} )^{-1}\\tilde{H}^{T}y\\ $$\n没有正则化时，虽然理论上可以恢复原始信号，但是实际上收到的噪声影响很大，且没有约束来将其消除\n为了完成我们的讨论，我们首先构建向量 $g_{\\text{PLS}}$，其分量定义如下： $$ g_{PLS}^{n} = \\frac{\\overset{\\circ}{h}{n}^{*}}{|\\overset{\\circ}{h}{n}|^2 + \\mu |\\overset{\\circ}{d}_{n}|^2} \\quad \\text{for } n = 1, 2, \\dots, N $$\n因此，向量 $\\overset{\\circ}{\\hat{x}}$ 是通过向量 $g_{\\text{PLS}}$ 和 $\\overset{\\circ}{\\hat{y}}$ 之间逐元素相乘得到的： $$ \\overset{\\circ}{\\hat{x}} = g_{\\text{PLS}} .* \\overset{\\circ}{\\hat{y}} $$ 反卷积问题可以表述为在傅里叶域中进行的滤波操作，其中 $g_{\\text{PLS}}$ 代表离散传递函数。\n反卷积问题总结如下：\n① 构建 $\\mathring{h}$ 作为脉冲响应的 $N$ 点 FFT\n② 构建 $\\mathring{d}$ 作为 $[1; -1]$ 的 $N$ 点 FFT\n③ 构建包含传递函数 $g_{\\text{PLS}}$ 的向量\n④ 构建观测值的 FFT $\\mathring{y}$\n⑤ 计算 $\\mathring{\\hat{x}}$，作为传递函数 $g_{\\text{PLS}}$ 和 $\\mathring{\\hat{y}}$ 的乘积\n⑥ 计算 $\\mathring{\\hat{x}}$ 的 IFFT 以在空间域中获得解 $\\hat{x}$\n2 实现 2.1 二维方法 对于二维情况，可以给出类似于一维情况的方程。然而，所涉及的矩阵结构更加复杂: block-Tœplitz 矩阵，每个块本身也具有 Tœplitz 结构。这使得在两个方向上进行循环近似变得更加困难。因此，二维情况仅作为一维情况的扩展来展示，重点是 Matlab 实现。\n注意以下几点：\n图像、脉冲响应、正则化项都是二维的，这意味着必须使用 FFT-2D 而不是 FFT。 更确切地说，如果要恢复的图像有 N 行和 N 列，那么 FFT-2D 必须在 N 行和 N 列上计算。 频率传递函数也是二维的，每个空间频率有一个维度。 特别说明 — 在任何情况下，矩阵 H 和 D 都不应在 Matlab 代码中构建。\n2.2 观测图像 第一步是加载文件 Data1 和 Data2 中提供的数据。这可以通过使用 load 函数完成。每个文件包含：模糊图像 (Data)、用于比较的真实图像 (TrueIma)，以及卷积滤波器的脉冲响应 (IR)。现在分析每个数据集及其相互关系。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 close all, clear all clc %% 第1部分：加载图像数据 % 加载第一组数据，包括模糊图像和真实图像 DataOne = load('DataOne.mat'); image_One = DataOne.Data; True_image_One = DataOne.TrueImage; % 加载第二组数据，包括模糊图像和真实图像 DataTwo = load('DataTwo.mat'); image_Two = DataTwo.Data; True_image_Two = DataTwo.TrueImage; %% 第2部分：显示两幅图像 % 创建一个图形窗口以显示两幅图像 figure(1), clf % 显示第一幅图像 subplot(1, 2, 1) imagesc(image_One) colormap('gray') colorbar axis square off title('Image One') % 显示第二幅图像 subplot(1, 2, 2) imagesc(image_Two) colormap('gray') colorbar axis square off title('Image Two') 对每个观察到的图像的模糊程度进行评论。 在频域中分析图像（同时使用线性和对数刻度）并提供适当的评论。花时间识别两个频率轴，必须正确标注零频率、低频、高频等。在你的报告中适当地展示这些结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 %% 第3部分：图像的频域分析 % 计算第一幅图像的二维傅里叶变换，并将零频移到中心 fft_image_One = MyFFT2(image_One); fft_image_One_shifted = fftshift(fft_image_One); % 计算第一幅图像频谱的幅值 magnitude_spectrum_One = abs(fft_image_One_shifted); % 计算第二幅图像的二维傅里叶变换，并将零频移到中心 fft_image_Two = MyFFT2(image_Two); fft_image_Two_shifted = fftshift(fft_image_Two); % 计算第二幅图像频谱的幅值 magnitude_spectrum_Two = abs(fft_image_Two_shifted); % 生成频率轴，用于第一幅图像 rows_One = size(image_One, 1); % 获取行数 cols_One = size(image_One, 2); % 获取列数 freq_axis_One = -0.5 : 1/cols_One : 0.5 - 1/cols_One; % 创建频率轴 freq_axis_One = fftshift(freq_axis_One); % 将频率轴中心化 % 生成频率轴，用于第二幅图像 rows_Two = size(image_Two, 1); cols_Two = size(image_Two, 2); freq_axis_Two = -0.5 : 1/cols_Two : 0.5 - 1/cols_Two; freq_axis_Two = fftshift(freq_axis_Two); %% 第4部分：显示频谱分析结果 % 在线性尺度下显示第一幅图像的频谱 figure(3), clf subplot(2, 2, 1) imagesc(freq_axis_One, freq_axis_One, magnitude_spectrum_One) colormap('jet') axis square title('Image One - Échelle Linéaire') xlabel('Fréquence horizontale (axe de fréquence)') ylabel('Fréquence verticale (axe de fréquence)') % 在线性尺度下显示第二幅图像的频谱 subplot(2, 2, 2) imagesc(freq_axis_Two, freq_axis_Two, magnitude_spectrum_Two) colormap('jet') axis square title('Image Two - Échelle Linéaire') xlabel('Fréquence horizontale (axe de fréquence)') ylabel('Fréquence verticale (axe de fréquence)') % 在对数尺度下显示第一幅图像的频谱 subplot(2, 2, 3) imagesc(freq_axis_One, freq_axis_One, log(1 + magnitude_spectrum_One)) colormap('jet') axis square title('Image One - Échelle Logarithmique') xlabel('Fréquence horizontale (axe de fréquence)') ylabel('Fréquence verticale (axe de fréquence)') % 在对数尺度下显示第二幅图像的频谱 subplot(2, 2, 4) imagesc(freq_axis_Two, freq_axis_Two, log(1 + magnitude_spectrum_Two)) colormap('jet') axis square title('Image Two - Échelle Logarithmique') xlabel('Fréquence horizontale (axe de fréquence)') ylabel('Fréquence verticale (axe de fréquence)') ​\t零频率 位于图像的中心，对应图像中的平均亮度。零频率处的值越高，意味着图像的整体亮度较高。\n​\t低频成分 主要反映图像中的大尺度结构或平滑区域。低频越强，图像的模糊程度越高。\n​\t高频成分 对应图像的细节和边缘。模糊的图像高频成分较少，这表明细节被模糊化了。\n显示两个脉冲响应 $h_{n,m}$ 及其关联的传递函数 $H(\\nu_x, \\nu_y)$ 。\n首先使用 imagesc 函数，然后使用 plot 函数。正确地在每个轴上标记它们。在你的报告中适当地展示这些结果。什么类型的滤波器是它们？高通还是低通？两个滤波器之间的差异是什么？\n我们假设有两个不同的脉冲响应 h_1 和 h_2 ，可以分别计算它们的传递函数，并比较它们的频率响应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 %% 第5部分：显示脉冲响应和传递函数 % 加载第一组数据的脉冲响应 h1 = DataOne.IR; % 加载第二组数据的脉冲响应 h2 = DataTwo.IR; % 计算第一幅图像的脉冲响应的傅里叶变换 H1 = abs(MyFFT2RI(h1,length(image_One))); % 计算第二幅图像的脉冲响应的傅里叶变换 H2 = abs(MyFFT2RI(h2,length(image_Two))); % 计算第一幅图像的传递函数 transfer_function_h1 = MyFFT2RI(h1, size(image_One, 1)); % 计算第二幅图像的传递函数 transfer_function_h2 = MyFFT2RI(h2, size(image_Two, 1)); % 显示第一幅图像的脉冲响应和传递函数 figure(4), clf subplot(2, 2, 1) imagesc(H1) axis square off title('Réponse Impulsionnelle H1[n,m]') colormap('gray') subplot(2, 2, 2) imagesc(fftshift(log(1 + abs(transfer_function_h1)))) axis square off title('Fonction de Transfert H1(νx, νy)') colormap('jet') % 显示第二幅图像的脉冲响应和传递函数 subplot(2, 2, 3) imagesc(H2) axis square off title('Réponse Impulsionnelle H2[n,m]') colormap('gray') subplot(2, 2, 4) imagesc(fftshift(log(1 + abs(transfer_function_h2)))) axis square off title('Fonction de Transfert H2(νx, νy)') colormap('jet') %% 第6部分：使用 plot 显示传递函数沿某一线的切片 % 显示第一幅图像的传递函数沿 νx 方向的切片 figure(5), clf line_profile_One = abs(fftshift(fft(H1(size(H1, 1)/2, :)))); subplot(2, 1, 1) plot(line_profile_One) title('Transfer Function H1(νx) along a Line') xlabel('Frequency (νx)') ylabel('Magnitude') % 显示第二幅图像的传递函数沿 νx 方向的切片 line_profile_Two = abs(fftshift(fft(H2(size(H2, 1)/2, :)))); subplot(2, 1, 2) plot(line_profile_Two) title('Transfer Function H2(νx) along a Line') xlabel('Frequency (νx)') ylabel('Magnitude') 2.3 Implementation Matlab 代码将在二维情况下实现反卷积，使用带有二次惩罚项的最小二乘法。该准则将使用第一节中提出的循环近似进行最小化，并在第4页进行了总结。\n关于正则化项，它依赖于图像列和行上相邻像素之间的差异。它的表达式为：\n$$ | D x |^2 = \\sum_{n,m} (x_{n,m} - x_{n,m+1})^2 + (x_{n,m} - x_{n+1,m})^2 $$\n并且它将基于两个滤波器来实现：\n$$ \\begin{bmatrix} 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 -1 \u0026 1 \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} \\quad \\text{and} \\quad \\begin{bmatrix} 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 -1 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \\end{bmatrix} $$\n这些滤波器计算列和行上像素之间的差异。也可以使用带有以下脉冲响应的唯一滤波器：\n$$ \\begin{bmatrix} 0 \u0026 -1 \u0026 0 \\\\ -1 \u0026 4 \u0026 -1 \\\\ 0 \u0026 -1 \u0026 0 \\end{bmatrix} \\quad or \\quad \\begin{bmatrix} -1 \u0026 -1 \u0026 -1 \\\\ -1 \u0026 8 \u0026 -1 \\\\ -1 \u0026 -1 \u0026 -1 \\end{bmatrix} \\quad or \\quad \\begin{bmatrix} 1 \u0026 -2 \u0026 1 \\\\ -2 \u0026 4 \u0026 -2 \\\\ 1 \u0026 -2 \u0026 1 \\end{bmatrix} $$ 它们实现了各种图像梯度的近似。\n在一个函数中实现反卷积，该函数以观测到的图像、脉冲响应和正则化参数作为输入。\n正则化项 $| D x |^2$ 代表了水平方向和垂直方向相邻像素值的平方差之和。 $$ D_{horiz} = \\begin{bmatrix} 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 -1 \u0026 1 \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} \\quad \\quad \\quad D_{vert} = \\begin{bmatrix} 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 -1 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \\end{bmatrix} $$ 前面我们得到： $$ \\hat{x} = (H^{T}H + \\mu D^{T}D)^{-1}H^{T}y $$ 现在进行傅里叶变换下的去卷积（在频域处理） $$ \\hat{x}(\\nu_{x}, \\nu_{y}) = \\frac{\\hat{H}^{*}(\\nu_{x}, \\nu_{y}) \\hat{y}(\\nu_{x}, \\nu_{y})}{|\\hat{H}(\\nu_{x}, \\nu_{y})|^2 + \\mu |\\hat{D}(\\nu_{x}, \\nu_{y})|^2} $$\n$\\hat{H}(\\nu_{x}, \\nu_{y})$ 是卷积矩阵的傅里叶变换 $\\hat{D}(\\nu_{x}, \\nu_{y})$ 是差分矩阵的傅里叶变换 $\\hat{x}(\\nu_{x}, \\nu_{y})$ 是频域中的恢复图像 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 function x_est = deconvolve_2D(y, h, mu) % y: 输入模糊图像 % h: 脉冲响应（卷积核） % mu: 正则化参数 % 计算卷积核的傅里叶变换 H = MyFFT2RI(h, length(y)); % 构造正则化滤波器 % 构造D矩阵，使用卷积实现邻近像素差分 D_horiz = [0 0 0; 0 -1 1; 0 0 0]; % 水平方向滤波器 D_vert = [0 0 0; 0 -1 0; 0 1 0]; % 垂直方向滤波器 % 计算D矩阵的傅里叶变换 D_horiz_fft = MyFFT2RI(D_horiz, length(y)); %这里length(y)正确与否不确定 D_vert_fft = MyFFT2RI(D_vert, length(y)); % 计算观测图像的傅里叶变换 Y = MyFFT2(y); % 构建正则化项的频率表达式 Reg_term = abs(D_horiz_fft).^2 + abs(D_vert_fft).^2; % 构建Wiener滤波器，带正则化项 H_conj = conj(H); X = (H_conj .* Y) ./ (abs(H).^2 + mu * Reg_term); % 反傅里叶变换返回空间域 x_est = real(MyIFFT2(F)); end 首先考虑简单的逆滤波器情况，即 $µ = 0$ 。分析并评论对每个数据集得到的结果。\n前面我们得到：\t$\\hat{x} = (H^{T}H + \\mu D^{T}D)^{-1}H^{T}y$\n现在变成：\t$\\hat{x} = (H^{T}H)^{-1}H^{T}y$ $$ \\hat{x}(\\nu_{x}, \\nu_{y}) = \\frac{\\hat{H}^{*}(\\nu_{x}, \\nu_{y}) \\hat{y}(\\nu_{x}, \\nu_{y})}{|\\hat{H}(\\nu_{x}, \\nu_{y})|^2 } $$\n$\\hat{H}(\\nu_{x}, \\nu_{y})$ 是卷积矩阵的傅里叶变换\n$\\hat{D}(\\nu_{x}, \\nu_{y})$ 是差分矩阵的傅里叶变换\n$\\hat{x}(\\nu_{x}, \\nu_{y})$ 是频域中的恢复图像\n当 µ = 0 时，去卷积过程依赖于直接反演卷积核的傅里叶系数。然而，这对噪声非常敏感，特别是当卷积核的某些频率接近零时，直接反演会导致噪声被放大。\n分析对不同 µ 值（在 log_10 刻度上取值）的结果。评论在空间域和频域中获得的结果。不同的 µ 值如何影响每个数据集的反卷积图像？通过试验和误差及视觉检查结果，确定合适的 µ值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 mu_values = logspace(-10, 10, 100); % 生成从 10^-10 到 10^10 的 \\mu 值 errors = zeros(size(mu_values)); % 用于存储每个 \\mu 对应的误差 for i = 1:length(mu_values) mu = mu_values(i); x_est = deconvolve_2D(y, h, mu); % 进行去卷积 % 计算去卷积结果与真实图像的误差 errors(i) = norm(x_est - true_image, 'fro'); % 使用 Frobenius 范数计算误差 end % 绘制 \\mu 与误差之间的关系 figure; loglog(mu_values, errors); xlabel('\\mu (log scale)'); ylabel('Error'); title('Regularization Parameter \\mu vs. Reconstruction Error'); 2.4 超参数的作用\n上一点使我们能够评估与反卷积问题相关的内在难度。它还表明，考虑可用的关于重建图像期望正则性的先验信息可以获得更好的结果。这种方法因此使我们能够在两种信息源之间进行折衷：观测数据和可用的 a priori 信息（关于正则性）。这是通过参数 µ 的值来实现的。在本研究中，µ 的值是通过经验选择的，以使反卷积图像既不过于平滑也不过于不规则。\n在这里研究的“玩具示例”中，真实图像已知，即从中生成观测数据的图像已知。\n因此，可以计算反卷积图像 $\\hat{x}$ 和真实图像 $x^*$ 之间的数值差异，作为正则化参数 $\\mu$ 的函数。\n为此，考虑以下三种距离函数： $$ \\begin{aligned} \\Delta_2(\\mu) \u0026= \\frac{\\sum_{p,q} \\left( \\hat{x}{p,q}(\\mu) - x^{\\star}{p,q} \\right)^2}{\\sum_{p,q} \\left( x^{\\star}{p,q} \\right)^2} = \\frac{|\\hat{x}(\\mu) - x^{\\star}|2^2}{|x^{\\star}|2^2} \\ \\Delta_1(\\mu) \u0026= \\frac{\\sum{p,q} \\left| \\hat{x}{p,q}(\\mu) - x^{\\star}{p,q} \\right|}{\\sum_{p,q} \\left| x^{\\star}{p,q} \\right|} = \\frac{|\\hat{x}(\\mu) - x^{\\star}|1}{|x^{\\star}|1} \\ \\Delta{\\infty}(\\mu) \u0026= \\frac{\\max{p,q} \\left| \\hat{x}{p,q}(\\mu) - x^{\\star}{p,q} \\right|}{\\max{p,q} \\left| x^{\\star}{p,q} \\right|} = \\frac{|\\hat{x}(\\mu) - x^{\\star}|{\\infty}}{|x^{\\star}|_{\\infty}} \\end{aligned} $$\n当恢复的图像类似于真实图像时，这些距离接近于0，当恢复的图像为零时，它们接近1。\n计算一组 $\\mu$ 值的距离，例如在 $10^{-10}$ 和 $10^{10}$ 之间的对数间隔值。给出最小化每个距离函数的 $\\mu$ 值，并将结果与先前选择的经验值进行比较（应主要关注第二个数据集 Data2）。\n[!IMPORTANT]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 function [best_mu, delta2_values, delta1_values, delta_inf_values] = find_best_mu(y, h, true_image) % y: 输入模糊图像 % h: 脉冲响应（卷积核） % true_image: 已知的真实图像 % 返回最优的 mu 值，以及每个 mu 对应的距离度量结果 % 计算真实图像的不同范数 true_image_norm2 = norm(true_image(:), 2)^2; % 二范数的平方 true_image_norm1 = norm(true_image(:), 1); % 一范数 true_image_norm_inf = norm(true_image(:), Inf); % 无穷范数 H = MyFFT2RI(h, length(y)); % 计算卷积核的傅里叶变换 % H = fft2(h, size(y, 1), size(y, 2)); %如果上面报错 用下面的尺度 Y = MyFFT2(y); % 计算观测图像的傅里叶变换 % 构造正则化滤波器 % 构造D矩阵，使用卷积实现邻近像素差分 D_horiz = [0 0 0; 0 -1 1; 0 0 0]; % 水平方向滤波器 D_vert = [0 0 0; 0 -1 0; 0 1 0]; % 垂直方向滤波器 % 计算D矩阵的傅里叶变换 D_horiz_fft = MyFFT2RI(D_horiz, length(y)); %这里length(y)正确与否不确定 D_vert_fft = MyFFT2RI(D_vert, length(y)); % 构建正则化项的频率表达式 Reg_term = abs(D_horiz_fft).^2 + abs(D_vert_fft).^2; % 正则化参数的范围，取对数间隔 mu_values = logspace(-10, 10, 100); % 存储每个 mu 对应的距离度量值 delta2_values = zeros(length(mu_values), 1); delta1_values = zeros(length(mu_values), 1); delta_inf_values = zeros(length(mu_values), 1); % 逐个计算不同 mu 下的去卷积结果 for i = 1:length(mu_values) mu = mu_values(i); % 构建 Wiener 滤波器 H_conj = conj(H); % 卷积核的复共轭 F = H_conj ./ (abs(H).^2 + mu * Reg_term); % 滤波器 % 使用 Wiener 滤波器对傅里叶域中的观测图像进行滤波 X_est = F .* Y; % 反傅里叶变换返回空间域 x_est = real(MyIFFT2(F)); % 计算三种距离度量 delta2_values(i) = norm(x_est(:) - true_image(:), 2)^2 / true_image_norm2; delta1_values(i) = norm(x_est(:) - true_image(:), 1) / true_image_norm1; delta_inf_values(i) = norm(x_est(:) - true_image(:), Inf) / true_image_norm_inf; end %% 找到使二范数误差最小的 mu [~, min_idx] = min(delta2_values); best_mu = mu_values(min_idx); % 可视化距离度量随 mu 的变化 figure; loglog(mu_values, delta2_values, 'r-', 'LineWidth', 2); hold on; loglog(mu_values, delta1_values, 'b-', 'LineWidth', 2); loglog(mu_values, delta_inf_values, 'g-', 'LineWidth', 2); xlabel('\\mu'); ylabel('Distance Metrics'); legend('\\Delta_2(\\mu)', '\\Delta_1(\\mu)', '\\Delta_\\infty(\\mu)'); title('Distance Metrics vs. \\mu'); grid on; end ",
  "wordCount" : "2244",
  "inLanguage": "zh",
  "image": "https://zehua716.github.io/images/papermod-cover.png","datePublished": "2023-11-05T00:00:00Z",
  "dateModified": "2023-11-05T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Theme PaperMod"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zehua716.github.io/zh/posts/2023-11-05-%E7%A4%BA%E4%BE%8B%E6%96%87%E7%AB%A0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod 中文",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zehua716.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zehua716.github.io/zh/" accesskey="h" title="PaperMod 中文 (Alt + H)">PaperMod 中文</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://zehua716.github.io/" title="English"
                            aria-label="English">English</a>
                    </li>
                    <li>
                        <a href="https://zehua716.github.io/fr/" title="French"
                            aria-label=":fr:">🇫🇷</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zehua716.github.io/zh/cntags" title="CNTags">
                    <span>CNTags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://zehua716.github.io/zh/">主页</a>&nbsp;»&nbsp;<a href="https://zehua716.github.io/zh/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      示例文章
    </h1>
    <div class="post-meta"><span title='2023-11-05 00:00:00 +0000 UTC'>十一月 5, 2023</span>&nbsp;·&nbsp;11 分钟&nbsp;·&nbsp;Theme PaperMod&nbsp;|&nbsp;<a href="https://github.com/zehua716/Zehua716.github.io/tree/main/content/posts/2023-11-05-%e7%a4%ba%e4%be%8b%e6%96%87%e7%ab%a0.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details >
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e5%9b%be%e5%83%8f%e6%81%a2%e5%a4%8d---------tp1" aria-label="图像恢复 &mdash; TP1"><strong>图像恢复   &mdash;   TP1</strong></a><ul>
                            <ul>
                            
                    <li>
                        <a href="#%e5%9b%be%e5%83%8f%e5%8f%8d%e5%8d%b7%e7%a7%afwiener-hunt-%e6%96%b9%e6%b3%95" aria-label="图像反卷积：Wiener-Hunt 方法"><strong>图像反卷积：Wiener-Hunt 方法</strong></a></li>
                    <li>
                        <a href="#1-%e4%b8%80%e7%bb%b4%e5%8f%8d%e5%8d%b7%e7%a7%af" aria-label="1. 一维反卷积">1. 一维反卷积</a><ul>
                            
                    <li>
                        <a href="#11-%e4%b8%80%e7%bb%b4%e5%bb%ba%e6%a8%a1" aria-label="1.1 一维建模">1.1 一维建模</a></li>
                    <li>
                        <a href="#12-%e5%b8%a6%e6%83%a9%e7%bd%9a%e7%9a%84%e6%9c%80%e5%b0%8f%e4%ba%8c%e4%b9%98%e6%b3%95" aria-label="1.2 带惩罚的最小二乘法">1.2 带惩罚的最小二乘法</a><ul>
                            
                    <li>
                        <a href="#121-%e5%be%aa%e7%8e%af%e8%bf%91%e4%bc%bc" aria-label="1.2.1 循环近似">1.2.1 循环近似</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#2-%e5%ae%9e%e7%8e%b0" aria-label="2 实现">2 实现</a><ul>
                            
                    <li>
                        <a href="#21-%e4%ba%8c%e7%bb%b4%e6%96%b9%e6%b3%95" aria-label="2.1 二维方法">2.1 二维方法</a></li>
                    <li>
                        <a href="#22-%e8%a7%82%e6%b5%8b%e5%9b%be%e5%83%8f" aria-label="2.2 观测图像"><strong>2.2 观测图像</strong></a></li>
                    <li>
                        <a href="#23-implementation" aria-label="2.3 Implementation">2.3 Implementation</a>
                    </li>
                </ul>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="图像恢复---------tp1"><strong>图像恢复   &mdash;   TP1</strong><a hidden class="anchor" aria-hidden="true" href="#图像恢复---------tp1">#</a></h1>
<h3 id="图像反卷积wiener-hunt-方法"><strong>图像反卷积：Wiener-Hunt 方法</strong><a hidden class="anchor" aria-hidden="true" href="#图像反卷积wiener-hunt-方法">#</a></h3>
<p>主要针对图像去模糊问题，即从模糊(带噪)图像中恢复清晰图像。这属于逆问题的范畴，一半出现在处理真实测量系统时。由于每个测量系统（如温度计、CCD相机、光谱仪等）都受到基础物理学的限制，比如有限精度、有限动态范围、非零响应时间等。这意味着测得的量或多或少都有扭曲。因此这部分是对感兴趣物理量的某种扭曲程度的度量。</p>
<p>大多数情况下，测量系统直接给出的测量数据通常具有足够的精度和鲁棒性。但是，也存在测量结果不准确的情况。为了解决精度问题，或者说至少部分地优化它，已经开发了特殊的信号和图像处理技术。在接下来的内容中，我们将通过一个简单的例子来展示此类方法。</p>
<p>我们有一张未聚焦的图像。这种情况下，点的图像实际上会是一个斑点。捕获的图像将会因为模糊而受损，因为它是由真实图像中每个点生成的斑点的叠加结果。</p>
<p>描述这种转换的最简单模型是线性不变滤波器，即卷积。</p>
<p>在上面的示意图中，$x_{n,m}$ 代表真实或原始图像，$y_{n,m}$ 代表观测到的图像，或者更确切地说，是我们通过相机拍到的未聚焦图像。添加分量 $b_{n,m}$ 是为了考虑测量和建模误差。</p>
<p>描述测量过程的方程(二维)如下：
$$
y_{n,m} = \sum_{p=-P}^{P} \sum_{q=-Q}^{Q} h_{p,q} x_{n-p,m-q} + b_{n,m}
$$
$y_{n,m}$ 是对于每个观测到的像素 $(n, m)$。在这个公式中，$P$ 和 $Q$ 是给定的整数。</p>
<p>注意，滤波器通常来说都是低通滤波器，这就意味着它们无法准确地在输出中再现输入信号或图像中的所有分量，因为高频分量要么被强烈衰减，要么完全被拒绝，这也就是为什么 &lsquo;&lsquo;恢复真实信号&rsquo;&lsquo;或者说&rsquo;&lsquo;图像的逆问题&rsquo;&rsquo; 是如此困难：必须恢复那些要么完全不存在、要么“错误”观测到的高频分量。</p>
<p>在下面的例子中，我们用线性方法来解决图像反卷积问题。这些线性方法依赖于最小二乘准则，并结合了二次惩罚。我们先介绍其理论部分，包括这些准则及其最小化器。此外，展示背后的技术细节，并提出了一种基于循环近似的方法，以实现快速的数值计算。</p>
<h3 id="1-一维反卷积">1. 一维反卷积<a hidden class="anchor" aria-hidden="true" href="#1-一维反卷积">#</a></h3>
<p>为了简化理论概念，我们先讨论在一维情况下的信号反卷积。这种简化情况允许对反卷积问题的分析更加深入，同时更容易掌握概念和思路。随后再引入二维情况，并将其视为一维情况的扩展。Matlab 实现部分仅涉及二维情况。</p>
<h4 id="11-一维建模">1.1 一维建模<a hidden class="anchor" aria-hidden="true" href="#11-一维建模">#</a></h4>
<p>在一维情况下，(1) 中给出的观测模型变为：</p>
<p>$$
y_n = \sum_{p=-P}^{P} h_p x_{n-p} + b_n
$$</p>
<p>如果我们有 $N$ 个样本，可以将相应的 $N$ 个方程写成矩阵形式：
$$
\mathbf{y} = \mathbf{H} \mathbf{x} + \mathbf{b}
$$</p>
<ul>
<li>
<p>向量 $\mathbf{y}$ 包含了所有的 $N$ 个观测值（在二维情况下，它将包含模糊的图像）。</p>
</li>
<li>
<p>向量 $\mathbf{x}$ 包含了恢复信号或图像的样本，而 $\mathbf{b}$ 是噪声样本。</p>
</li>
<li>
<p>矩阵 $\mathbf{H}$，称为模糊矩阵，具有以下经典结构：</p>
</li>
</ul>
<p>$$
H = \begin{bmatrix}
h_P &amp; \cdots &amp; h_0 &amp; \cdots &amp; h_{-P} &amp; 0 &amp; 0 &amp; 0 &amp; \cdots \\
0 &amp; h_P &amp; \cdots &amp; h_0 &amp; \cdots &amp; h_{-P} &amp; 0 &amp; 0 &amp; \cdots \\
0 &amp; 0 &amp; h_P &amp; \cdots &amp; h_0 &amp; \cdots &amp; h_{-P} &amp; 0 &amp; \cdots \\
0 &amp; 0 &amp; 0 &amp; h_P &amp; \cdots &amp; h_0 &amp; \cdots &amp; h_{-P} &amp; \cdots \\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots
\end{bmatrix}
$$</p>
<ul>
<li>$\mathbf{H}$ 是一个 $N \times N$ 的方阵，并且具有 Toeplitz 结构。</li>
</ul>
<p>因此，信号反卷积问题可以重新表述为: 在已知观测信号 $\mathbf{y}$ 并知道卷积矩阵 $H$ 的情况下，估计向量 $\mathbf{x}$</p>
<h4 id="12-带惩罚的最小二乘法">1.2 带惩罚的最小二乘法<a hidden class="anchor" aria-hidden="true" href="#12-带惩罚的最小二乘法">#</a></h4>
<p>提出的重建策略 (损失函数) 是一种带惩罚的最小二乘法。它包含两个部分：</p>
<ul>
<li>一个重构损失项，用于量化恢复信号  $\mathbf{x}$ 与观测信号 $\mathbf{y}$ 进行重新卷积后的相似性，从而确保恢复的信号与观测信号一致。</li>
<li>一个惩罚项，用于限制恢复信号的连续样本之间的差异，确保其具有一定的规则性结构。</li>
</ul>
<p>该准则采用以下表达式：</p>
<p>$$
J_{\text{PLS}}(x) = | y - Hx |^2 + \mu | Dx |^2
= (y - Hx)^t (y - Hx) + \mu x^t D^t D x
$$</p>
<p>其中，$D$ 是阶数为 1，大小为 $(N - 1) \times N$ 的差分矩阵，定义如下：</p>
<p>$$
D = \begin{bmatrix}
\cdots &amp; -1 &amp; 1 &amp; 0 &amp; 0 &amp; \cdots \
\cdots &amp; 0 &amp; -1 &amp; 1 &amp; 0 &amp; \cdots \
\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \
\cdots &amp; 0 &amp; 0 &amp; -1 &amp; 1 &amp; \cdots
\end{bmatrix}
$$</p>
<p>带惩罚的最小二乘准则的最小化器为：
$$
\hat{x} = (H^t H + \mu D^t D)^{-1} H^t y
$$</p>
<p>证明:
$$
\hat{x} = (H^T H + \mu D^T D)^{-1} H^T y
$$
我们已知损失准则为:
$$
J_{PLS}(x) = (y - Hx)^T(y - Hx) + \mu x^T D^T Dx
$$</p>
<p>$$
J_{PLS}(x) = y^T y - 2x^T H^T y + x^T H^T H x + \mu x^T D^T D x
$$</p>
<p>求偏导为0:
$$
\frac{\partial J_{PLS}(x)}{\partial x} = -2H^T y + 2H^T H x + 2\mu D^T D x = 0
$$</p>
<p>$$
(H^T H + \mu D^T D) x = H^T y
$$</p>
<p>$$
\hat{x} = (H^T H + \mu D^T D)^{-1} H^T y
$$</p>
<p>特殊情况：</p>
<p>在特定情况下 $\mu = 0$ 时准则和最小化器的结果表达式变为 $  J_{PLS}(x) = |y - Hx|^2$</p>
<p>最小化器方程为：
$$
H^T H x = H^T y
$$</p>
<p>$$
\hat{x} = (H^T H)^{-1} H^T y
$$</p>
<blockquote>
<p>此时准则变为经典的最小二乘问题，没有正则化项，也就是说，模型仅考虑最小化观测值与预测值之间的误差，而不会惩罚解的复杂度或平滑性。其解是经典的 <strong>最小二乘解</strong>。</p>
</blockquote>
<blockquote>
</blockquote>
<h5 id="121-循环近似">1.2.1 循环近似<a hidden class="anchor" aria-hidden="true" href="#121-循环近似">#</a></h5>
<p>回到公式 (9) ，我们已知矩阵 $H^T H + \mu D^T D$ 的大小为 $N \times N$，当 $N$ 很大时，这种反演在计算上非常昂贵甚至不可行。</p>
<p>比如说在处理图像时，比如对于 $1000 \times 1000$ 的图像，矩阵的大小为 $10^6 \times 10^6$ ，计算不了。在三维情况下，更复杂。</p>
<p>因此为了计算 $\hat{x}$，有几种方法可以克服这种大计算量的困难。</p>
<p>下面我们考虑使用循环矩阵的特性，因为我们可以用对角矩阵来 “替换” 公式 (9) 中的矩阵 (通过快速傅里叶变换 FFT 可以将循环矩阵 “转化”为对角矩阵)。因此，使用对角矩阵进行计算时，乘法或反演等矩阵运算的复杂度将大大降低。</p>
<p>但是，这需要先将矩阵 $H$ 和 $D$ 近似为循环矩阵 $\tilde{H}$ 和 $\tilde{D}$。</p>
<p>循环近似涉及修改矩阵的右上角和/或左下角部分，使其具有循环结构。这种近似的核心假设是信号或图像在开始和结束部分是周期性的，即信号的末尾与开头相连接，形成一个环状结构。</p>
<p>循环卷积矩阵 $\tilde{H}$ 和 $\tilde{D}$ 在傅里叶基下可以轻松对角化：
$$
\tilde{H} = F^T \Lambda_h F \quad \text{和} \quad \tilde{D} = F^T \Lambda_d F
$$
矩阵 $\Lambda_h$ 是对角矩阵，其对角线上元素是 $H$ 的特征值。</p>
<p>特征值可以通过对矩阵 $H$ 第一行进行快速傅里叶变换（FFT）获得，即计算脉冲响应的 N 点 FFT，这些响应代表频率响应的样本。</p>
<p>同样适用于矩阵 $\tilde{D}$ 及其特征值，其中将脉冲响应替换为 $[-1, 1]$。</p>
<p>通过在 (9) 中用 (18) 代替，并使用简单的矩阵操作，可以得到：
$$
\overset{\circ}{\hat{x}} = (\Lambda_{h}^{\dagger} \Lambda_{h} + \mu \Lambda_{d}^{\dagger} \Lambda_{d})^{-1} \Lambda_{h}^{\dagger} \overset{\circ}{y}
$$</p>
<p>证明：</p>
<p>补充知识: $\tilde{H}$ 是一个实矩阵，因此其复共轭等于它本身，$\tilde{H} = \tilde{H}^T$ 。  $\tilde{D}$ 同理</p>
<p>在近似为循环矩阵后，公式 (15) 变为:
$$
\hat{x} = (\tilde{H}^{T}\tilde{H} + \mu \tilde{D}^{T}\tilde{D})^{-1}\tilde{H}^{T}y
$$
其中:  $\tilde{H} = F^T \Lambda_h F$   且  $ \tilde{D} = F^T \Lambda_d F$  将其带入上述公式，得:
$$
\hat{x} = ((F^{T}\Lambda_{h}F)^{T}(F^{T}\Lambda_{h}F) + \mu (F^{T}\Lambda_{d}F)^{T}(F^{T}\Lambda_{d}F))^{-1}(F^{T}\Lambda_{h}F)^{T}y
$$
因为傅里叶矩阵 $F$ 是一个正交矩阵，具有 $F F^{T} = I$ 的性质，即 $F^{T} = F^{-1}$</p>
<p>并且我们有 $(F^{T}\Lambda_{h}F)^{T} = F^{T}\Lambda_{h}^{T}F$   以及   $(F^{T}\Lambda_{d}F)^{T} = F^{T}\Lambda_{d}^{T}F$</p>
<p>所以:
$$
\hat{x} = (F^{T}\Lambda_{h}^{T}\Lambda_{h}F + \mu F^{T}\Lambda_{d}^{T}\Lambda_{d}F)^{-1} F^{T}\Lambda_{h}^{T}F y
$$</p>
<p>$$
\hat{x} = F^{T}(\Lambda_{h}^{T}\Lambda_{h} + \mu \Lambda_{d}^{T}\Lambda_{d})^{-1} \Lambda_{h}^{T}F y
$$</p>
<p>$$
令\quad  \overset{\circ}{\hat{x}} = F \hat{x}, \quad \overset{\circ}{y} = F y
$$</p>
<p>那么:
$$
\overset{\circ}{\hat{x}} = (\Lambda_{h}^{\dagger} \Lambda_{h} + \mu \Lambda_{d}^{\dagger} \Lambda_{d})^{-1} \Lambda_{h}^{\dagger} \overset{\circ}{y}
$$
特殊情况：</p>
<p>当 $\mu = 0$ 时，正则化项消失，公式简化为：
$$
\overset{\circ}{\hat{x}} = (\Lambda_{h}^{\dagger} \Lambda_{h})^{-1} \Lambda_{h}^{\dagger} \overset{\circ}{y}
$$
这意味着我们仅仅执行了经典的 Wiener 去卷积，没有考虑图像的正则化。
$$
\hat{x} = (\tilde{H}^{T}\tilde{H} )^{-1}\tilde{H}^{T}y\
$$</p>
<p>没有正则化时，虽然理论上可以恢复原始信号，但是实际上收到的噪声影响很大，且没有约束来将其消除</p>
<p>为了完成我们的讨论，我们首先构建向量 $g_{\text{PLS}}$，其分量定义如下：
$$
g_{PLS}^{n} = \frac{\overset{\circ}{h}<em>{n}^{*}}{|\overset{\circ}{h}</em>{n}|^2 + \mu |\overset{\circ}{d}_{n}|^2} \quad \text{for } n = 1, 2, \dots, N
$$</p>
<p>因此，向量 $\overset{\circ}{\hat{x}}$ 是通过向量  $g_{\text{PLS}}$ 和 $\overset{\circ}{\hat{y}}$ 之间逐元素相乘得到的：
$$
\overset{\circ}{\hat{x}} = g_{\text{PLS}} .* \overset{\circ}{\hat{y}}
$$
反卷积问题可以表述为在傅里叶域中进行的滤波操作，其中 $g_{\text{PLS}}$ 代表离散传递函数。</p>
<p>反卷积问题总结如下：</p>
<p>① 构建 $\mathring{h}$ 作为脉冲响应的 $N$ 点 FFT</p>
<p>② 构建 $\mathring{d}$ 作为 $[1; -1]$ 的 $N$ 点 FFT</p>
<p>③ 构建包含传递函数 $g_{\text{PLS}}$ 的向量</p>
<p>④ 构建观测值的 FFT $\mathring{y}$</p>
<p>⑤ 计算 $\mathring{\hat{x}}$，作为传递函数 $g_{\text{PLS}}$ 和 $\mathring{\hat{y}}$ 的乘积</p>
<p>⑥ 计算 $\mathring{\hat{x}}$ 的 IFFT 以在空间域中获得解 $\hat{x}$</p>
<h3 id="2-实现">2 实现<a hidden class="anchor" aria-hidden="true" href="#2-实现">#</a></h3>
<h4 id="21-二维方法">2.1 二维方法<a hidden class="anchor" aria-hidden="true" href="#21-二维方法">#</a></h4>
<p>对于二维情况，可以给出类似于一维情况的方程。然而，所涉及的矩阵结构更加复杂:  block-Tœplitz 矩阵，每个块本身也具有 Tœplitz 结构。这使得在两个方向上进行循环近似变得更加困难。因此，二维情况仅作为一维情况的扩展来展示，重点是 Matlab 实现。</p>
<p>注意以下几点：</p>
<ul>
<li>图像、脉冲响应、正则化项都是二维的，这意味着必须使用 FFT-2D 而不是 FFT。</li>
<li>更确切地说，如果要恢复的图像有 N 行和 N 列，那么 FFT-2D 必须在 N 行和 N 列上计算。</li>
<li>频率传递函数也是二维的，每个空间频率有一个维度。</li>
</ul>
<p>特别说明 — 在任何情况下，矩阵 H 和 D 都不应在 Matlab 代码中构建。</p>
<h4 id="22-观测图像"><strong>2.2 观测图像</strong><a hidden class="anchor" aria-hidden="true" href="#22-观测图像">#</a></h4>
<ul>
<li>
<p>第一步是加载文件 <strong>Data1</strong> 和 <strong>Data2</strong> 中提供的数据。这可以通过使用 <strong>load</strong> 函数完成。每个文件包含：模糊图像 (<strong>Data</strong>)、用于比较的真实图像 (<strong>TrueIma</strong>)，以及卷积滤波器的脉冲响应 (<strong>IR</strong>)。现在分析每个数据集及其相互关系。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">close</span> <span class="n">all</span><span class="p">,</span> <span class="n">clear</span> <span class="n">all</span>
</span></span><span class="line"><span class="cl"><span class="n">clc</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">%% 第1部分：加载图像数据</span>
</span></span><span class="line"><span class="cl"><span class="c">% 加载第一组数据，包括模糊图像和真实图像</span>
</span></span><span class="line"><span class="cl"><span class="n">DataOne</span> <span class="p">=</span> <span class="n">load</span><span class="p">(</span><span class="s">&#39;DataOne.mat&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">image_One</span> <span class="p">=</span> <span class="n">DataOne</span><span class="p">.</span><span class="n">Data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">True_image_One</span> <span class="p">=</span> <span class="n">DataOne</span><span class="p">.</span><span class="n">TrueImage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 加载第二组数据，包括模糊图像和真实图像</span>
</span></span><span class="line"><span class="cl"><span class="n">DataTwo</span> <span class="p">=</span> <span class="n">load</span><span class="p">(</span><span class="s">&#39;DataTwo.mat&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">image_Two</span> <span class="p">=</span> <span class="n">DataTwo</span><span class="p">.</span><span class="n">Data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">True_image_Two</span> <span class="p">=</span> <span class="n">DataTwo</span><span class="p">.</span><span class="n">TrueImage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">%% 第2部分：显示两幅图像</span>
</span></span><span class="line"><span class="cl"><span class="c">% 创建一个图形窗口以显示两幅图像</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">clf</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 显示第一幅图像</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">image_One</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">colorbar</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="n">square</span> <span class="n">off</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Image One&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 显示第二幅图像</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">image_Two</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">colorbar</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="n">square</span> <span class="n">off</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Image Two&#39;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>对每个观察到的图像的模糊程度进行评论。 在频域中分析图像（同时使用线性和对数刻度）并提供适当的评论。花时间识别两个频率轴，必须正确标注零频率、低频、高频等。在你的报告中适当地展示这些结果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 第3部分：图像的频域分析</span>
</span></span><span class="line"><span class="cl"><span class="c">% 计算第一幅图像的二维傅里叶变换，并将零频移到中心</span>
</span></span><span class="line"><span class="cl"><span class="n">fft_image_One</span> <span class="p">=</span> <span class="n">MyFFT2</span><span class="p">(</span><span class="n">image_One</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">fft_image_One_shifted</span> <span class="p">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">fft_image_One</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% 计算第一幅图像频谱的幅值</span>
</span></span><span class="line"><span class="cl"><span class="n">magnitude_spectrum_One</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fft_image_One_shifted</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 计算第二幅图像的二维傅里叶变换，并将零频移到中心</span>
</span></span><span class="line"><span class="cl"><span class="n">fft_image_Two</span> <span class="p">=</span> <span class="n">MyFFT2</span><span class="p">(</span><span class="n">image_Two</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">fft_image_Two_shifted</span> <span class="p">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">fft_image_Two</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% 计算第二幅图像频谱的幅值</span>
</span></span><span class="line"><span class="cl"><span class="n">magnitude_spectrum_Two</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fft_image_Two_shifted</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 生成频率轴，用于第一幅图像</span>
</span></span><span class="line"><span class="cl"><span class="n">rows_One</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">image_One</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c">% 获取行数</span>
</span></span><span class="line"><span class="cl"><span class="n">cols_One</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">image_One</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c">% 获取列数</span>
</span></span><span class="line"><span class="cl"><span class="n">freq_axis_One</span> <span class="p">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">cols_One</span> <span class="p">:</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">cols_One</span><span class="p">;</span> <span class="c">% 创建频率轴</span>
</span></span><span class="line"><span class="cl"><span class="n">freq_axis_One</span> <span class="p">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">freq_axis_One</span><span class="p">);</span> <span class="c">% 将频率轴中心化</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 生成频率轴，用于第二幅图像</span>
</span></span><span class="line"><span class="cl"><span class="n">rows_Two</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">image_Two</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">cols_Two</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">image_Two</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">freq_axis_Two</span> <span class="p">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">cols_Two</span> <span class="p">:</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">cols_Two</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">freq_axis_Two</span> <span class="p">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">freq_axis_Two</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">%% 第4部分：显示频谱分析结果</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 在线性尺度下显示第一幅图像的频谱</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">clf</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">freq_axis_One</span><span class="p">,</span> <span class="n">freq_axis_One</span><span class="p">,</span> <span class="n">magnitude_spectrum_One</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;jet&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="n">square</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Image One - Échelle Linéaire&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Fréquence horizontale (axe de fréquence)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Fréquence verticale (axe de fréquence)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 在线性尺度下显示第二幅图像的频谱</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">freq_axis_Two</span><span class="p">,</span> <span class="n">freq_axis_Two</span><span class="p">,</span> <span class="n">magnitude_spectrum_Two</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;jet&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="n">square</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Image Two - Échelle Linéaire&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Fréquence horizontale (axe de fréquence)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Fréquence verticale (axe de fréquence)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 在对数尺度下显示第一幅图像的频谱</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">freq_axis_One</span><span class="p">,</span> <span class="n">freq_axis_One</span><span class="p">,</span> <span class="nb">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">magnitude_spectrum_One</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;jet&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="n">square</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Image One - Échelle Logarithmique&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Fréquence horizontale (axe de fréquence)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Fréquence verticale (axe de fréquence)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 在对数尺度下显示第二幅图像的频谱</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">freq_axis_Two</span><span class="p">,</span> <span class="n">freq_axis_Two</span><span class="p">,</span> <span class="nb">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">magnitude_spectrum_Two</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;jet&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="n">square</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Image Two - Échelle Logarithmique&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Fréquence horizontale (axe de fréquence)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Fréquence verticale (axe de fréquence)&#39;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>​	<strong>零频率</strong> 位于图像的中心，对应图像中的平均亮度。零频率处的值越高，意味着图像的整体亮度较高。</p>
</li>
<li>
<p>​	<strong>低频成分</strong> 主要反映图像中的大尺度结构或平滑区域。低频越强，图像的模糊程度越高。</p>
</li>
<li>
<p>​	<strong>高频成分</strong> 对应图像的细节和边缘。模糊的图像高频成分较少，这表明细节被模糊化了。</p>
</li>
</ul>
</li>
<li>
<p>显示两个脉冲响应 $h_{n,m}$ 及其关联的传递函数 $H(\nu_x, \nu_y)$ 。</p>
<p>首先使用 imagesc 函数，然后使用 plot 函数。正确地在每个轴上标记它们。在你的报告中适当地展示这些结果。什么类型的滤波器是它们？高通还是低通？两个滤波器之间的差异是什么？</p>
<p>我们假设有两个不同的脉冲响应  h_1  和  h_2 ，可以分别计算它们的传递函数，并比较它们的频率响应</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 第5部分：显示脉冲响应和传递函数</span>
</span></span><span class="line"><span class="cl"><span class="c">% 加载第一组数据的脉冲响应</span>
</span></span><span class="line"><span class="cl"><span class="n">h1</span> <span class="p">=</span> <span class="n">DataOne</span><span class="p">.</span><span class="n">IR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c">% 加载第二组数据的脉冲响应</span>
</span></span><span class="line"><span class="cl"><span class="n">h2</span> <span class="p">=</span> <span class="n">DataTwo</span><span class="p">.</span><span class="n">IR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 计算第一幅图像的脉冲响应的傅里叶变换</span>
</span></span><span class="line"><span class="cl"><span class="n">H1</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span><span class="nb">length</span><span class="p">(</span><span class="n">image_One</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl"><span class="c">% 计算第二幅图像的脉冲响应的傅里叶变换</span>
</span></span><span class="line"><span class="cl"><span class="n">H2</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">h2</span><span class="p">,</span><span class="nb">length</span><span class="p">(</span><span class="n">image_Two</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 计算第一幅图像的传递函数</span>
</span></span><span class="line"><span class="cl"><span class="n">transfer_function_h1</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="nb">size</span><span class="p">(</span><span class="n">image_One</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c">% 计算第二幅图像的传递函数</span>
</span></span><span class="line"><span class="cl"><span class="n">transfer_function_h2</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">h2</span><span class="p">,</span> <span class="nb">size</span><span class="p">(</span><span class="n">image_Two</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 显示第一幅图像的脉冲响应和传递函数</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">clf</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">H1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="n">square</span> <span class="n">off</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Réponse Impulsionnelle H1[n,m]&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="nb">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">transfer_function_h1</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="n">square</span> <span class="n">off</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Fonction de Transfert H1(νx, νy)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;jet&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 显示第二幅图像的脉冲响应和传递函数</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">H2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="n">square</span> <span class="n">off</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Réponse Impulsionnelle H2[n,m]&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="nb">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">transfer_function_h2</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="n">square</span> <span class="n">off</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Fonction de Transfert H2(νx, νy)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;jet&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">%% 第6部分：使用 plot 显示传递函数沿某一线的切片</span>
</span></span><span class="line"><span class="cl"><span class="c">% 显示第一幅图像的传递函数沿 νx 方向的切片</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">clf</span>
</span></span><span class="line"><span class="cl"><span class="n">line_profile_One</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">H1</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">H1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">:))));</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">line_profile_One</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Transfer Function H1(νx) along a Line&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Frequency (νx)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Magnitude&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 显示第二幅图像的传递函数沿 νx 方向的切片</span>
</span></span><span class="line"><span class="cl"><span class="n">line_profile_Two</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">H2</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">H2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">:))));</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">line_profile_Two</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Transfer Function H2(νx) along a Line&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Frequency (νx)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Magnitude&#39;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="23-implementation">2.3 Implementation<a hidden class="anchor" aria-hidden="true" href="#23-implementation">#</a></h4>
<p>Matlab 代码将在二维情况下实现反卷积，使用带有二次惩罚项的最小二乘法。该准则将使用第一节中提出的循环近似进行最小化，并在第4页进行了总结。</p>
<p>关于正则化项，它依赖于图像列和行上相邻像素之间的差异。它的表达式为：</p>
<p>$$
| D x |^2 = \sum_{n,m} (x_{n,m} - x_{n,m+1})^2 + (x_{n,m} - x_{n+1,m})^2
$$</p>
<p>并且它将基于两个滤波器来实现：</p>
<p>$$
\begin{bmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 1 \\
0 &amp; 0 &amp; 0
\end{bmatrix}
\quad \text{and} \quad
\begin{bmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
0 &amp; 1 &amp; 0
\end{bmatrix}
$$</p>
<p>这些滤波器计算列和行上像素之间的差异。也可以使用带有以下脉冲响应的唯一滤波器：</p>
<p>$$
\begin{bmatrix}
0 &amp; -1 &amp; 0 \\
-1 &amp; 4 &amp; -1 \\
0 &amp; -1 &amp; 0
\end{bmatrix}
\quad or \quad
\begin{bmatrix}
-1 &amp; -1 &amp; -1 \\
-1 &amp; 8 &amp; -1 \\
-1 &amp; -1 &amp; -1
\end{bmatrix}
\quad or \quad
\begin{bmatrix}
1 &amp; -2 &amp; 1 \\
-2 &amp; 4 &amp; -2 \\
1 &amp; -2 &amp; 1
\end{bmatrix}
$$
它们实现了各种图像梯度的近似。</p>
<ul>
<li>
<p>在一个函数中实现反卷积，该函数以观测到的图像、脉冲响应和正则化参数作为输入。</p>
<p>正则化项 $| D x |^2$ 代表了水平方向和垂直方向相邻像素值的平方差之和。
$$
D_{horiz} = \begin{bmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 1 \\
0 &amp; 0 &amp; 0
\end{bmatrix} \quad \quad \quad
D_{vert} = \begin{bmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
0 &amp; 1 &amp; 0
\end{bmatrix}
$$
前面我们得到：
$$
\hat{x} = (H^{T}H + \mu D^{T}D)^{-1}H^{T}y
$$
现在进行傅里叶变换下的去卷积（在频域处理）
$$
\hat{x}(\nu_{x}, \nu_{y}) = \frac{\hat{H}^{*}(\nu_{x}, \nu_{y}) \hat{y}(\nu_{x}, \nu_{y})}{|\hat{H}(\nu_{x}, \nu_{y})|^2 + \mu |\hat{D}(\nu_{x}, \nu_{y})|^2}
$$</p>
<ul>
<li>$\hat{H}(\nu_{x}, \nu_{y})$ 是卷积矩阵的傅里叶变换</li>
<li>$\hat{D}(\nu_{x}, \nu_{y})$ 是差分矩阵的傅里叶变换</li>
<li>$\hat{x}(\nu_{x}, \nu_{y})$ 是频域中的恢复图像</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">function</span><span class="w"> </span>x_est <span class="p">=</span><span class="w"> </span><span class="nf">deconvolve_2D</span><span class="p">(</span>y, h, mu<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="c">% y: 输入模糊图像</span>
</span></span><span class="line"><span class="cl"> <span class="c">% h: 脉冲响应（卷积核）</span>
</span></span><span class="line"><span class="cl"> <span class="c">% mu: 正则化参数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 计算卷积核的傅里叶变换</span>
</span></span><span class="line"><span class="cl"> <span class="n">H</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">length</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 构造正则化滤波器</span>
</span></span><span class="line"><span class="cl"> <span class="c">% 构造D矩阵，使用卷积实现邻近像素差分</span>
</span></span><span class="line"><span class="cl"> <span class="n">D_horiz</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">];</span>  <span class="c">% 水平方向滤波器</span>
</span></span><span class="line"><span class="cl"> <span class="n">D_vert</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">];</span>   <span class="c">% 垂直方向滤波器</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 计算D矩阵的傅里叶变换</span>
</span></span><span class="line"><span class="cl"> <span class="n">D_horiz_fft</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">D_horiz</span><span class="p">,</span> <span class="nb">length</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>  
</span></span><span class="line"><span class="cl"> <span class="c">%这里length(y)正确与否不确定</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">D_vert_fft</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">D_vert</span><span class="p">,</span> <span class="nb">length</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 计算观测图像的傅里叶变换</span>
</span></span><span class="line"><span class="cl"> <span class="n">Y</span> <span class="p">=</span> <span class="n">MyFFT2</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 构建正则化项的频率表达式</span>
</span></span><span class="line"><span class="cl"> <span class="n">Reg_term</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">D_horiz_fft</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">D_vert_fft</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 构建Wiener滤波器，带正则化项</span>
</span></span><span class="line"><span class="cl"> <span class="n">H_conj</span> <span class="p">=</span> <span class="nb">conj</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">X</span> <span class="p">=</span> <span class="p">(</span><span class="n">H_conj</span> <span class="o">.*</span> <span class="n">Y</span><span class="p">)</span> <span class="o">./</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">H</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">Reg_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 反傅里叶变换返回空间域</span>
</span></span><span class="line"><span class="cl"> <span class="n">x_est</span> <span class="p">=</span> <span class="nb">real</span><span class="p">(</span><span class="n">MyIFFT2</span><span class="p">(</span><span class="n">F</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>首先考虑简单的逆滤波器情况，即 $µ = 0$ 。分析并评论对每个数据集得到的结果。</p>
<p>前面我们得到：							$\hat{x} = (H^{T}H + \mu D^{T}D)^{-1}H^{T}y$</p>
<p>现在变成：									$\hat{x} = (H^{T}H)^{-1}H^{T}y$
$$
\hat{x}(\nu_{x}, \nu_{y}) = \frac{\hat{H}^{*}(\nu_{x}, \nu_{y}) \hat{y}(\nu_{x}, \nu_{y})}{|\hat{H}(\nu_{x}, \nu_{y})|^2 }
$$</p>
<ul>
<li>
<p>$\hat{H}(\nu_{x}, \nu_{y})$ 是卷积矩阵的傅里叶变换</p>
</li>
<li>
<p>$\hat{D}(\nu_{x}, \nu_{y})$ 是差分矩阵的傅里叶变换</p>
</li>
<li>
<p>$\hat{x}(\nu_{x}, \nu_{y})$ 是频域中的恢复图像</p>
</li>
</ul>
<p>当 µ = 0 时，去卷积过程依赖于直接反演卷积核的傅里叶系数。然而，这对噪声非常敏感，特别是当卷积核的某些频率接近零时，直接反演会导致噪声被放大。</p>
</li>
<li>
<p>分析对不同 µ 值（在  log_10  刻度上取值）的结果。评论在空间域和频域中获得的结果。不同的 µ 值如何影响每个数据集的反卷积图像？通过试验和误差及视觉检查结果，确定合适的 µ值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">mu_values</span> <span class="p">=</span> <span class="nb">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>  <span class="c">% 生成从 10^-10 到 10^10 的 \mu 值</span>
</span></span><span class="line"><span class="cl"><span class="n">errors</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">mu_values</span><span class="p">));</span>     <span class="c">% 用于存储每个 \mu 对应的误差</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nb">i</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">mu_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">mu</span> <span class="p">=</span> <span class="n">mu_values</span><span class="p">(</span><span class="nb">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">x_est</span> <span class="p">=</span> <span class="n">deconvolve_2D</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">mu</span><span class="p">);</span>  <span class="c">% 进行去卷积</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 计算去卷积结果与真实图像的误差</span>
</span></span><span class="line"><span class="cl"><span class="n">errors</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">x_est</span> <span class="o">-</span> <span class="n">true_image</span><span class="p">,</span> <span class="s">&#39;fro&#39;</span><span class="p">);</span>  <span class="c">% 使用 Frobenius 范数计算误差</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 绘制 \mu 与误差之间的关系</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">loglog</span><span class="p">(</span><span class="n">mu_values</span><span class="p">,</span> <span class="n">errors</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;\mu (log scale)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Error&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Regularization Parameter \mu vs. Reconstruction Error&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>2.4 超参数的作用</p>
<p>上一点使我们能够评估与反卷积问题相关的内在难度。它还表明，考虑可用的关于重建图像期望正则性的先验信息可以获得更好的结果。这种方法因此使我们能够在两种信息源之间进行折衷：观测数据和可用的 a priori 信息（关于正则性）。这是通过参数 µ 的值来实现的。在本研究中，µ 的值是通过经验选择的，以使反卷积图像既不过于平滑也不过于不规则。</p>
<p>在这里研究的“玩具示例”中，真实图像已知，即从中生成观测数据的图像已知。</p>
<p>因此，可以计算反卷积图像 $\hat{x}$ 和真实图像 $x^*$ 之间的数值差异，作为正则化参数 $\mu$ 的函数。</p>
<p>为此，考虑以下三种距离函数：
$$
\begin{aligned}
\Delta_2(\mu) &amp;= \frac{\sum_{p,q} \left( \hat{x}<em>{p,q}(\mu) - x^{\star}</em>{p,q} \right)^2}{\sum_{p,q} \left( x^{\star}<em>{p,q} \right)^2} = \frac{|\hat{x}(\mu) - x^{\star}|<em>2^2}{|x^{\star}|<em>2^2} \
\Delta_1(\mu) &amp;= \frac{\sum</em>{p,q} \left| \hat{x}</em>{p,q}(\mu) - x^{\star}</em>{p,q} \right|}{\sum_{p,q} \left| x^{\star}<em>{p,q} \right|} = \frac{|\hat{x}(\mu) - x^{\star}|<em>1}{|x^{\star}|<em>1} \
\Delta</em>{\infty}(\mu) &amp;= \frac{\max</em>{p,q} \left| \hat{x}</em>{p,q}(\mu) - x^{\star}<em>{p,q} \right|}{\max</em>{p,q} \left| x^{\star}<em>{p,q} \right|} = \frac{|\hat{x}(\mu) - x^{\star}|</em>{\infty}}{|x^{\star}|_{\infty}}
\end{aligned}
$$</p>
<p>当恢复的图像类似于真实图像时，这些距离接近于0，当恢复的图像为零时，它们接近1。</p>
<ul>
<li>
<p>计算一组 $\mu$ 值的距离，例如在 $10^{-10}$ 和 $10^{10}$ 之间的对数间隔值。给出最小化每个距离函数的 $\mu$ 值，并将结果与先前选择的经验值进行比较（应主要关注第二个数据集 Data2）。</p>
<blockquote>
<p>[!IMPORTANT]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">function</span><span class="w"> </span>[best_mu, delta2_values, delta1_values, delta_inf_values] <span class="p">=</span><span class="w"> </span><span class="nf">find_best_mu</span><span class="p">(</span>y, h, true_image<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="c">% y: 输入模糊图像</span>
</span></span><span class="line"><span class="cl"> <span class="c">% h: 脉冲响应（卷积核）</span>
</span></span><span class="line"><span class="cl"> <span class="c">% true_image: 已知的真实图像</span>
</span></span><span class="line"><span class="cl"> <span class="c">% 返回最优的 mu 值，以及每个 mu 对应的距离度量结果</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 计算真实图像的不同范数</span>
</span></span><span class="line"><span class="cl"> <span class="n">true_image_norm2</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">true_image</span><span class="p">(:),</span> <span class="mi">2</span><span class="p">)</span>^<span class="mi">2</span><span class="p">;</span>  <span class="c">% 二范数的平方</span>
</span></span><span class="line"><span class="cl"> <span class="n">true_image_norm1</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">true_image</span><span class="p">(:),</span> <span class="mi">1</span><span class="p">);</span>    <span class="c">% 一范数</span>
</span></span><span class="line"><span class="cl"> <span class="n">true_image_norm_inf</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">true_image</span><span class="p">(:),</span> <span class="n">Inf</span><span class="p">);</span> <span class="c">% 无穷范数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">H</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">length</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>         <span class="c">% 计算卷积核的傅里叶变换     </span>
</span></span><span class="line"><span class="cl">   <span class="c">% H = fft2(h, size(y, 1), size(y, 2)); %如果上面报错 用下面的尺度</span>
</span></span><span class="line"><span class="cl"> <span class="n">Y</span> <span class="p">=</span> <span class="n">MyFFT2</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>        <span class="c">% 计算观测图像的傅里叶变换</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 构造正则化滤波器</span>
</span></span><span class="line"><span class="cl"> <span class="c">% 构造D矩阵，使用卷积实现邻近像素差分</span>
</span></span><span class="line"><span class="cl"> <span class="n">D_horiz</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">];</span>  <span class="c">% 水平方向滤波器</span>
</span></span><span class="line"><span class="cl"> <span class="n">D_vert</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">];</span>   <span class="c">% 垂直方向滤波器</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 计算D矩阵的傅里叶变换</span>
</span></span><span class="line"><span class="cl"> <span class="n">D_horiz_fft</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">D_horiz</span><span class="p">,</span> <span class="nb">length</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>  <span class="c">%这里length(y)正确与否不确定</span>
</span></span><span class="line"><span class="cl"> <span class="n">D_vert_fft</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">D_vert</span><span class="p">,</span> <span class="nb">length</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 构建正则化项的频率表达式</span>
</span></span><span class="line"><span class="cl"> <span class="n">Reg_term</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">D_horiz_fft</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">D_vert_fft</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 正则化参数的范围，取对数间隔</span>
</span></span><span class="line"><span class="cl"> <span class="n">mu_values</span> <span class="p">=</span> <span class="nb">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 存储每个 mu 对应的距离度量值</span>
</span></span><span class="line"><span class="cl"> <span class="n">delta2_values</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">mu_values</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">delta1_values</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">mu_values</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">delta_inf_values</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">mu_values</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 逐个计算不同 mu 下的去卷积结果</span>
</span></span><span class="line"><span class="cl"> <span class="k">for</span> <span class="nb">i</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">mu_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">mu</span> <span class="p">=</span> <span class="n">mu_values</span><span class="p">(</span><span class="nb">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="c">% 构建 Wiener 滤波器</span>
</span></span><span class="line"><span class="cl">     <span class="n">H_conj</span> <span class="p">=</span> <span class="nb">conj</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>  <span class="c">% 卷积核的复共轭</span>
</span></span><span class="line"><span class="cl">     <span class="n">F</span> <span class="p">=</span> <span class="n">H_conj</span> <span class="o">./</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">H</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">Reg_term</span><span class="p">);</span>  <span class="c">% 滤波器</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="c">% 使用 Wiener 滤波器对傅里叶域中的观测图像进行滤波</span>
</span></span><span class="line"><span class="cl">     <span class="n">X_est</span> <span class="p">=</span> <span class="n">F</span> <span class="o">.*</span> <span class="n">Y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 反傅里叶变换返回空间域</span>
</span></span><span class="line"><span class="cl"> <span class="n">x_est</span> <span class="p">=</span> <span class="nb">real</span><span class="p">(</span><span class="n">MyIFFT2</span><span class="p">(</span><span class="n">F</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="c">% 计算三种距离度量</span>
</span></span><span class="line"><span class="cl">     <span class="n">delta2_values</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">x_est</span><span class="p">(:)</span> <span class="o">-</span> <span class="n">true_image</span><span class="p">(:),</span> <span class="mi">2</span><span class="p">)</span>^<span class="mi">2</span> <span class="o">/</span> <span class="n">true_image_norm2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="n">delta1_values</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">x_est</span><span class="p">(:)</span> <span class="o">-</span> <span class="n">true_image</span><span class="p">(:),</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">true_image_norm1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="n">delta_inf_values</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="p">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">x_est</span><span class="p">(:)</span> <span class="o">-</span> <span class="n">true_image</span><span class="p">(:),</span> <span class="n">Inf</span><span class="p">)</span> <span class="o">/</span> <span class="n">true_image_norm_inf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">%% 找到使二范数误差最小的 mu</span>
</span></span><span class="line"><span class="cl"> <span class="p">[</span><span class="o">~</span><span class="p">,</span> <span class="n">min_idx</span><span class="p">]</span> <span class="p">=</span> <span class="n">min</span><span class="p">(</span><span class="n">delta2_values</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">best_mu</span> <span class="p">=</span> <span class="n">mu_values</span><span class="p">(</span><span class="n">min_idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c">% 可视化距离度量随 mu 的变化</span>
</span></span><span class="line"><span class="cl"> <span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">loglog</span><span class="p">(</span><span class="n">mu_values</span><span class="p">,</span> <span class="n">delta2_values</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span> <span class="s">&#39;LineWidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">hold</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">loglog</span><span class="p">(</span><span class="n">mu_values</span><span class="p">,</span> <span class="n">delta1_values</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span> <span class="s">&#39;LineWidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">loglog</span><span class="p">(</span><span class="n">mu_values</span><span class="p">,</span> <span class="n">delta_inf_values</span><span class="p">,</span> <span class="s">&#39;g-&#39;</span><span class="p">,</span> <span class="s">&#39;LineWidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;\mu&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Distance Metrics&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">legend</span><span class="p">(</span><span class="s">&#39;\Delta_2(\mu)&#39;</span><span class="p">,</span> <span class="s">&#39;\Delta_1(\mu)&#39;</span><span class="p">,</span> <span class="s">&#39;\Delta_\infty(\mu)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">title</span><span class="p">(</span><span class="s">&#39;Distance Metrics vs. \mu&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
