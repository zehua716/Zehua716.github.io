<!DOCTYPE html>
<html lang="zh" dir="ltr">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>飞机俯仰控制系统 | 主页</title>
<meta name="keywords" content="控制, 复杂系统">
<meta name="description" content="飞机俯仰控制系统的稳定性分析设计并利用多种控制方法增强其鲁棒性">
<meta name="author" content="Zehua">
<link rel="canonical" href="http://zehua.eu/zh/posts/probability_cn/%E9%A3%9E%E6%9C%BA%E4%BF%AF%E4%BB%B0%E7%B3%BB%E7%BB%9F/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.555e8889a324a4e96ce6751e5a6db535bb380495bd716aff56431212ff61ae56.css" integrity="sha256-VV6IiaMkpOls5nUeWm21Nbs4BJW9cWr/VkMSEv9hrlY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://zehua.eu/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://zehua.eu/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://zehua.eu/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://zehua.eu/apple-touch-icon.png">
<link rel="mask-icon" href="http://zehua.eu/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://zehua.eu/zh/posts/probability_cn/%E9%A3%9E%E6%9C%BA%E4%BF%AF%E4%BB%B0%E7%B3%BB%E7%BB%9F/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
    integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
    integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
    integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    }); 
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

<meta property="og:title" content="飞机俯仰控制系统" />
<meta property="og:description" content="飞机俯仰控制系统的稳定性分析设计并利用多种控制方法增强其鲁棒性" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://zehua.eu/zh/posts/probability_cn/%E9%A3%9E%E6%9C%BA%E4%BF%AF%E4%BB%B0%E7%B3%BB%E7%BB%9F/" />
<meta property="og:image" content="http://zehua.eu/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-25T16:25:17+01:00" />
<meta property="article:modified_time" content="2024-11-23T17:12:35+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://zehua.eu/images/papermod-cover.png" />
<meta name="twitter:title" content="飞机俯仰控制系统"/>
<meta name="twitter:description" content="飞机俯仰控制系统的稳定性分析设计并利用多种控制方法增强其鲁棒性"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://zehua.eu/zh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "概率统计",
      "item": "http://zehua.eu/zh/posts/probability_cn/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "飞机俯仰控制系统",
      "item": "http://zehua.eu/zh/posts/probability_cn/%E9%A3%9E%E6%9C%BA%E4%BF%AF%E4%BB%B0%E7%B3%BB%E7%BB%9F/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "飞机俯仰控制系统",
  "name": "飞机俯仰控制系统",
  "description": "飞机俯仰控制系统的稳定性分析设计并利用多种控制方法增强其鲁棒性",
  "keywords": [
    "控制", "复杂系统"
  ],
  "articleBody": "一.研究目的 为提高大仰角飞行状态下的飞机控制系统的稳态精度，为保持或者稳定飞行器的姿态角，需要对角度进行一定的控制，保证其稳定性\n二.物理系统方程式 飞机总的方程式非常复杂，有六个非线性耦合微分方程，因此需对其进行解耦并线性化，分成横向和纵向方程。而此处的俯仰系统只由纵向动力学决定。\n将设计一个自动驾驶仪(就是不同的控制器)来控制飞机俯仰角。飞机坐标轴建立与力如图所示。\n对其中参数进行说明：\n① $X’$ $Z’$ 都是地面坐标系，$X$ $Z$ 是机体坐标系，一个指向机头，一个指向机腹，原点为飞机质心\n② $θ$ 为俯仰角（姿态角） $α$ 为气动角 $δ$ 为升降舵偏转角\n③ $v$ 是速度方向，构成了风轴系\n为了简化问题，我们假设①现在的推力 阻力在x轴上平衡，重力与升力在Y轴上平衡。与此同时，假设②俯仰角θ的变化并不会改变飞机速度的变化。由此可以得到纵向运动方程如下： $$ \\dot{\\alpha} = \\mu \\Omega \\sigma \\left[-(C_L + C_D)\\alpha + \\frac{1}{(\\mu - C_L)}q - (C_W \\sin \\gamma)\\theta + C_L \\right] $$\n$$ \\dot{q} = \\frac{\\mu \\sigma \\Omega}{2 i_{yy}} \\left[[C_M - \\eta(C_L + C_D)]\\alpha + [C_M + \\sigma C_M (1 - \\mu C_L)]q + (\\eta C_W \\sin \\gamma) \\delta \\right] $$\n$$ \\dot{\\theta} = \\Omega q $$\n可见，输入是 $δ$，输出是 $θ$\n三.寻找传递函数并建立状态空间表达式 1.传递函数的求得 将上述纵向运动方程简化 $$ \\dot{\\alpha} = -0.313\\alpha + 56.7q + 0.232\\delta $$\n$$ \\dot{q} = -0.0139\\alpha - 0.426q + 0.0203\\delta $$\n$$ \\dot{\\theta} = 56.7q $$\n将其进行拉普拉斯变换，使用单位阶跃输入 $R(s) = 1/s$ 得 $$ sA(s) = -0.313A(s) + 56.7Q(s) + 0.232\\Delta(s) $$\n$$ sQ(s) = -0.0139A(s) - 0.426Q(s) + 0.0203\\Delta(s) $$\n$$ s\\Theta(s) = 56.7Q(s) $$\n阶跃信号用于模拟突然变化的输入，例如飞机需要快速响应新的姿态角设定\n不难得到传递函数 $$ P(s) = \\frac{\\Theta(s)}{\\Delta(s)} = \\frac{1.151s + 0.1774}{s^3 + 0.739s^2 + 0.921s} $$\n2.状态空间方程 状态空间形式便于在多输入多输出（MIMO）系统中统一表示动态方程，因此由上述公式写成矩阵形式有\n$$ \\begin{bmatrix} \\dot{\\alpha} \\\\ \\dot{q} \\\\ \\dot{\\theta} \\end{bmatrix} = \\begin{bmatrix} -0.313 \u0026 56.7 \u0026 0 \\\\ -0.0139 \u0026 -0.426 \u0026 0 \\\\ 0 \u0026 56.7 \u0026 0 \\end{bmatrix} \\begin{bmatrix} \\alpha \\\\ q \\\\ \\theta \\end{bmatrix} + \\begin{bmatrix} 0.232 \\\\ 0.0203 \\\\ 0 \\end{bmatrix} \\begin{bmatrix} \\delta \\end{bmatrix} $$ $$ y = \\begin{bmatrix} 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} \\alpha \\ q \\ \\theta \\end{bmatrix} $$\n四.系统分析 1.设计要求 输入信号为阶跃信号，要求得到的波形性能指标如下：\n俯仰角的超调量小于10% 上升时间小于2s 稳定时间小于10s 稳态误差小于2% 2.开环传函系统分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 %% 定义传递函数和开环系统分析 % 定义传递函数 s = tf('s'); P_pitch = (1.151*s + 0.1774)/(s^3 + 0.739*s^2 + 0.921*s); % 绘制开环系统的阶跃响应 t = 0:0.01:10; % 时间向量 figure; step(P_pitch, t); ylabel('俯仰角 (度)'); xlabel('时间 (秒)'); title('开环系统的阶跃响应'); grid on; % 增加网格便于观察 set(gca, 'FontSize', 12); % 增大字体，便于阅读 % 检查传递函数的极点 disp('开环系统的极点为:'); open_loop_poles = pole(P_pitch); disp(open_loop_poles); 得到三个极点与开传函图像：\n0.0000 + 0.0000i\n-0.3695 + 0.8857i\n-0.3695 - 0.8857i\n要对其进行修正，而极点也表明了，一个极点在虚轴上，其他两个极点在复数域s的左半平面。这个虚轴上的极点表示其相应波形并不会无限上升，但即使如此，由于虚轴极点的特性，给定输入时，依然有可能无限上升。即虚轴极点导致系统对阶跃输入响应呈现无界增长，这是不稳定开环系统的典型特征，在此种特殊情况下，其极点像个积分器，当给定阶跃输入时，对其常数进行积分会导致输出无穷大。\n3.闭环传递函数性能分析 显然开环不能满足，加入反馈模块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 %% 闭环系统分析 % 定义闭环系统（单位反馈） sys_cl = feedback(P_pitch, 1); % 绘制闭环系统的阶跃响应 t = 0:0.01:60; % 使用更长时间范围分析系统收敛特性 figure; step(sys_cl, t); ylabel('俯仰角 (度)'); xlabel('时间 (秒)'); title('闭环系统的阶跃响应'); grid on; set(gca, 'FontSize', 12); % 检查闭环系统的极点 disp('闭环系统的极点为:'); closed_loop_poles = pole(sys_cl); disp(closed_loop_poles); 闭环传递函数 $$ \\text{sys}_{cl} = \\frac{1.151s + 0.1774}{s^3 + 0.739s^2 + 2.072s + 0.1774} $$ 在阶跃响应下的波形图：\n由图可见，闭环系统仍然不满足要求，但稳态误差e近乎为0，且无超调量\n（1）继续对传递函数的极点与零点进行分析\n1 2 3 % 查看闭环系统的极点 disp('闭环传递函数的极点为:'); pole(sys_cl) $$ \\text{极点为} = \\begin{cases} -0.3255 + 1.3816i \\\\ -0.3255 - 1.3816i \\\\ -0.0881 + 0.0000i \\end{cases} $$ $$ 零点为 = -0.1541 $$\n不难看出，其闭环传函系统是稳定的，因为所有极点都具有负实部，尽管都位于左半平面，但复共轭极点的虚部较大，导致系统呈现较明显的振荡特性。此传递函数是三阶系统，由于往常都是使用标准的无阻尼且无零点的二阶系统，因此在本例中不可以依赖零极点关系。不如将输出转换回时域，用系统响应时间函数来了解零极点如何影响系统。\n(2) 闭环传递函数形式为 $Y(s)/R(s)$, 可得 $Y(s) = \\text{传递函数} \\cdot R(s)$\n再将得到的 $Y(s)$ 进行分解因式，部分分数展开用于将高阶系统的传递函数分解为一阶和二阶子系统的叠加，便于理解其动态响应，使用命令 zpk 进行分解。 $$ Y(s) = k \\cdot \\frac{(s-z_1)(s-z_2)\\dots}{(s-p_1)(s-p_2)\\dots} $$\n1 2 3 4 5 6 7 8 %% 分解闭环系统传递函数 % 定义阶跃输入 R(s) = 1/s R = 1/s; % 分解闭环输出 Y(s) Y = zpk(sys_cl * R); disp('闭环系统输出传递函数的零极点增益形式:'); disp(Y); $$ \\begin{aligned} Y(s) \u0026= \\frac{0.2302(s + 0.1541)}{s(s + 0.08805)(s^2 + 0.6509s + 2.105)} \\ \u0026= \\frac{A}{s} + \\frac{B}{s + 0.08805} + \\frac{Cs + D}{s^2 + 0.6509s + 2.105} \\end{aligned} $$\n可以看出，其极点分布为，原点，实极的一阶项，共轭复极的二阶项。再将其因式分解成如下形式\n（3）现在就开始求ABCD，可手动计算，或用命令计算，使用residue命令\n1 2 3 4 5 6 7 8 % 部分分数展开 [r, p, k] = residue([1.151 0.1774], [1 0.739 2.072 0.1774 0]); disp('部分分数展开的残差 （零点分布）:'); disp(r); disp('部分分数展开的极点:'); disp(p); disp('多项式余项:'); disp(k); 零点\n$$ r = \\begin{cases} -0.2802 + 0.0800i \\\\ -0.2802 - 0.0800i \\\\ -0.4395 + 0.0000i \\\\ 1.0000 + 0.0000i \\end{cases} $$ 极点\n$$ r = \\begin{cases} -0.2802 + 0.0800i \\\\ -0.2802 - 0.0800i \\\\ -0.4395 + 0.0000i \\\\ 1.0000 + 0.0000i \\end{cases} $$ $$ k =[\\quad ] $$\n$r$ 包含部分分数展开的残差，即 $A, B$；$p$ 包含系统的极点，极点的阶次对应 $r$ 中残基的阶次；$k$ 由于通常分子多项式比分母多项式小，一般为空，因此 $A = 1, B = -0.0881$\n（4）接下来再求CD，其求法为让复共轭极点项分解成单项表达式来确定\n1 2 3 4 5 6 7 % 提取复共轭极点部分 [num, den] = residue(r(1:2), p(1:2), k); disp('复共轭极点部分的分子与分母:'); disp('分子:'); disp(num); disp('分母:'); disp(den); 可得\n$C = -0.5605$, $D = -0.4036$ $$ \\frac{-0.5605s - 0.4036}{s^2 + 0.6509s + 2.015} $$\n（5）至此，ABCD全得到了，进行逆变换求解\n1 2 3 4 5 6 7 %% 求解闭环系统的时域响应 syms s t F = 1/s - 0.881/(s + 0.08805) - (0.5605*s + 0.4036)/(s^2 + 0.6509*s + 2.015); y_t = ilaplace(F); disp('闭环系统的时域响应表达式:'); disp(vpa(y_t, 4)); % 显示高精度表达式 （6）得到了 $y(t)$ $$ y(t) = 1.0 - 0.5605 e^{-0.3255 t} \\left(\\cos(1.382 t) + 0.2856 \\sin(1.382 t)\\right) - 0.881 e^{-0.08805 t} $$\n每个项应该对应传函极点，而极点的实部又描述了其指数的增长或衰减，虚部对应其振荡频率\n至此可以了解拉普拉斯域中零极点如何影响时域。\n（7）将时域进行画图，和之前应该对应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 %% 绘制闭环系统的时域响应曲线 % 定义时间向量 t3 = 0:0.1:70; % 时域响应的计算 yy = 1 - (1121*exp(-(6509*t3)/20000).*(cos((763632919^(1/2)*t3)/20000) + ... (8847411*763632919^(1/2)*sin((763632919^(1/2)*t3)/20000))/856032502199))/2000 - ... (881*exp(-(1761*t3)/20000))/1000; % 绘制时域响应曲线 figure; plot(t3, yy, 'LineWidth', 1.5); % 增加曲线宽度 xlabel('时间 (秒)'); ylabel('俯仰角 (度)'); title('闭环系统的时域响应曲线'); grid on; set(gca, 'FontSize', 12); % 标注响应特性 text(15, 0.8, '稳态响应近似为1', 'FontSize', 12, 'Color', 'red'); （8）至此表明闭环也不能满足要求，接下来设计一些其他的控制器来完成目标性能\n五.控制方法与结果分析 1.根轨迹法 闭环根轨迹增益=开环前向通路根轨迹增益（单位反馈） 闭环传递函数的零点分别为开传函的零点+反馈回路的极点，若反馈回路为1，则就是开传函的零点。即闭环零点=开环零点 闭环极点与开环零点，开环极点以及根轨迹增益K均有关 对根轨迹做出一些解释说明\n根轨迹设计的主要思想是 有很多可能的闭环极点位置，当处于某个位置的时候，去预测闭环输出响应。因此，通过增加零点或者极点，就可以修改根轨迹，使得极点可以处于新根轨迹上新的位置，从而可以实现所需要的闭环响应。而这个不断选择的位置其实本质就是Kp值的大小。 增加开环极点对根轨迹的影响如下：开环极点会改变根轨迹在实轴上的分布，并改变渐近线的条数+倾角+截距，改变根轨迹分支数，根轨迹会向右偏移。在这种情况下，不利于稳定性与动态性能，并且所增加的开环极点越靠近虚轴，影响就越大 增加开环零点对根轨迹的影响如下：开环零点同样会改变根轨迹在实轴上的分布，并改变渐近线的条数+倾角+截距，如果开环零点与开环极点相距很近，或者近乎重合，那么两者可以相互抵消。因此通常加入零点来抵消不利的开环极点，引入开环零点后根轨迹会向左偏移，会提高稳定性，改善动态性能，，同样，开环零点越靠近虚轴，影响就越大 （1）先找到开环传递函数根轨迹图\n1 2 3 4 5 6 7 %% 根轨迹法 - 开环根轨迹设计 % 定义传递函数 s = tf('s'); P_pitch = (1.151*s + 0.1774)/(s^3 + 0.739*s^2 + 0.921*s); % 打开控制系统设计器进行根轨迹分析 controlSystemDesigner('rlocus', P_pitch); 因此打开了控制系统设计器窗口，其中的控制器 $C(s)=K$\n（2）打开左上角’编辑架构’，可修改回路模型，我们就用最简单的反馈就行\n再回到主页面，在根轨迹编辑器的图中右键，非常隐蔽，不然我赌你肯定找不到， 然后可以调参数（例如调F)(在编辑补偿器里） ，这里我们在设计需求中新建设计参数的范围\n对各项性能指标提出要求，其中上升时间不能直接调节，只能通过调节固有频率的方式间接改变，其关系如下 $$ w_n \\approx \\frac{1.8}{T_r} $$ 根据要求新建并调调其他参数\n（3）参数调节完毕后，得到下图\n极点位置与瞬态性能有关，不如先把满足要求的参数调好，得到满足要求的区域。上面得到的非阴影区域就是闭环极点的最终所需区域。\n换句话讲，以原点为中心的两条射线代表超调要求，射线与负实轴构成的角度越小，则超调量越小。在s=-0.4处有一条垂直线，表示了建立时间的要求，闭环极点越靠近左侧，建立时间就越短。上升时间对应于以原点为中心的圆，其半径就是固有频率的值。\n不难看出，开传函的三个分支都没有进入非阴影区，无法通过改变控制器的比例增益K来讲闭环传函极点放在非阴影区，因此考虑尝试用带极点/零点的动态补偿器\n超前补偿器 (4)要想将根轨迹在复平面上往左移动，采用超前补偿器，传函如下\n$$ C(s) = K \\frac{s + z}{s + p} $$ 其中零点的幅度小于极点的幅度（$z \u003c p$），即零点在复平面中更加靠近虚轴。\n(5)现在开始选择超前补偿器的传递函数\n点击右上角预设项\n(6)随后进入编辑器的参数设置，不如把零点放到 $Z=-0.9$ (就是上升时间对应的固有频率所形成的圆的左半面的实轴上)，可以保证随着后面K的增加，零点根轨迹一定在非阴影范围内，并且将极点放在与零点更远的地方 $p=-3$ （下面图应该极点为-3）。跟着下面这个参数添加一个超前零极点并配置好对应数值就行\n(7)随后可以看到新的根轨迹图像，零极点是可以拖动的\n(8)右键属性中可以调节XY范围，现在放大观看右边的零极点情况\n不难看出，零极点的三条线分支在规定范围内，唯独有一个不在范围内，此极点比其他极点慢，但其响应被隔得非常近的那个零点所抵消。环路增益K越大，闭环极点就越靠近闭环零点，闭环极点所产生的影响就越小。最左边的闭环极点对系统的响应程度最小，因为它比其他极点快得多\n当前极点位置所得到的环路增益K可以在左下方得出。\n(10)现在重新查看闭环阶跃响应曲线图，右键参数设置里可以勾选上升时间、稳定时间等虚线。\n我们的K=200，可见所有极点仍在实轴上，也就是没有超调，最终误差e=0，满足设计条件\n(11)总结:\n至此，采用根轨迹法的控制器设计完毕，从最初的 $C（s）=K$ 不能满足要求，到增加超前环节，到最后调节K值来使闭环极点移动，以使得阶跃响应曲线达到了良好的结果。其实，根轨迹中采用超前补偿器的根本核心就在于在闭环中增加了一项超前补偿器的传函，加入这个环节后可以改变根轨迹，让更稳定的点在根轨迹上。 换句话说，当我们希望闭环的根往左移动（更稳定时），引入超前补偿即可 为什么叫超前补偿器？因为其相角裕度是正的，加入到系统相位上可以使相角增大，就是使系统相位裕度增大，稳定性就大大增强。因为相角超前，叫超前补偿器 2.频域分析法 频率设计的主要思想是利用开环传递函数的Bode图来估计闭环响应，如果向系统添加控制器，会改变开环伯德图，进而改变闭环输出响应，频域分析法直观地展示了系统的增益裕度、相位裕度，以及响应速度与稳定性的关系，为后续设计补偿器提供了依据\n(1)在之前分析闭环传递函数的时候，已经分析得到有三个极点，一个零点，且闭环系统是稳定的。现在其稳定性再由开环频率响应来确定，采用margin命令来生成伯德图，并注释增益裕度与相位裕度\n1 2 3 4 5 6 7 8 9 10 11 12 %% 频域分析法 - Bode图与补偿器设计 % 定义传递函数 s = tf('s'); P_pitch = (1.151*s + 0.1774)/(s^3 + 0.739*s^2 + 0.921*s); % 初始开环系统的Bode图与裕度分析 figure; margin(P_pitch); grid on; title('开环系统的Bode图 (未补偿)'); xlabel('频率 (rad/s)'); ylabel('幅度与相位'); 可见，增益裕度为Inf，相位裕度位46.9，都为正，说明系统稳定（目前的增益裕度是无限的，这表明该系统是稳健的，具有最小的超调，相位裕度为 $46.9^\\circ$ 意味着系统有一定的稳定余量，但不能保证快速响应）。所以满足要求？\n(2)重新回到上面求得的阶跃响应图\n我们通过分析闭环的阶跃响应发现系统是稳定的，只是稳定时间等等均不满足指标，想加快系统响应，就容易导致过冲问题，因此想再次使用补偿器来重塑开环系统的伯德图（开环系统的伯德图表示了闭环系统的行为）（增益交叉频率与闭环响应速度呈正相关，而相位裕度与过冲成反比），采用一个补偿器来加快增益交叉频率且增加相位裕度。因此也采用超前补偿器。其核心目的是优化系统的响应速度和阻尼特性。通过调整零点和极点的位置，它既可以提升增益交叉频率（加快响应速度），又能增加相位裕度（减小过冲）\n超前补偿器 (3)超前补偿器为系统增加了正相位，这样可以增加相位裕度，从而增加阻尼。与此同时，它还可以在高频率下增加开环频率响应的幅度，进而增强增益交叉频率和整体速度（稳定时间降低）。\n其传递函数一般形式如下：\n$$ C(s) = K \\frac{Ts + 1}{\\alpha Ts + 1} \\quad (\\alpha \u003c 1) $$ (4)通常将K设置为满足稳态误差的要求，而由于系统是Ⅰ型的，因此不管任何K值，阶跃输入的稳态误差都是0。增加K（大于1）也可以弥补速度误差常数太小所导致的响应慢尾。换句话说，增大K值会使幅度图往上移动。经选择后，令K=10\n1 2 3 4 5 6 7 8 % 设置增益K并观察频域响应 K = 10; % 增益设置 figure; margin(K * P_pitch); grid on; title('加增益后的Bode图 (K=10)'); xlabel('频率 '); ylabel('幅度与相位'); 可见，我们增加了系统的幅度，并且提高了增益交叉频率，可得出的是随着K的增加，相位裕度也减小了，意味着超调量增加了，这是我们不希望的，但超前补偿器是可以增加系统的阻尼的，也就是说有办法来减小超调量\n(5) 于是继续寻找 $\\alpha$，其定义为零点与极点的比值。零点与极点间隔距离越大，相位的凸点就越大，其中单个零极对可以最大增加相位为 $90^\\circ$。最大相位与 $\\alpha$ 的关系如下：\n$$ \\sin(\\phi_m) = \\frac{1 - \\alpha}{1 + \\alpha} $$ 同时我们也知道标准欠阻尼二阶系统的时间响应与频率响应之间的关系\n$$ \\zeta \\approx \\frac{PM(\\text{degrees})}{100^\\circ} $$ 通常阻尼比 $\\zeta$ 近似小于 $0.6$ 或 $0.7$。\n(6) 尽管之前的系统并不是标准的二阶系统，但仍可以用以上关系进行设计。由于超调量要求小于 $10%$，也就是说，阻尼比 $\\zeta$ 要大于 $0.59$（关系图可以在网上找到），因此相位裕度需要大于 $59^\\circ$。根据超调量与阻尼比的关系，可以先从目标超调量反推出阻尼比，再通过近似公式计算所需的相位裕度\n当前相位裕度为 $10.4^\\circ$，因此再增加 $50^\\circ$ 就足够了。由于超前补偿器会额外增加频率响应的幅度，因此需要添加超过 $50^\\circ$ 的相位超前。最终我们选定 $55^\\circ$ 的相位超前为目标。\n(7)然后计算α\n$$ \\alpha = \\frac{1 - \\sin(55^\\circ)}{1 + \\sin(55^\\circ)} \\approx 0.10 $$ (8)因此α必须小于0.1，再根据下面关系式计算出超前补偿器所造成的幅度增加量\n$$ 20 \\log\\left(\\frac{1}{\\sqrt{\\alpha}}\\right) \\approx 20 \\log\\left(\\frac{1}{\\sqrt{0.10}}\\right) \\approx 10 , \\text{dB} $$ (9) 在之前的图中可以看出，穿过幅值 $= 0$ 那条线的交叉频率 $\\omega_c = 3.49$，穿过幅值 $= -10 , \\text{dB}$ 的频率为 $6.1 , \\text{rad/dec}$。由此不难想到，加入超前补偿器的 $\\alpha$ 后，其交叉频率会变为 $6.1$。然后我们再利用这个新交叉频率值来计算 $T$，目的是使最大相位裕量增加到最大。因为参数 $\\alpha$ 控制了零点和极点之间的距离，从而决定了补偿器的相位峰值大小以及频率范围。\n$$ \\omega_m = \\frac{1}{T \\sqrt{\\alpha}} \\implies T = \\frac{1}{6.1 \\sqrt{0.10}} \\approx 0.52 $$ (10) 由此，超前补偿器的三个变量值全部得到：$K = 10$, $\\alpha = 0.1$, $T = 0.52$。将这些值通过编程应用于开环传递函数，观察超前补偿器对系统频率响应的影响。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 % 定义超前补偿器参数 alpha = 0.1; % 零点与极点的比值 T = 0.52; % 时间常数 % 超前补偿器传递函数 C_lead = K * (T*s + 1) / (alpha*T*s + 1); % 补偿后的开环传递函数 P_lead = C_lead * P_pitch; % 绘制补偿后的Bode图 figure; margin(P_lead); grid on; title('加入超前补偿器后的Bode图'); xlabel('频率 '); ylabel('幅度与相位'); 可见相位裕度和交叉频率都提高了\n(11)接下来再看闭环阶跃响应\n1 2 3 4 5 6 7 8 9 10 11 12 13 % 补偿后的闭环系统 sys_cl_lead = feedback(P_lead, 1); % 绘制闭环阶跃响应 figure; step(sys_cl_lead, 0:0.01:10); grid on; title('超前补偿器设计的闭环阶跃响应'); ylabel('俯仰角 (度)'); xlabel('时间 (秒)'); % 获取闭环系统的性能指标 disp('超前补偿器设计后的闭环系统性能:'); 从图上很难细致的看出超调量等参数，因此采用stepinfo命令\n1 stepinfo(sys_cl_lead); (12) 得到参数后，计算发现超调量还是略大了一些，此时重新调整取 $\\alpha = 0.04$，结果改善了许多：\n上升时间: \\(0.2074\\)\n过渡时间: \\(8.9835\\)\nSettlingTime: \\(8.9835\\)\nSettlingMin: \\(0.9004\\)\nSettlingMax: \\(1.1198\\)\nOvershoot: \\(11.9792\\%\\)\nUndershoot: \\(0\\)\n峰值: \\(1.1198\\)\n峰值时间: \\(0.4886\\) (13) 综上，超前补偿器设置完毕（$\\alpha = 0.04$）\n超前补偿器的传递函数为： $$ C(s) = 10 \\frac{0.55s + 1}{0.022s + 1} $$\n总结：\n原闭环系统稳定，但一定不满足要求的调节，通过频域分析确定初始系统的缺陷后，利用超前补偿器增加相位裕度和增益交叉频率，从而优化了响应速度和稳定性。这种设计方法强调频域与时域性能的结合，通过不断调整 $\\alpha$ 和 $T$ 实现精确的动态控制。换句话说频率分析法也只是看看它稳不稳定罢了，至于要让他满足要求，还得是设计各种前馈器，让他的整体传递函数变化，从而改变伯德图里的相位裕度以及交叉频率，增加相位裕度可以提高阻尼系数，增加交叉频率可以减小稳定时间。单独的增加K可以增加交叉频率，但有缺陷，因此又引入了α与T来调节相位裕度与超调量。 比较难的地方在于α的选择，选α一定就要先找要增加多少相位？也就是目标相位-原始相位（带K），目标相位怎么找？用超调量找阻尼比再找相位（图标关系），于是可以得出，根据要求的超调量就可以找到α，其T值水到渠成的就得到了，因此整个超前补偿器就设计完毕了。但仍需要不断观察伯德图与输出响应曲线来对比不同之处，并判断是否的确满足系统要求。 3.状态空间法 （1）前面已经得到过状态空间形式的动力学方程\n$$ \\begin{bmatrix} \\dot{\\alpha} \\\\ \\dot{q} \\\\ \\dot{\\theta} \\end{bmatrix} = \\begin{bmatrix} -0.313 \u0026 56.7 \u0026 0 \\\\ -0.0139 \u0026 -0.426 \u0026 0 \\\\ 0 \u0026 56.7 \u0026 0 \\end{bmatrix} \\begin{bmatrix} \\alpha \\\\ q \\\\ \\theta \\end{bmatrix} + \\begin{bmatrix} 0.232 \\\\ 0.0203 \\\\ 0 \\end{bmatrix} \\begin{bmatrix} \\delta \\end{bmatrix} $$ $$ y = \\begin{bmatrix} 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} \\alpha \\\\ q \\\\ \\theta \\end{bmatrix} + \\begin{bmatrix} 0 \\end{bmatrix} \\begin{bmatrix} \\delta \\end{bmatrix} $$ 上面等式与一般的线性状态空间形式匹配 $$ \\frac{dx}{dt} = A x + B u $$\n$$ y = C x + D u $$\n（2）因此将采用状态空间控制器来设计系统，来放置闭环极点\n要想设计状态空间控制器，首先要看能控性能观性。能控性对应了我们可以将闭环极点放置在s平面的任意位置，给出能控性矩阵\n$$ C = [B , AB , A^2B , \\dots , A^{n-1}B] $$ （3） 其中 $n$ 对应状态变量的数量。由于我们的矩阵为 $3 \\times 3$，因此矩阵的秩 $\\text{rank}$ 也必须为 $3$（满秩）。为了验证这一点，可以使用命令来查看矩阵的秩。\n1 2 3 4 5 6 7 8 9 10 11 %% 连续状态空间法 - 能控性与极点布置 % 定义连续状态空间模型 A = [-0.313 56.7 0; -0.0139 -0.426 0; 0 56.7 0]; B = [0.232; 0.0203; 0]; C = [0 0 1]; D = [0]; % 检查系统能控性 co = ctrb(A, B); % 能控性矩阵 Controllability = rank(co); disp(['连续系统能控性: Rank = ', num2str(Controllability)]); 其中co为： $$ C_o = \\text{ctrb}(A, B) , \\text{returns the controllability matrix:} $$\n$$ C_o = [B , AB , A^2B , \\dots , A^{n-1}B] $$\n得到结果连续系统能控性: Rank = 3，证明矩阵满秩，完全可控。能观性略\n通过极点布置来进行控制设计 （4）全状态反馈控制系统原理图如下（ABC就是表达式里的值，这里D=0）\n其中 $K$ 为增益矩阵，$\\mathbf{x} = [\\alpha, q, \\theta]^\\top$ 为状态向量，$\\theta_{\\text{des}}$ 为参考信号 ($r$)，$\\delta = \\theta_{\\text{des}} - K\\mathbf{x}$ 为控制输入 ($u$)，$\\theta$ 为输出 ($y$)\n(5) 由于新的 $\\delta = \\theta_{\\text{des}} - K\\mathbf{x}$，将其代入到原状态方程中，得到新状态方程如下：\n$$ \\dot{\\mathbf{x}} = (A - BK)\\mathbf{x} + B\\theta_{\\text{des}} $$\n$$ \\theta = C\\mathbf{x} $$\n因此，矩阵 $A - BK$ 确定了系统的闭环动力学，其行列式 $\\det(sI - (A - BK))$ 的根是系统的闭环极点。由于该行列式是三阶的，因此可以任意放置的极点数量为三个。再加上系统是完全能控的，因此极点的位置可以随意配置。\n控制系统的性能主要取决于系统的极点在根平面上的分布。可以按照设计意图调整的参数是反馈增益矩阵 $K$。经典控制理论中的根轨迹法就是一种极点配置方法，其核心目标是通过各种手段重新配置开环系统的极点与零点。\n需要注意的是，此反馈定律假定矢量 $\\mathbf{x}$ 中的所有状态变量均已被测量，否则需要设计一个观察器来估计状态变量。\n注意：实际上并不是只有这一种新的状态方程，也可以引入一个状态观测器G，然后以C来算，不过很麻烦。举例如下\n状态观测器公式： $$ \\dot{\\hat{X}} = (A - GC)\\hat{X} + GY + Bu $$\n$$ Y = C\\hat{X} $$\n反馈控制率公式： $$ u = KX + v $$ 根据系统性能指标的公式：\n超调量：\n$$ \\sigma\\% = e^{-\\frac{\\pi \\zeta}{\\sqrt{1 - \\zeta^2}}} $$ 调整时间：\n$$ t_s = \\frac{4}{\\zeta \\omega_n} $$ 系统闭环特征方程： $$ s^2 - 8440.0565K_d s - 8440.0565K_p - 956.0587 = 0 $$ 阻尼比：\n$$ \\zeta = \\frac{-8440.0565K_d}{2\\sqrt{-8440.0565K_p - 956.0587}} $$ 自然频率：\n$$ \\omega_n = \\sqrt{-8440.0565K_p - 956.0587} $$ 超调量：\n$$ \\sigma\\% = e^{-\\frac{\\pi \\zeta}{\\sqrt{1 - \\zeta^2}}} $$ 调整时间：\n$$ t_s = \\frac{4}{\\zeta \\omega_n} $$ （6）因此有三个可以任意放置位置的极点，可问题是放在哪里？如果有标准的一阶或者二阶系统，那么极点的位置与阶跃响应的特性有直接的关系，利用这些关系可以得到极点的位置。但是如果是高阶系统，可以将高阶极点放置在复平面中比主导极点偏左 5-10 倍的位置（由于太左，对瞬态响应的影响就忽略不计了）。但是这样也有两点局限性：\n其一是难以解决零点的问题； 其二是工作量可能大。 由此可见，这种放置极点的方法不行。\n（7）因此，为了得到反馈增益矩阵 $K$，将使用 LQR（线性二次调节器）来生成最佳增益矩阵 $K$。这样就不必计算要将极点放在哪个特定位置。若要使用 LQR，需要定义两个参数：状态成本加权矩阵 $Q$ 和控制权重矩阵 $R$。为图简单，选择 $R = 1$，$Q = p C^\\top C$。在这种情况下，$\\theta$ 是输出中唯一的状态变量，而加权因子 $p$ 将被更新以修改阶跃响应。对于 $R$，由于只有一个输入，因此它是标量。\n（8）LQR 参数全了，接下来得到反馈控制矩阵 $K$，先令加权因子 $p = 2$。\n1 2 3 4 5 6 7 8 9 % 定义LQR权重矩阵 p = 50; % 状态加权因子 Q = p * C' * C; % 状态成本加权矩阵 R = 1; % 控制权重矩阵 % 求解状态反馈增益矩阵K [K] = lqr(A, B, Q, R); disp('LQR设计的反馈增益矩阵K:'); disp(K); $$ Q = \\begin{bmatrix} 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 2 \\end{bmatrix} $$ $$ K = \\begin{bmatrix} -0.5034 \u0026 52.8645 \u0026 1.4142 \\end{bmatrix} $$\n（9）接下来根据新状态方程来生成闭环阶跃响应曲线图\n1 2 3 4 5 6 7 8 % 构造闭环系统 sys_cl = ss(A - B * K, B, C, D); figure; step(sys_cl); grid on; title('连续状态空间下的LQR闭环阶跃响应'); xlabel('时间 (秒)'); ylabel('俯仰角 (度)'); （10）明显可见，响应太慢，可以通过调整LQR来优化，具体的讲，就是增加加权因子 $p$ 来完成，现在将 $p=50$\n得到 $$ K = \\begin{bmatrix} -0.6435 \u0026 169.6950 \u0026 7.0711 \\end{bmatrix} $$ （11）比较不错，美中不足是和我们预设的阶跃信号1相差有点大，有没有办法让他最终稳定在1附近？此时LQR无能为力了，需要引入预补偿器 $N(-)$\n添加预补偿器 注意，一直使用的全状态反馈系统并不是将输出值与参考输入值直接相比较，而是有个反馈矩阵K。因此为了获得所需要的输出可以缩放参考输入，使其输出在稳定时等于输入。加入预补偿器。\n(12)因此得到了带有预补偿器的比例因子的状态反馈系统\n(13) 其中的比例因子 $N$ （-）需要在用户定义函数（官方 help 文档中）rscale.m 中计算得到。该函数用于查找比例因子以消除稳态误差。\n1 2 3 4 %% 连续状态空间法 - 添加预补偿器 % 计算预补偿器Nbar Nbar = rscale(A, B, C, D, K); % 官方函数 rscale.m disp(['预补偿器比例因子Nbar = ', num2str(Nbar)]); 下面给出具体的函数代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function Nbar = rscale(A, B, C, D, K) % RSCALE calculates the scale factor Nbar to ensure zero steady-state error. % Nbar adjusts the input to match the desired output. % % Usage: % Nbar = rscale(A, B, C, D, K) % % Inputs: % A, B, C, D - State-space matrices % K - State feedback gain % % Output: % Nbar - Input scaling factor % Error check if nargin \u003c 5 error('Usage: Nbar = rscale(A, B, C, D, K)'); end % Compute system size n = size(A, 1); % Form augmented system matrix A_cl = A - B * K; I = eye(size(A)); % Compute Nbar using the formula Nbar = -inv(C * inv(A_cl) * B + D); end 现在系统已经稳定在 $1$ 附近，设计要求达到了。\n(14) 注意：\n添加的预补偿器 $N$ （-）并不位于反馈回路中，这意味着如果存在未知干扰，预补偿器无法消除这部分偏差。换句话说，预补偿器的作用仅是对输入进行放大或缩小。例如，在此设计中，将输入放大了 $7$ 倍，从而使输出从原来的 $0.14$ 变为我们设定的 $1$（仅是振幅提高）。但从本质上说，稳态误差并未真正被消除。可以观察图中输出并未完全稳定在 $1$，原因在于 $N$ 不在反馈回路内，因此无法真正改变输出的波形，也不能有效减少稳态误差。\n一种改进的方法是将预补偿器与积分控制相结合。这样不仅可以缩放输出波形，同时还能在一定程度上减小稳态误差。\n4.离散状态空间法-数字控制器设计法 (1)原连续时间状态方程如下，还是利用这个状态方程，但是现在想要得到新的离散时间状态空间方程\n$$ \\begin{bmatrix} \\dot{\\alpha} \\\\ \\dot{q} \\\\ \\dot{\\theta} \\end{bmatrix} = \\begin{bmatrix} -0.313 \u0026 56.7 \u0026 0 \\\\ -0.0139 \u0026 -0.426 \u0026 0 \\\\ 0 \u0026 56.7 \u0026 0 \\end{bmatrix} \\begin{bmatrix} \\alpha \\\\ q \\\\ \\theta \\end{bmatrix} + \\begin{bmatrix} 0.232 \\\\ 0.0203 \\\\ 0 \\end{bmatrix} \\begin{bmatrix} \\delta \\end{bmatrix} $$ $$ y = \\begin{bmatrix} 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} \\alpha \\\\ q \\\\ \\theta \\end{bmatrix} + \\begin{bmatrix} 0 \\end{bmatrix} \\begin{bmatrix} \\delta \\end{bmatrix} $$ 离散状态空间 (2) 要想设计数字控制系统，第一步必须使用 c2d 命令生成系统的采样数据模型（用编程从连续时间模型得到此模型）。而 c2d 命令需要三个参数：系统模型 + 采样时间 + 保持电路的类型。本实例中加入的是一个零阶保持电路（zoh）。\n为了选择采样时间（防止漏信号），将采样频率与系统动态相比较，通常来讲，采样频率至少比闭环波特图的带宽频率大 30 倍。（带宽频率也称为闭环截止频率，是指当闭环幅频特性下降到频率为零时的分贝值以下 3 dB 时，对应的频率）\n（额外补充：开环截止频率也称为剪切频率，是 开环幅频特性 中，幅频特性曲线穿越 0 dB 线的频率，记为 $\\omega_c$；闭环截止频率也称为带宽频率，是指当 闭环幅频特性曲线 下降到 -3 dB 时，对应的频率，记作 $\\omega_b$。开环 bode 图 ≠ 闭环 bode 图）\n根据闭环波特图可得，带宽频率为 $2 , \\text{rad/sec}$，因此得到 $0.01 , \\text{s}$ 的采样时间。\n(3)使用c2d函数\n1 2 3 4 %% 离散状态空间法 - 离散化与能控性检查 % 将连续系统离散化 Ts = 0.01; % 采样时间 (秒) sys_d = c2d(ss(A, B, C, D), Ts, 'zoh'); (4)因此就得到了离散时间状态空间模型\n$$ \\begin{bmatrix} \\alpha(k+1) \\\\ q(k+1) \\\\ \\theta(k+1) \\end{bmatrix} = \\begin{bmatrix} 0.9969 \u0026 0.05649 \u0026 0 \\\\ -0.0001 \u0026 0.9957 \u0026 0 \\\\ 0 \u0026 0.5658 \u0026 1 \\end{bmatrix} \\begin{bmatrix} \\alpha(k) \\\\ q(k) \\\\ \\theta(k) \\end{bmatrix} + \\begin{bmatrix} 0.0024 \\\\ 0.0002 \\\\ 0.0001 \\end{bmatrix} \\begin{bmatrix} \\delta(k) \\end{bmatrix} $$ $$ y(k) = \\begin{bmatrix} 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} \\alpha(k) \\\\ q(k) \\\\ \\theta(k) \\end{bmatrix} + \\begin{bmatrix} 0 \\end{bmatrix} \\begin{bmatrix} \\delta(k) \\end{bmatrix} $$ 能控性 (5)与连续一样，必须验证离散系统可控性，依旧是算秩，方法同之前连续系统。\n1 2 3 4 % 检查离散系统能控性 co_d = ctrb(sys_d.A, sys_d.B); Controllability_d = rank(co_d); disp(['离散系统能控性: Rank = ', num2str(Controllability_d)]); 离散系统能控性: $Rank = 3$\n极点布置进行控制设计 (6)和连续状态空间步骤一样，不过这次是离散全状态反馈控制系统\n其中 $q^-1$是延迟算子，依旧假设 $D=0$\n(7)同理得到矩阵\n$$ \\mathbf{x}(k+1) = (A - BK)\\mathbf{x}(k) + B\\theta_{\\text{des}}(k) $$\n$$ \\theta(k) = C\\mathbf{x}(k) $$\n(8)同理使用 $LQR$ 来找 $K$，不过是 $LQR$ 方法的离散版本\n1 2 3 4 5 6 7 8 9 % LQR离散版本 p = 50; % 状态加权因子 Q_d = p * sys_d.C' * sys_d.C; % 离散状态成本加权矩阵 R_d = 1; % 控制权重矩阵 % 求解离散状态反馈增益矩阵K [K_d] = dlqr(sys_d.A, sys_d.B, Q_d, R_d); disp('离散LQR设计的反馈增益矩阵K:'); disp(K_d); $$ K = \\begin{bmatrix} -0.6436 \u0026 168.3611 \u0026 6.9555 \\end{bmatrix} $$\n(9) $K$ 有了$A-BK$ 就有了，离散状态方程所有量就都有了，直接看输出波形\n1 2 3 4 5 6 7 8 9 10 11 12 13 % 构造离散闭环系统 sys_cl_d = ss(sys_d.A - sys_d.B * K_d, sys_d.B, sys_d.C, sys_d.D, Ts); time = 0:Ts:10; % 仿真时间 theta_des = ones(size(time)); % 阶跃输入 [y, t] = lsim(sys_cl_d, theta_des, time); % 绘制离散闭环系统的响应 figure; stairs(t, y); grid on; title('离散LQR下的闭环阶跃响应'); xlabel('时间 (秒)'); ylabel('俯仰角 (度)'); 依旧还是离1差老远。\n预补偿器 (10) 与连续不同的是，Nbar不能通过函数文件来自动算得了，因此只能手动调调改改。最后选定N=6.95\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 %% 离散状态空间法 - 添加预补偿器 % 手动调整预补偿器比例因子 Nbar_d = 6.95; % 根据仿真调整的比例因子 disp(['离散系统预补偿器比例因子Nbar = ', num2str(Nbar_d)]); % 构造加入预补偿器后的离散闭环系统 sys_cl_comp_d = ss(sys_d.A - sys_d.B * K_d, sys_d.B * Nbar_d, sys_d.C, sys_d.D, Ts); [y_comp, t_comp] = lsim(sys_cl_comp_d, theta_des, time); % 绘制加入预补偿器后的离散闭环响应 figure; stairs(t_comp, y_comp); grid on; title('加入预补偿器后的离散LQR闭环阶跃响应'); xlabel('时间 (秒)'); ylabel('俯仰角 (度)'); 设计成功\n5.PID法（不带脑子法） PID的传函如下 $$ C(s) = K_p + \\frac{K_i}{s} + K_d s = \\frac{K_d s^2 + K_p s + K_i}{s} $$\n我认为再多解释一个字都是对这个方法的不尊重\n6.利用simulink建立状况空间模型法 LQR 初步构建模型\n状态空间参数如下\n注：$C$ 矩阵必须为 $3 \\times 3$ 的矩阵，而不是原方程中的 $[0 , 0 , 1]$。这意味着 $C$ 矩阵的维度必须与矩阵 $A$ 保持一致。可以使用 eye(3) 生成 $3 \\times 3$ 的单位矩阵。\n在这种情况下，不仅将 $\\theta$ 视为输出，还将 $\\alpha$ 和 $q$ 一起算作输出。因此，输出包含三条线，但实际上只有 $\\theta$ 的波形是需要重点关注的，其他两条可以忽略。\n运行后，得到了开环阶跃响应（原始状态空间方程下）的输出波形\n可见系统不稳定。参照以前的做法，我们将引入全状态反馈控制系统，这会将系统的状态矩阵变为 $A - BK$。接下来需要确定增益矩阵 $K$，这里利用 LQR 方法求解。为了提升稳态值，还引入了预补偿器。Simulink 模型中依旧按照这一流程进行。\n通过代码计算，得到反馈增益矩阵： $$ K = [-0.6435, 169.6950, 7.0711] $$ 将 $K$ 加入系统后，全状态反馈控制系统就构成了。\n预补偿器 接下来加入预补偿器。由于上面计算得出 $N(-) = 7.0711$，因此只需在系统中增加一个增益块，将输入乘以 $N$ 即可实现预补偿。\n观察θ输出波形已经稳定了，但是差点火候。特别是如果再添加一个扰动，那完蛋了，因为LQR的设计中并没有考虑到模型不确定性的鲁棒性，这也就是为什么LQR渐渐被PID淘汰，后面可以用PID来控制状态空间方程.\nPID 其中的滤波器系数 $N$ 定义了微分项上一阶低通滤波器的时间常数，用于平滑微分信号，减少噪声对控制系统的影响。\n可以在 PID 控制块的 Limit Output 中设置控制器输出的饱和上下限。例如，对于飞机的升降角度，其范围很可能被限制在 $-25^\\circ$ 到 $+25^\\circ$。加入饱和限制可以防止控制信号超出此范围，并用于自动调节 PID 参数以避免失控。\n但是，这样的设计也会引入积分饱和问题：当输出已经达到饱和限制时，积分器仍然继续工作，导致系统响应变得缓慢。为了解决这一问题，PID 控制块中提供了积分器抗饱和策略（在 PID Advanced 选项中选择 Anti-windup method）。这个模块会在积分饱和时立刻停止积分器的工作，而当输出恢复到非饱和状态时重新启用积分器。\n版权说明\n​\t本内容框架和主题是基于 湖南工业大学控制实验室 所发布的教学内容的整理和进一步解释，仅供个人学习及复习回顾使用，我只是一个快乐的调包侠\n",
  "wordCount" : "2443",
  "inLanguage": "zh",
  "image": "http://zehua.eu/images/papermod-cover.png","datePublished": "2023-03-25T16:25:17+01:00",
  "dateModified": "2024-11-23T17:12:35+08:00",
  "author":{
    "@type": "Person",
    "name": "Zehua"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://zehua.eu/zh/posts/probability_cn/%E9%A3%9E%E6%9C%BA%E4%BF%AF%E4%BB%B0%E7%B3%BB%E7%BB%9F/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "主页",
    "logo": {
      "@type": "ImageObject",
      "url": "http://zehua.eu/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://zehua.eu/zh/" accesskey="h" title="主页 (Alt + H)">主页</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://zehua.eu/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://zehua.eu/zh/posts/" title="列表">
                    <span>列表</span>
                </a>
            </li>
            <li>
                <a href="http://zehua.eu/zh/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://zehua.eu/zh/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="http://zehua.eu/zh/about/" title="版权说明">
                    <span>版权说明</span>
                </a>
            </li>
            <li>
                <a href="http://zehua.eu/zh/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://zehua.eu/zh/">主页</a>&nbsp;»&nbsp;<a href="http://zehua.eu/zh/posts/">Posts</a>&nbsp;»&nbsp;<a href="http://zehua.eu/zh/posts/probability_cn/">概率统计</a></div>
    <h1 class="post-title entry-hint-parent">
      飞机俯仰控制系统
    </h1>
    <div class="post-meta">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/all.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/v4-shims.css"><span class="meta-tag"><span class="fa fa-calendar-plus-o"></span>&nbsp;<span title='2023-03-25 16:25:17 +0100 CET'>3月25日, 2023</span></span>&nbsp; | &nbsp;<span class="meta-tag"><span class="fa fa-file-word-o"></span>&nbsp;<span>共2443字</span></span>&nbsp; | &nbsp;<span class="meta-tag"><span class="fa fa-user-circle-o"></span>&nbsp;<span>Zehua</span></span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e4%b8%80%e7%a0%94%e7%a9%b6%e7%9b%ae%e7%9a%84" aria-label="一.研究目的">一.研究目的</a></li>
                    <li>
                        <a href="#%e4%ba%8c%e7%89%a9%e7%90%86%e7%b3%bb%e7%bb%9f%e6%96%b9%e7%a8%8b%e5%bc%8f" aria-label="二.物理系统方程式">二.<strong>物理系统方程式</strong></a><ul>
                            
                    <li>
                        <a href="#%e4%b8%89%e5%af%bb%e6%89%be%e4%bc%a0%e9%80%92%e5%87%bd%e6%95%b0%e5%b9%b6%e5%bb%ba%e7%ab%8b%e7%8a%b6%e6%80%81%e7%a9%ba%e9%97%b4%e8%a1%a8%e8%be%be%e5%bc%8f" aria-label="三.寻找传递函数并建立状态空间表达式">三.寻找传递函数并建立状态空间表达式</a><ul>
                            
                    <li>
                        <a href="#1%e4%bc%a0%e9%80%92%e5%87%bd%e6%95%b0%e7%9a%84%e6%b1%82%e5%be%97" aria-label="1.传递函数的求得">1.传递函数的求得</a></li>
                    <li>
                        <a href="#2%e7%8a%b6%e6%80%81%e7%a9%ba%e9%97%b4%e6%96%b9%e7%a8%8b" aria-label="2.状态空间方程">2.状态空间方程</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e5%9b%9b%e7%b3%bb%e7%bb%9f%e5%88%86%e6%9e%90" aria-label="四.系统分析">四.系统分析</a><ul>
                            
                    <li>
                        <a href="#1%e8%ae%be%e8%ae%a1%e8%a6%81%e6%b1%82" aria-label="1.设计要求">1.设计要求</a></li>
                    <li>
                        <a href="#2%e5%bc%80%e7%8e%af%e4%bc%a0%e5%87%bd%e7%b3%bb%e7%bb%9f%e5%88%86%e6%9e%90" aria-label="2.开环传函系统分析">2.开环传函系统分析</a></li>
                    <li>
                        <a href="#3%e9%97%ad%e7%8e%af%e4%bc%a0%e9%80%92%e5%87%bd%e6%95%b0%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90" aria-label="3.闭环传递函数性能分析">3.闭环传递函数性能分析</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e4%ba%94%e6%8e%a7%e5%88%b6%e6%96%b9%e6%b3%95%e4%b8%8e%e7%bb%93%e6%9e%9c%e5%88%86%e6%9e%90" aria-label="五.控制方法与结果分析">五.控制方法与结果分析</a><ul>
                            
                    <li>
                        <a href="#1%e6%a0%b9%e8%bd%a8%e8%bf%b9%e6%b3%95" aria-label="1.根轨迹法">1.根轨迹法</a><ul>
                            
                    <li>
                        <a href="#%e8%b6%85%e5%89%8d%e8%a1%a5%e5%81%bf%e5%99%a8" aria-label="超前补偿器">超前补偿器</a></li></ul>
                    </li>
                    <li>
                        <a href="#2%e9%a2%91%e5%9f%9f%e5%88%86%e6%9e%90%e6%b3%95" aria-label="2.频域分析法">2.频域分析法</a><ul>
                            
                    <li>
                        <a href="#%e8%b6%85%e5%89%8d%e8%a1%a5%e5%81%bf%e5%99%a8-1" aria-label="超前补偿器"><strong>超前补偿器</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#3%e7%8a%b6%e6%80%81%e7%a9%ba%e9%97%b4%e6%b3%95" aria-label="3.状态空间法">3.状态空间法</a><ul>
                            
                    <li>
                        <a href="#%e9%80%9a%e8%bf%87%e6%9e%81%e7%82%b9%e5%b8%83%e7%bd%ae%e6%9d%a5%e8%bf%9b%e8%a1%8c%e6%8e%a7%e5%88%b6%e8%ae%be%e8%ae%a1" aria-label="通过极点布置来进行控制设计"><strong>通过极点布置来进行控制设计</strong></a></li>
                    <li>
                        <a href="#%e6%b7%bb%e5%8a%a0%e9%a2%84%e8%a1%a5%e5%81%bf%e5%99%a8" aria-label="添加预补偿器"><strong>添加预补偿器</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#4%e7%a6%bb%e6%95%a3%e7%8a%b6%e6%80%81%e7%a9%ba%e9%97%b4%e6%b3%95-%e6%95%b0%e5%ad%97%e6%8e%a7%e5%88%b6%e5%99%a8%e8%ae%be%e8%ae%a1%e6%b3%95" aria-label="4.离散状态空间法-数字控制器设计法">4.离散状态空间法-数字控制器设计法</a><ul>
                            
                    <li>
                        <a href="#%e7%a6%bb%e6%95%a3%e7%8a%b6%e6%80%81%e7%a9%ba%e9%97%b4" aria-label="离散状态空间">离散状态空间</a></li>
                    <li>
                        <a href="#%e8%83%bd%e6%8e%a7%e6%80%a7" aria-label="能控性">能控性</a></li>
                    <li>
                        <a href="#%e6%9e%81%e7%82%b9%e5%b8%83%e7%bd%ae%e8%bf%9b%e8%a1%8c%e6%8e%a7%e5%88%b6%e8%ae%be%e8%ae%a1" aria-label="极点布置进行控制设计">极点布置进行控制设计</a></li>
                    <li>
                        <a href="#%e9%a2%84%e8%a1%a5%e5%81%bf%e5%99%a8" aria-label="预补偿器">预补偿器</a></li></ul>
                    </li>
                    <li>
                        <a href="#5pid%e6%b3%95%e4%b8%8d%e5%b8%a6%e8%84%91%e5%ad%90%e6%b3%95" aria-label="5.PID法（不带脑子法）">5.PID法（不带脑子法）</a></li>
                    <li>
                        <a href="#6%e5%88%a9%e7%94%a8simulink%e5%bb%ba%e7%ab%8b%e7%8a%b6%e5%86%b5%e7%a9%ba%e9%97%b4%e6%a8%a1%e5%9e%8b%e6%b3%95" aria-label="6.利用simulink建立状况空间模型法">6.利用simulink建立状况空间模型法</a><ul>
                            
                    <li>
                        <a href="#lqr" aria-label="LQR">LQR</a></li>
                    <li>
                        <a href="#%e9%a2%84%e8%a1%a5%e5%81%bf%e5%99%a8-1" aria-label="预补偿器">预补偿器</a></li>
                    <li>
                        <a href="#pid" aria-label="PID">PID</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="一研究目的">一.研究目的<a hidden class="anchor" aria-hidden="true" href="#一研究目的">#</a></h1>
<p>为提高大仰角飞行状态下的飞机控制系统的稳态精度，为保持或者稳定飞行器的姿态角，需要对角度进行一定的控制，保证其稳定性</p>
<h1 id="二物理系统方程式">二.<strong>物理系统方程式</strong><a hidden class="anchor" aria-hidden="true" href="#二物理系统方程式">#</a></h1>
<p>飞机总的方程式非常复杂，有六个非线性耦合微分方程，因此需对其进行解耦并线性化，分成横向和纵向方程。而此处的俯仰系统只由纵向动力学决定。</p>
<p>将设计一个自动驾驶仪(就是不同的控制器)来控制飞机俯仰角。飞机坐标轴建立与力如图所示。</p>
<p>对其中参数进行说明：</p>
<p>① $X&rsquo;$ $Z&rsquo;$ 都是地面坐标系，$X$ $Z$ 是机体坐标系，一个指向机头，一个指向机腹，原点为飞机质心</p>
<p>② $θ$ 为俯仰角（姿态角） $α$ 为气动角 $δ$ 为升降舵偏转角</p>
<p>③ $v$ 是速度方向，构成了风轴系</p>
<p>为了简化问题，我们假设①现在的推力 阻力在x轴上平衡，重力与升力在Y轴上平衡。与此同时，假设②俯仰角θ的变化并不会改变飞机速度的变化。由此可以得到纵向运动方程如下：
$$
\dot{\alpha} = \mu \Omega \sigma \left[-(C_L + C_D)\alpha + \frac{1}{(\mu - C_L)}q - (C_W \sin \gamma)\theta + C_L \right]
$$</p>
<p>$$
\dot{q} = \frac{\mu \sigma \Omega}{2 i_{yy}} \left[[C_M - \eta(C_L + C_D)]\alpha + [C_M + \sigma C_M (1 - \mu C_L)]q + (\eta C_W \sin \gamma) \delta \right]
$$</p>
<p>$$
\dot{\theta} = \Omega q
$$</p>
<p>可见，输入是 $δ$，输出是 $θ$</p>
<h2 id="三寻找传递函数并建立状态空间表达式">三.寻找传递函数并建立状态空间表达式<a hidden class="anchor" aria-hidden="true" href="#三寻找传递函数并建立状态空间表达式">#</a></h2>
<h3 id="1传递函数的求得">1.传递函数的求得<a hidden class="anchor" aria-hidden="true" href="#1传递函数的求得">#</a></h3>
<p>将上述纵向运动方程简化
$$
\dot{\alpha} = -0.313\alpha + 56.7q + 0.232\delta
$$</p>
<p>$$
\dot{q} = -0.0139\alpha - 0.426q + 0.0203\delta
$$</p>
<p>$$
\dot{\theta} = 56.7q
$$</p>
<p>将其进行拉普拉斯变换，使用单位阶跃输入 $R(s) = 1/s$ 得
$$
sA(s) = -0.313A(s) + 56.7Q(s) + 0.232\Delta(s)
$$</p>
<p>$$
sQ(s) = -0.0139A(s) - 0.426Q(s) + 0.0203\Delta(s)
$$</p>
<p>$$
s\Theta(s) = 56.7Q(s)
$$</p>
<p>阶跃信号用于模拟突然变化的输入，例如飞机需要快速响应新的姿态角设定</p>
<p>不难得到传递函数
$$
P(s) = \frac{\Theta(s)}{\Delta(s)} = \frac{1.151s + 0.1774}{s^3 + 0.739s^2 + 0.921s}
$$</p>
<h3 id="2状态空间方程">2.状态空间方程<a hidden class="anchor" aria-hidden="true" href="#2状态空间方程">#</a></h3>
<p>状态空间形式便于在多输入多输出（MIMO）系统中统一表示动态方程，因此由上述公式写成矩阵形式有</p>
<div> 
$$
\begin{bmatrix}
\dot{\alpha} \\
\dot{q} \\
\dot{\theta}
\end{bmatrix}
=
\begin{bmatrix}
-0.313 & 56.7 & 0 \\
-0.0139 & -0.426 & 0 \\
0 & 56.7 & 0
\end{bmatrix}
\begin{bmatrix}
\alpha \\
q \\
\theta
\end{bmatrix}
+
\begin{bmatrix}
0.232 \\
0.0203 \\
0
\end{bmatrix}
\begin{bmatrix}
\delta
\end{bmatrix}
$$ 
</div>
<p>$$
y =
\begin{bmatrix}
0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
\alpha \
q \
\theta
\end{bmatrix}
$$</p>
<h1 id="四系统分析">四.系统分析<a hidden class="anchor" aria-hidden="true" href="#四系统分析">#</a></h1>
<h2 id="1设计要求">1.设计要求<a hidden class="anchor" aria-hidden="true" href="#1设计要求">#</a></h2>
<p>输入信号为阶跃信号，要求得到的波形性能指标如下：</p>
<ul>
<li>俯仰角的超调量小于10%</li>
<li>上升时间小于2s</li>
<li>稳定时间小于10s</li>
<li>稳态误差小于2%</li>
</ul>
<h2 id="2开环传函系统分析">2.开环传函系统分析<a hidden class="anchor" aria-hidden="true" href="#2开环传函系统分析">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 定义传递函数和开环系统分析</span>
</span></span><span class="line"><span class="cl"><span class="c">% 定义传递函数</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span> <span class="p">=</span> <span class="n">tf</span><span class="p">(</span><span class="s">&#39;s&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">P_pitch</span> <span class="p">=</span> <span class="p">(</span><span class="mf">1.151</span><span class="o">*</span><span class="n">s</span> <span class="o">+</span> <span class="mf">0.1774</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s</span>^<span class="mi">3</span> <span class="o">+</span> <span class="mf">0.739</span><span class="o">*</span><span class="n">s</span>^<span class="mi">2</span> <span class="o">+</span> <span class="mf">0.921</span><span class="o">*</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 绘制开环系统的阶跃响应</span>
</span></span><span class="line"><span class="cl"><span class="n">t</span> <span class="p">=</span> <span class="mi">0</span><span class="p">:</span><span class="mf">0.01</span><span class="p">:</span><span class="mi">10</span><span class="p">;</span>  <span class="c">% 时间向量</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">step</span><span class="p">(</span><span class="n">P_pitch</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;俯仰角 (度)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;时间 (秒)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;开环系统的阶跃响应&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>  <span class="c">% 增加网格便于观察</span>
</span></span><span class="line"><span class="cl"><span class="n">set</span><span class="p">(</span><span class="n">gca</span><span class="p">,</span> <span class="s">&#39;FontSize&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span> <span class="c">% 增大字体，便于阅读</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 检查传递函数的极点</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="s">&#39;开环系统的极点为:&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">open_loop_poles</span> <span class="p">=</span> <span class="n">pole</span><span class="p">(</span><span class="n">P_pitch</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="n">open_loop_poles</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>得到三个极点与开传函图像：</p>
<ul>
<li>
<p>0.0000 + 0.0000i</p>
</li>
<li>
<p>-0.3695 + 0.8857i</p>
</li>
<li>
<p>-0.3695 - 0.8857i</p>
<img src="/img/sys_airplane/2.png" alt="描述" style="width: 70%;">
</li>
</ul>
<p>要对其进行修正，而极点也表明了，一个极点在虚轴上，其他两个极点在复数域s的左半平面。这个虚轴上的极点表示其相应波形并不会无限上升，但即使如此，由于虚轴极点的特性，给定输入时，依然有可能无限上升。即虚轴极点导致系统对阶跃输入响应呈现无界增长，这是不稳定开环系统的典型特征，在此种特殊情况下，其极点像个积分器，当给定阶跃输入时，对其常数进行积分会导致输出无穷大。</p>
<h2 id="3闭环传递函数性能分析">3.闭环传递函数性能分析<a hidden class="anchor" aria-hidden="true" href="#3闭环传递函数性能分析">#</a></h2>
<p>显然开环不能满足，加入反馈模块。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 闭环系统分析</span>
</span></span><span class="line"><span class="cl"><span class="c">% 定义闭环系统（单位反馈）</span>
</span></span><span class="line"><span class="cl"><span class="n">sys_cl</span> <span class="p">=</span> <span class="n">feedback</span><span class="p">(</span><span class="n">P_pitch</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 绘制闭环系统的阶跃响应</span>
</span></span><span class="line"><span class="cl"><span class="n">t</span> <span class="p">=</span> <span class="mi">0</span><span class="p">:</span><span class="mf">0.01</span><span class="p">:</span><span class="mi">60</span><span class="p">;</span>  <span class="c">% 使用更长时间范围分析系统收敛特性</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">step</span><span class="p">(</span><span class="n">sys_cl</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;俯仰角 (度)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;时间 (秒)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;闭环系统的阶跃响应&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">set</span><span class="p">(</span><span class="n">gca</span><span class="p">,</span> <span class="s">&#39;FontSize&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 检查闭环系统的极点</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="s">&#39;闭环系统的极点为:&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">closed_loop_poles</span> <span class="p">=</span> <span class="n">pole</span><span class="p">(</span><span class="n">sys_cl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="n">closed_loop_poles</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>闭环传递函数
$$
\text{sys}_{cl} = \frac{1.151s + 0.1774}{s^3 + 0.739s^2 + 2.072s + 0.1774}
$$
在阶跃响应下的波形图：</p>
<img src="/img/sys_airplane/4.png" alt="描述" style="width: 70%;">
<p>由图可见，闭环系统仍然不满足要求，但稳态误差e近乎为0，且无超调量</p>
<p>（1）继续对传递函数的极点与零点进行分析</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% 查看闭环系统的极点</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="s">&#39;闭环传递函数的极点为:&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">pole</span><span class="p">(</span><span class="n">sys_cl</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div>
$$
\text{极点为} =
\begin{cases}
-0.3255 + 1.3816i \\
-0.3255 - 1.3816i \\
-0.0881 + 0.0000i
\end{cases}
$$
</div>
<p>$$
零点为 =  -0.1541
$$</p>
<p>不难看出，其闭环传函系统是稳定的，因为所有极点都具有负实部，尽管都位于左半平面，但复共轭极点的虚部较大，导致系统呈现较明显的振荡特性。此传递函数是三阶系统，由于往常都是使用标准的无阻尼且无零点的二阶系统，因此在本例中不可以依赖零极点关系。不如将输出转换回时域，用系统响应时间函数来了解零极点如何影响系统。</p>
<p>(2) 闭环传递函数形式为 $Y(s)/R(s)$, 可得 $Y(s) = \text{传递函数} \cdot R(s)$</p>
<p>再将得到的 $Y(s)$ 进行分解因式，部分分数展开用于将高阶系统的传递函数分解为一阶和二阶子系统的叠加，便于理解其动态响应，使用命令 <code>zpk</code> 进行分解。
$$
Y(s) = k \cdot \frac{(s-z_1)(s-z_2)\dots}{(s-p_1)(s-p_2)\dots}
$$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 分解闭环系统传递函数</span>
</span></span><span class="line"><span class="cl"><span class="c">% 定义阶跃输入 R(s) = 1/s</span>
</span></span><span class="line"><span class="cl"><span class="n">R</span> <span class="p">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 分解闭环输出 Y(s)</span>
</span></span><span class="line"><span class="cl"><span class="n">Y</span> <span class="p">=</span> <span class="n">zpk</span><span class="p">(</span><span class="n">sys_cl</span> <span class="o">*</span> <span class="n">R</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="s">&#39;闭环系统输出传递函数的零极点增益形式:&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="n">Y</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{aligned}
Y(s) &amp;= \frac{0.2302(s + 0.1541)}{s(s + 0.08805)(s^2 + 0.6509s + 2.105)} \
&amp;= \frac{A}{s} + \frac{B}{s + 0.08805} + \frac{Cs + D}{s^2 + 0.6509s + 2.105}
\end{aligned}
$$</p>
<p>可以看出，其极点分布为，原点，实极的一阶项，共轭复极的二阶项。再将其因式分解成如下形式</p>
<p>（3）现在就开始求ABCD，可手动计算，或用命令计算，使用residue命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% 部分分数展开</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="p">=</span> <span class="n">residue</span><span class="p">([</span><span class="mf">1.151</span> <span class="mf">0.1774</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span> <span class="mf">0.739</span> <span class="mf">2.072</span> <span class="mf">0.1774</span> <span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="s">&#39;部分分数展开的残差 （零点分布）:&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="s">&#39;部分分数展开的极点:&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="s">&#39;多项式余项:&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>零点</p>
<div>
$$
r =
\begin{cases}
-0.2802 + 0.0800i \\
-0.2802 - 0.0800i \\
-0.4395 + 0.0000i \\
1.0000 + 0.0000i
\end{cases}
$$
</div>
<p>极点</p>
<div>
$$
r =
\begin{cases}
-0.2802 + 0.0800i \\
-0.2802 - 0.0800i \\
-0.4395 + 0.0000i \\
1.0000 + 0.0000i
\end{cases}
$$
</div>
<p>$$
k =[\quad ]
$$</p>
<p>$r$ 包含部分分数展开的残差，即 $A, B$；$p$ 包含系统的极点，极点的阶次对应 $r$ 中残基的阶次；$k$ 由于通常分子多项式比分母多项式小，一般为空，因此 $A = 1, B = -0.0881$</p>
<p>（4）接下来再求CD，其求法为让复共轭极点项分解成单项表达式来确定</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">% 提取复共轭极点部分
</span></span><span class="line"><span class="cl">[num, den] = residue(r(1:2), p(1:2), k);
</span></span><span class="line"><span class="cl">disp(&#39;复共轭极点部分的分子与分母:&#39;);
</span></span><span class="line"><span class="cl">disp(&#39;分子:&#39;);
</span></span><span class="line"><span class="cl">disp(num);
</span></span><span class="line"><span class="cl">disp(&#39;分母:&#39;);
</span></span><span class="line"><span class="cl">disp(den);
</span></span></code></pre></td></tr></table>
</div>
</div><p>可得</p>
<p>$C = -0.5605$,   $D = -0.4036$
$$
\frac{-0.5605s - 0.4036}{s^2 + 0.6509s + 2.015}
$$</p>
<p>（5）至此，ABCD全得到了，进行逆变换求解</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">%% 求解闭环系统的时域响应
</span></span><span class="line"><span class="cl">syms s t
</span></span><span class="line"><span class="cl">F = 1/s - 0.881/(s + 0.08805) - (0.5605*s + 0.4036)/(s^2 + 0.6509*s + 2.015);
</span></span><span class="line"><span class="cl">y_t = ilaplace(F);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">disp(&#39;闭环系统的时域响应表达式:&#39;);
</span></span><span class="line"><span class="cl">disp(vpa(y_t, 4));  % 显示高精度表达式
</span></span></code></pre></td></tr></table>
</div>
</div><p>（6）得到了 $y(t)$
$$
y(t) = 1.0 - 0.5605 e^{-0.3255 t} \left(\cos(1.382 t) + 0.2856 \sin(1.382 t)\right) - 0.881 e^{-0.08805 t}
$$</p>
<p>每个项应该对应传函极点，而极点的实部又描述了其指数的增长或衰减，虚部对应其振荡频率</p>
<p>至此可以了解拉普拉斯域中零极点如何影响时域。</p>
<p>（7）将时域进行画图，和之前应该对应</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">%% 绘制闭环系统的时域响应曲线
</span></span><span class="line"><span class="cl">% 定义时间向量
</span></span><span class="line"><span class="cl">t3 = 0:0.1:70;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">% 时域响应的计算
</span></span><span class="line"><span class="cl">yy = 1 - (1121*exp(-(6509*t3)/20000).*(cos((763632919^(1/2)*t3)/20000) + ...
</span></span><span class="line"><span class="cl">    (8847411*763632919^(1/2)*sin((763632919^(1/2)*t3)/20000))/856032502199))/2000 - ...
</span></span><span class="line"><span class="cl">    (881*exp(-(1761*t3)/20000))/1000;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">% 绘制时域响应曲线
</span></span><span class="line"><span class="cl">figure;
</span></span><span class="line"><span class="cl">plot(t3, yy, &#39;LineWidth&#39;, 1.5); % 增加曲线宽度
</span></span><span class="line"><span class="cl">xlabel(&#39;时间 (秒)&#39;);
</span></span><span class="line"><span class="cl">ylabel(&#39;俯仰角 (度)&#39;);
</span></span><span class="line"><span class="cl">title(&#39;闭环系统的时域响应曲线&#39;);
</span></span><span class="line"><span class="cl">grid on;
</span></span><span class="line"><span class="cl">set(gca, &#39;FontSize&#39;, 12);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">% 标注响应特性
</span></span><span class="line"><span class="cl">text(15, 0.8, &#39;稳态响应近似为1&#39;, &#39;FontSize&#39;, 12, &#39;Color&#39;, &#39;red&#39;);
</span></span></code></pre></td></tr></table>
</div>
</div><img src="/img/sys_airplane/5.png" alt="描述" style="width: 70%;">
<p>（8）至此表明闭环也不能满足要求，接下来设计一些其他的控制器来完成目标性能</p>
<h1 id="五控制方法与结果分析">五.控制方法与结果分析<a hidden class="anchor" aria-hidden="true" href="#五控制方法与结果分析">#</a></h1>
<h2 id="1根轨迹法">1.根轨迹法<a hidden class="anchor" aria-hidden="true" href="#1根轨迹法">#</a></h2>
<ul>
<li><strong>闭环根轨迹增益=开环前向通路根轨迹增益（单位反馈）</strong></li>
<li><strong>闭环传递函数的零点分别为开传函的零点+反馈回路的极点，若反馈回路为1，则就是开传函的零点。即闭环零点=开环零点</strong></li>
<li><strong>闭环极点与开环零点，开环极点以及根轨迹增益K均有关</strong></li>
</ul>
<p><strong>对根轨迹做出一些解释说明</strong></p>
<ul>
<li>根轨迹设计的主要思想是 有很多可能的闭环极点位置，当处于某个位置的时候，去预测闭环输出响应。因此，通过增加零点或者极点，就可以修改根轨迹，使得极点可以处于新根轨迹上新的位置，从而可以实现所需要的闭环响应。而这个不断选择的位置其实本质就是Kp值的大小。</li>
<li>增加开环极点对根轨迹的影响如下：开环极点会改变根轨迹在实轴上的分布，并改变渐近线的条数+倾角+截距，改变根轨迹分支数，根轨迹会向右偏移。在这种情况下，不利于稳定性与动态性能，并且所增加的开环极点越靠近虚轴，影响就越大</li>
<li>增加开环零点对根轨迹的影响如下：开环零点同样会改变根轨迹在实轴上的分布，并改变渐近线的条数+倾角+截距，如果开环零点与开环极点相距很近，或者近乎重合，那么两者可以相互抵消。因此通常加入零点来抵消不利的开环极点，引入开环零点后根轨迹会向左偏移，会提高稳定性，改善动态性能，，同样，开环零点越靠近虚轴，影响就越大</li>
</ul>
<p>（1）先找到开环传递函数根轨迹图</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 根轨迹法 - 开环根轨迹设计</span>
</span></span><span class="line"><span class="cl"><span class="c">% 定义传递函数</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span> <span class="p">=</span> <span class="n">tf</span><span class="p">(</span><span class="s">&#39;s&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">P_pitch</span> <span class="p">=</span> <span class="p">(</span><span class="mf">1.151</span><span class="o">*</span><span class="n">s</span> <span class="o">+</span> <span class="mf">0.1774</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s</span>^<span class="mi">3</span> <span class="o">+</span> <span class="mf">0.739</span><span class="o">*</span><span class="n">s</span>^<span class="mi">2</span> <span class="o">+</span> <span class="mf">0.921</span><span class="o">*</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 打开控制系统设计器进行根轨迹分析</span>
</span></span><span class="line"><span class="cl"><span class="n">controlSystemDesigner</span><span class="p">(</span><span class="s">&#39;rlocus&#39;</span><span class="p">,</span> <span class="n">P_pitch</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因此打开了控制系统设计器窗口，其中的控制器 $C(s)=K$</p>
<img src="/img/sys_airplane/6.png" alt="描述" style="width: 90%;">
<p>（2）打开左上角&rsquo;编辑架构&rsquo;，可修改回路模型，我们就用最简单的反馈就行</p>
<img src="/img/sys_airplane/7.png" alt="描述" style="width: 90%;">
<p>再回到主页面，在根轨迹编辑器的图中右键，非常隐蔽，不然我赌你肯定找不到， 然后可以调参数（例如调F)(在编辑补偿器里）   ，这里我们在设计需求中新建设计参数的范围</p>
<img src="/img/sys_airplane/8.png" alt="描述" style="width: 40%;">
<p>对各项性能指标提出要求，其中上升时间不能直接调节，只能通过调节固有频率的方式间接改变，其关系如下
$$
w_n \approx \frac{1.8}{T_r}
$$
根据要求新建并调调其他参数</p>
<p>（3）参数调节完毕后，得到下图</p>
<img src="/img/sys_airplane/9.png" alt="描述" style="width: 50%;">
<p>极点位置与瞬态性能有关，不如先把满足要求的参数调好，得到满足要求的区域。上面得到的非阴影区域就是闭环极点的最终所需区域。</p>
<p>换句话讲，以原点为中心的两条射线代表超调要求，射线与负实轴构成的角度越小，则超调量越小。在s=-0.4处有一条垂直线，表示了建立时间的要求，闭环极点越靠近左侧，建立时间就越短。上升时间对应于以原点为中心的圆，其半径就是固有频率的值。</p>
<p>不难看出，开传函的三个分支都没有进入非阴影区，无法通过改变控制器的比例增益K来讲闭环传函极点放在非阴影区，因此考虑尝试用带极点/零点的动态补偿器</p>
<h3 id="超前补偿器">超前补偿器<a hidden class="anchor" aria-hidden="true" href="#超前补偿器">#</a></h3>
<p>(4)要想将根轨迹在复平面上往左移动，采用超前补偿器，传函如下</p>
<p>$$
C(s) = K \frac{s + z}{s + p}
$$
其中零点的幅度小于极点的幅度（$z &lt; p$），即零点在复平面中更加靠近虚轴。</p>
<p>(5)现在开始选择超前补偿器的传递函数</p>
<p>点击右上角预设项</p>
<img src="/img/sys_airplane/10.png" alt="描述" style="width: 60%;">
<p>(6)随后进入编辑器的参数设置，不如把零点放到 $Z=-0.9$  (就是上升时间对应的固有频率所形成的圆的左半面的实轴上)，可以保证随着后面K的增加，零点根轨迹一定在非阴影范围内，并且将极点放在与零点更远的地方 $p=-3$  （下面图应该极点为-3）。跟着下面这个参数添加一个超前零极点并配置好对应数值就行</p>
<img src="/img/sys_airplane/11.png" alt="描述" style="width: 60%;">
<p>(7)随后可以看到新的根轨迹图像，零极点是可以拖动的</p>
<img src="/img/sys_airplane/12.png" alt="描述" style="width: 50%;">
<p>(8)右键属性中可以调节XY范围，现在放大观看右边的零极点情况</p>
<img src="/img/sys_airplane/13.png" alt="描述" style="width: 50%;">
<p>不难看出，零极点的三条线分支在规定范围内，唯独有一个不在范围内，此极点比其他极点慢，但其响应被隔得非常近的那个零点所抵消。环路增益K越大，闭环极点就越靠近闭环零点，闭环极点所产生的影响就越小。最左边的闭环极点对系统的响应程度最小，因为它比其他极点快得多</p>
<p>当前极点位置所得到的环路增益K可以在左下方得出。</p>
<p>(10)现在重新查看闭环阶跃响应曲线图，右键参数设置里可以勾选上升时间、稳定时间等虚线。</p>
<p>我们的K=200，可见所有极点仍在实轴上，也就是没有超调，最终误差e=0，满足设计条件</p>
<img src="/img/sys_airplane/14.png" alt="描述" style="width: 90%;">
<p>(11)总结:</p>
<ul>
<li>至此，采用根轨迹法的控制器设计完毕，从最初的 $C（s）=K$ 不能满足要求，到增加超前环节，到最后调节K值来使闭环极点移动，以使得阶跃响应曲线达到了良好的结果。其实，根轨迹中采用超前补偿器的根本核心就在于在闭环中增加了一项超前补偿器的传函，加入这个环节后可以改变根轨迹，让更稳定的点在根轨迹上。</li>
<li>换句话说，当我们希望闭环的根往左移动（更稳定时），引入超前补偿即可</li>
<li>为什么叫超前补偿器？因为其相角裕度是正的，加入到系统相位上可以使相角增大，就是使系统相位裕度增大，稳定性就大大增强。因为相角超前，叫超前补偿器</li>
</ul>
<h2 id="2频域分析法">2.频域分析法<a hidden class="anchor" aria-hidden="true" href="#2频域分析法">#</a></h2>
<p><strong>频率设计的主要思想是利用开环传递函数的Bode图来估计闭环响应，如果向系统添加控制器，会改变开环伯德图，进而改变闭环输出响应</strong>，频域分析法直观地展示了系统的增益裕度、相位裕度，以及响应速度与稳定性的关系，为后续设计补偿器提供了依据</p>
<p>(1)在之前分析闭环传递函数的时候，已经分析得到有三个极点，一个零点，且闭环系统是稳定的。现在其稳定性再由开环频率响应来确定，采用margin命令来生成伯德图，并注释增益裕度与相位裕度</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 频域分析法 - Bode图与补偿器设计</span>
</span></span><span class="line"><span class="cl"><span class="c">% 定义传递函数</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span> <span class="p">=</span> <span class="n">tf</span><span class="p">(</span><span class="s">&#39;s&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">P_pitch</span> <span class="p">=</span> <span class="p">(</span><span class="mf">1.151</span><span class="o">*</span><span class="n">s</span> <span class="o">+</span> <span class="mf">0.1774</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s</span>^<span class="mi">3</span> <span class="o">+</span> <span class="mf">0.739</span><span class="o">*</span><span class="n">s</span>^<span class="mi">2</span> <span class="o">+</span> <span class="mf">0.921</span><span class="o">*</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 初始开环系统的Bode图与裕度分析</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">margin</span><span class="p">(</span><span class="n">P_pitch</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;开环系统的Bode图 (未补偿)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;频率 (rad/s)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;幅度与相位&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="/img/sys_airplane/15.png" alt="描述" style="width: 70%;">
<p>可见，增益裕度为Inf，相位裕度位46.9，都为正，说明系统稳定（目前的增益裕度是无限的，这表明该系统是稳健的，具有最小的超调，相位裕度为 $46.9^\circ$ 意味着系统有一定的稳定余量，但不能保证快速响应）。所以满足要求？</p>
<p>(2)重新回到上面求得的阶跃响应图</p>
<img src="/img/sys_airplane/4.png" alt="描述" style="width: 70%;">
<p>我们通过分析闭环的阶跃响应发现系统是稳定的，只是稳定时间等等均不满足指标，想加快系统响应，就容易导致过冲问题，因此想再次使用补偿器来重塑开环系统的伯德图（开环系统的伯德图表示了闭环系统的行为）（增益交叉频率与闭环响应速度呈正相关，而相位裕度与过冲成反比），采用一个补偿器来加快增益交叉频率且增加相位裕度。因此也采用<strong>超前补偿器</strong>。其核心目的是优化系统的响应速度和阻尼特性。通过调整零点和极点的位置，它既可以提升增益交叉频率（加快响应速度），又能增加相位裕度（减小过冲）</p>
<h3 id="超前补偿器-1"><strong>超前补偿器</strong><a hidden class="anchor" aria-hidden="true" href="#超前补偿器-1">#</a></h3>
<p>(3)超前补偿器为系统增加了正相位，这样可以增加相位裕度，从而增加阻尼。与此同时，它还可以在高频率下增加开环频率响应的幅度，进而增强增益交叉频率和整体速度（稳定时间降低）。</p>
<p>其传递函数一般形式如下：</p>
<p>$$
C(s) = K \frac{Ts + 1}{\alpha Ts + 1} \quad (\alpha &lt; 1)
$$
(4)通常将K设置为满足稳态误差的要求，而由于系统是Ⅰ型的，因此不管任何K值，阶跃输入的稳态误差都是0。增加K（大于1）也可以弥补速度误差常数太小所导致的响应慢尾。换句话说，增大K值会使幅度图往上移动。经选择后，令K=10</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% 设置增益K并观察频域响应</span>
</span></span><span class="line"><span class="cl"><span class="n">K</span> <span class="p">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c">% 增益设置</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">margin</span><span class="p">(</span><span class="n">K</span> <span class="o">*</span> <span class="n">P_pitch</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;加增益后的Bode图 (K=10)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;频率 &#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;幅度与相位&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="/img/sys_airplane/16.png" alt="描述" style="width: 70%;">
<p>可见，我们增加了系统的幅度，并且提高了增益交叉频率，可得出的是随着K的增加，相位裕度也减小了，意味着超调量增加了，这是我们不希望的，但超前补偿器是可以增加系统的阻尼的，也就是说有办法来减小超调量</p>
<p>(5) 于是继续寻找 $\alpha$，其定义为零点与极点的比值。零点与极点间隔距离越大，相位的凸点就越大，其中单个零极对可以最大增加相位为 $90^\circ$。最大相位与 $\alpha$ 的关系如下：</p>
<p>$$
\sin(\phi_m) = \frac{1 - \alpha}{1 + \alpha}
$$
同时我们也知道标准欠阻尼二阶系统的时间响应与频率响应之间的关系</p>
<p>$$
\zeta \approx \frac{PM(\text{degrees})}{100^\circ}
$$
通常阻尼比 $\zeta$ 近似小于 $0.6$ 或 $0.7$。</p>
<p>(6) 尽管之前的系统并不是标准的二阶系统，但仍可以用以上关系进行设计。由于超调量要求小于 $10%$，也就是说，阻尼比 $\zeta$ 要大于 $0.59$（关系图可以在网上找到），因此相位裕度需要大于 $59^\circ$。根据超调量与阻尼比的关系，可以先从目标超调量反推出阻尼比，再通过近似公式计算所需的相位裕度</p>
<p>当前相位裕度为 $10.4^\circ$，因此再增加 $50^\circ$ 就足够了。由于超前补偿器会额外增加频率响应的幅度，因此需要添加超过 $50^\circ$ 的相位超前。最终我们选定 $55^\circ$ 的相位超前为目标。</p>
<p>(7)然后计算α</p>
<p>$$
\alpha = \frac{1 - \sin(55^\circ)}{1 + \sin(55^\circ)} \approx 0.10
$$
(8)因此α必须小于0.1，再根据下面关系式计算出超前补偿器所造成的幅度增加量</p>
<p>$$
20 \log\left(\frac{1}{\sqrt{\alpha}}\right) \approx 20 \log\left(\frac{1}{\sqrt{0.10}}\right) \approx 10 , \text{dB}
$$
(9) 在之前的图中可以看出，穿过幅值 $= 0$ 那条线的交叉频率 $\omega_c = 3.49$，穿过幅值 $= -10 , \text{dB}$ 的频率为 $6.1 , \text{rad/dec}$。由此不难想到，加入超前补偿器的 $\alpha$ 后，其交叉频率会变为 $6.1$。然后我们再利用这个新交叉频率值来计算 $T$，目的是使最大相位裕量增加到最大。因为参数 $\alpha$ 控制了零点和极点之间的距离，从而决定了补偿器的相位峰值大小以及频率范围。</p>
<p>$$
\omega_m = \frac{1}{T \sqrt{\alpha}} \implies T = \frac{1}{6.1 \sqrt{0.10}} \approx 0.52
$$
(10) 由此，超前补偿器的三个变量值全部得到：$K = 10$, $\alpha = 0.1$, $T = 0.52$。将这些值通过编程应用于开环传递函数，观察超前补偿器对系统频率响应的影响。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">% 定义超前补偿器参数
</span></span><span class="line"><span class="cl">alpha = 0.1;  % 零点与极点的比值
</span></span><span class="line"><span class="cl">T = 0.52;      % 时间常数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">% 超前补偿器传递函数
</span></span><span class="line"><span class="cl">C_lead = K * (T*s + 1) / (alpha*T*s + 1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">% 补偿后的开环传递函数
</span></span><span class="line"><span class="cl">P_lead = C_lead * P_pitch;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">% 绘制补偿后的Bode图
</span></span><span class="line"><span class="cl">figure;
</span></span><span class="line"><span class="cl">margin(P_lead);
</span></span><span class="line"><span class="cl">grid on;
</span></span><span class="line"><span class="cl">title(&#39;加入超前补偿器后的Bode图&#39;);
</span></span><span class="line"><span class="cl">xlabel(&#39;频率 &#39;);
</span></span><span class="line"><span class="cl">ylabel(&#39;幅度与相位&#39;);
</span></span></code></pre></td></tr></table>
</div>
</div><img src="/img/sys_airplane/17.png" alt="描述" style="width: 70%;">
<p>可见相位裕度和交叉频率都提高了</p>
<p>(11)接下来再看闭环阶跃响应</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% 补偿后的闭环系统</span>
</span></span><span class="line"><span class="cl"><span class="n">sys_cl_lead</span> <span class="p">=</span> <span class="n">feedback</span><span class="p">(</span><span class="n">P_lead</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 绘制闭环阶跃响应</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">step</span><span class="p">(</span><span class="n">sys_cl_lead</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mf">0.01</span><span class="p">:</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;超前补偿器设计的闭环阶跃响应&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;俯仰角 (度)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;时间 (秒)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 获取闭环系统的性能指标</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="s">&#39;超前补偿器设计后的闭环系统性能:&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="/img/sys_airplane/18.png" alt="描述" style="width: 70%;">
<p>从图上很难细致的看出超调量等参数，因此采用stepinfo命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">stepinfo</span><span class="p">(</span><span class="n">sys_cl_lead</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>(12) 得到参数后，计算发现超调量还是略大了一些，此时重新调整取 $\alpha = 0.04$，结果改善了许多：</p>
<div>
    上升时间: \(0.2074\)<br>
    过渡时间: \(8.9835\)<br>
    SettlingTime: \(8.9835\)<br>
    SettlingMin: \(0.9004\)<br>
    SettlingMax: \(1.1198\)<br>
    Overshoot: \(11.9792\%\)<br>
    Undershoot: \(0\)<br>
    峰值: \(1.1198\)<br>
    峰值时间: \(0.4886\)
</div>
<p>(13) 综上，超前补偿器设置完毕（$\alpha = 0.04$）</p>
<p>超前补偿器的传递函数为：
$$
C(s) = 10 \frac{0.55s + 1}{0.022s + 1}
$$</p>
<p>总结：</p>
<ul>
<li>原闭环系统稳定，但一定不满足要求的调节，通过频域分析确定初始系统的缺陷后，利用超前补偿器增加相位裕度和增益交叉频率，从而优化了响应速度和稳定性。这种设计方法强调频域与时域性能的结合，通过不断调整 $\alpha$ 和 $T$ 实现精确的动态控制。换句话说频率分析法也只是看看它稳不稳定罢了，至于要让他满足要求，还得是设计各种前馈器，让他的整体传递函数变化，从而改变伯德图里的相位裕度以及交叉频率，增加相位裕度可以提高阻尼系数，增加交叉频率可以减小稳定时间。单独的增加K可以增加交叉频率，但有缺陷，因此又引入了α与T来调节相位裕度与超调量。</li>
<li>比较难的地方在于α的选择，选α一定就要先找要增加多少相位？也就是目标相位-原始相位（带K），目标相位怎么找？用超调量找阻尼比再找相位（图标关系），于是可以得出，根据要求的超调量就可以找到α，其T值水到渠成的就得到了，因此整个超前补偿器就设计完毕了。但仍需要不断观察伯德图与输出响应曲线来对比不同之处，并判断是否的确满足系统要求。</li>
</ul>
<h2 id="3状态空间法">3.状态空间法<a hidden class="anchor" aria-hidden="true" href="#3状态空间法">#</a></h2>
<p>（1）前面已经得到过状态空间形式的动力学方程</p>
<div>
$$
\begin{bmatrix}
\dot{\alpha} \\
\dot{q} \\
\dot{\theta}
\end{bmatrix}
=
\begin{bmatrix}
-0.313 & 56.7 & 0 \\
-0.0139 & -0.426 & 0 \\
0 & 56.7 & 0
\end{bmatrix}
\begin{bmatrix}
\alpha \\
q \\
\theta
\end{bmatrix}
+
\begin{bmatrix}
0.232 \\
0.0203 \\
0
\end{bmatrix}
\begin{bmatrix}
\delta
\end{bmatrix}
$$
</div>
<div>
$$
y = 
\begin{bmatrix}
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
\alpha \\
q \\
\theta
\end{bmatrix}
+ \begin{bmatrix}
0
\end{bmatrix}
\begin{bmatrix}
\delta
\end{bmatrix}
$$
</div>
<p>上面等式与一般的线性状态空间形式匹配
$$
\frac{dx}{dt} = A x + B u
$$</p>
<p>$$
y = C x + D u
$$</p>
<p>（2）因此将采用状态空间控制器来设计系统，来放置闭环极点</p>
<p>要想设计状态空间控制器，首先要看能控性能观性。能控性对应了我们可以将闭环极点放置在s平面的任意位置，给出能控性矩阵</p>
<p>$$
C = [B , AB , A^2B , \dots , A^{n-1}B]
$$
（3） 其中 $n$ 对应状态变量的数量。由于我们的矩阵为 $3 \times 3$，因此矩阵的秩 $\text{rank}$ 也必须为 $3$（满秩）。为了验证这一点，可以使用命令来查看矩阵的秩。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 连续状态空间法 - 能控性与极点布置</span>
</span></span><span class="line"><span class="cl"><span class="c">% 定义连续状态空间模型</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="p">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.313</span> <span class="mf">56.7</span> <span class="mi">0</span><span class="p">;</span> <span class="o">-</span><span class="mf">0.0139</span> <span class="o">-</span><span class="mf">0.426</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mf">56.7</span> <span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span> <span class="p">=</span> <span class="p">[</span><span class="mf">0.232</span><span class="p">;</span> <span class="mf">0.0203</span><span class="p">;</span> <span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">D</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 检查系统能控性</span>
</span></span><span class="line"><span class="cl"><span class="n">co</span> <span class="p">=</span> <span class="n">ctrb</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span> <span class="c">% 能控性矩阵</span>
</span></span><span class="line"><span class="cl"><span class="n">Controllability</span> <span class="p">=</span> <span class="n">rank</span><span class="p">(</span><span class="n">co</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">([</span><span class="s">&#39;连续系统能控性: Rank = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">Controllability</span><span class="p">)]);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中co为：
$$
C_o = \text{ctrb}(A, B) , \text{returns the controllability matrix:}
$$</p>
<p>$$
C_o = [B , AB , A^2B , \dots , A^{n-1}B]
$$</p>
<p>得到结果连续系统能控性: Rank = 3，证明矩阵满秩，完全可控。能观性略</p>
<h3 id="通过极点布置来进行控制设计"><strong>通过极点布置来进行控制设计</strong><a hidden class="anchor" aria-hidden="true" href="#通过极点布置来进行控制设计">#</a></h3>
<p>（4）全状态反馈控制系统原理图如下（ABC就是表达式里的值，这里D=0）</p>
<img src="/img/sys_airplane/19.png" alt="描述" style="width: 70%;">
<p>其中 $K$ 为增益矩阵，$\mathbf{x} = [\alpha, q, \theta]^\top$ 为状态向量，$\theta_{\text{des}}$ 为参考信号 ($r$)，$\delta = \theta_{\text{des}} - K\mathbf{x}$ 为控制输入 ($u$)，$\theta$ 为输出 ($y$)</p>
<p>(5) 由于新的 $\delta = \theta_{\text{des}} - K\mathbf{x}$，将其代入到原状态方程中，得到新状态方程如下：</p>
<p>$$
\dot{\mathbf{x}} = (A - BK)\mathbf{x} + B\theta_{\text{des}}
$$</p>
<p>$$
\theta = C\mathbf{x}
$$</p>
<p>因此，矩阵 $A - BK$ 确定了系统的闭环动力学，其行列式 $\det(sI - (A - BK))$ 的根是系统的闭环极点。由于该行列式是三阶的，因此可以任意放置的极点数量为三个。再加上系统是完全能控的，因此极点的位置可以随意配置。</p>
<p>控制系统的性能主要取决于系统的极点在根平面上的分布。可以按照设计意图调整的参数是反馈增益矩阵 $K$。经典控制理论中的根轨迹法就是一种极点配置方法，其核心目标是通过各种手段重新配置开环系统的极点与零点。</p>
<p>需要注意的是，此反馈定律假定矢量 $\mathbf{x}$ 中的所有状态变量均已被测量，否则需要设计一个观察器来估计状态变量。</p>
<p>注意：实际上并不是只有这一种新的状态方程，也可以引入一个状态观测器G，然后以C来算，不过很麻烦。举例如下</p>
<p><strong>状态观测器公式：</strong>
$$
\dot{\hat{X}} = (A - GC)\hat{X} + GY + Bu
$$</p>
<p>$$
Y = C\hat{X}
$$</p>
<p><strong>反馈控制率公式：</strong>
$$
u = KX + v
$$
<strong>根据系统性能指标的公式：</strong></p>
<p>超调量：</p>
<div>
$$
\sigma\% = e^{-\frac{\pi \zeta}{\sqrt{1 - \zeta^2}}}
$$
</div>
<p>调整时间：</p>
<p>$$
t_s = \frac{4}{\zeta \omega_n}
$$
<strong>系统闭环特征方程：</strong>
$$
s^2 - 8440.0565K_d s - 8440.0565K_p - 956.0587 = 0
$$
阻尼比：</p>
<p>$$
\zeta = \frac{-8440.0565K_d}{2\sqrt{-8440.0565K_p - 956.0587}}
$$
自然频率：</p>
<p>$$
\omega_n = \sqrt{-8440.0565K_p - 956.0587}
$$
超调量：</p>
<div>
$$
\sigma\% = e^{-\frac{\pi \zeta}{\sqrt{1 - \zeta^2}}}
$$
</div>
<p>调整时间：</p>
<p>$$
t_s = \frac{4}{\zeta \omega_n}
$$
（6）因此有三个可以任意放置位置的极点，可问题是放在哪里？如果有标准的一阶或者二阶系统，那么极点的位置与阶跃响应的特性有直接的关系，利用这些关系可以得到极点的位置。但是如果是高阶系统，可以将高阶极点放置在复平面中比主导极点偏左 5-10 倍的位置（由于太左，对瞬态响应的影响就忽略不计了）。但是这样也有两点局限性：</p>
<ul>
<li>其一是难以解决零点的问题；</li>
<li>其二是工作量可能大。</li>
</ul>
<p>由此可见，这种放置极点的方法不行。</p>
<p>（7）因此，为了得到反馈增益矩阵 $K$，将使用 LQR（线性二次调节器）来生成最佳增益矩阵 $K$。这样就不必计算要将极点放在哪个特定位置。若要使用 LQR，需要定义两个参数：状态成本加权矩阵 $Q$ 和控制权重矩阵 $R$。为图简单，选择 $R = 1$，$Q = p C^\top C$。在这种情况下，$\theta$ 是输出中唯一的状态变量，而加权因子 $p$ 将被更新以修改阶跃响应。对于 $R$，由于只有一个输入，因此它是标量。</p>
<p>（8）LQR 参数全了，接下来得到反馈控制矩阵 $K$，先令加权因子 $p = 2$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% 定义LQR权重矩阵</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span> <span class="p">=</span> <span class="mi">50</span><span class="p">;</span> <span class="c">% 状态加权因子</span>
</span></span><span class="line"><span class="cl"><span class="n">Q</span> <span class="p">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">C</span><span class="o">&#39;</span> <span class="o">*</span> <span class="n">C</span><span class="p">;</span> <span class="c">% 状态成本加权矩阵</span>
</span></span><span class="line"><span class="cl"><span class="n">R</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>          <span class="c">% 控制权重矩阵</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 求解状态反馈增益矩阵K</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="p">=</span> <span class="n">lqr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="s">&#39;LQR设计的反馈增益矩阵K:&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div>
$$
Q =
\begin{bmatrix}
0 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 2
\end{bmatrix}
$$
</div>
<p>$$
K =
\begin{bmatrix}
-0.5034 &amp; 52.8645 &amp; 1.4142
\end{bmatrix}
$$</p>
<p>（9）接下来根据新状态方程来生成闭环阶跃响应曲线图</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% 构造闭环系统</span>
</span></span><span class="line"><span class="cl"><span class="n">sys_cl</span> <span class="p">=</span> <span class="n">ss</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">K</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">step</span><span class="p">(</span><span class="n">sys_cl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;连续状态空间下的LQR闭环阶跃响应&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;时间 (秒)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;俯仰角 (度)&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="/img/sys_airplane/20.png" alt="描述" style="width: 70%;">
<p>（10）明显可见，响应太慢，可以通过调整LQR来优化，具体的讲，就是增加加权因子 $p$ 来完成，现在将 $p=50$</p>
<p>得到
$$
K =
\begin{bmatrix}
-0.6435 &amp; 169.6950 &amp; 7.0711
\end{bmatrix}
$$
<img src="/img/sys_airplane/21.png" alt="描述" style="width: 70%;"></p>
<p>（11）比较不错，美中不足是和我们预设的阶跃信号1相差有点大，有没有办法让他最终稳定在1附近？此时LQR无能为力了，需要引入预补偿器 $N(-)$</p>
<h3 id="添加预补偿器"><strong>添加预补偿器</strong><a hidden class="anchor" aria-hidden="true" href="#添加预补偿器">#</a></h3>
<p>注意，一直使用的全状态反馈系统并不是将输出值与参考输入值直接相比较，而是有个反馈矩阵K。因此为了获得所需要的输出可以缩放参考输入，使其输出在稳定时等于输入。加入预补偿器。</p>
<p>(12)因此得到了带有预补偿器的比例因子的状态反馈系统</p>
<img src="/img/sys_airplane/22.png" alt="描述" style="width: 80%;">
<p>(13) 其中的比例因子 $N$ （-）需要在用户定义函数（官方 <code>help</code> 文档中）<code>rscale.m</code> 中计算得到。该函数用于查找比例因子以消除稳态误差。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 连续状态空间法 - 添加预补偿器</span>
</span></span><span class="line"><span class="cl"><span class="c">% 计算预补偿器Nbar</span>
</span></span><span class="line"><span class="cl"><span class="n">Nbar</span> <span class="p">=</span> <span class="n">rscale</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span> <span class="c">% 官方函数 rscale.m</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">([</span><span class="s">&#39;预补偿器比例因子Nbar = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">Nbar</span><span class="p">)]);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面给出具体的函数代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">function</span><span class="w"> </span>Nbar <span class="p">=</span><span class="w"> </span><span class="nf">rscale</span><span class="p">(</span>A, B, C, D, K<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c">% RSCALE calculates the scale factor Nbar to ensure zero steady-state error.</span>
</span></span><span class="line"><span class="cl">    <span class="c">% Nbar adjusts the input to match the desired output.</span>
</span></span><span class="line"><span class="cl">    <span class="c">% </span>
</span></span><span class="line"><span class="cl">    <span class="c">% Usage:</span>
</span></span><span class="line"><span class="cl">    <span class="c">% Nbar = rscale(A, B, C, D, K)</span>
</span></span><span class="line"><span class="cl">    <span class="c">%</span>
</span></span><span class="line"><span class="cl">    <span class="c">% Inputs:</span>
</span></span><span class="line"><span class="cl">    <span class="c">%   A, B, C, D - State-space matrices</span>
</span></span><span class="line"><span class="cl">    <span class="c">%   K          - State feedback gain</span>
</span></span><span class="line"><span class="cl">    <span class="c">%</span>
</span></span><span class="line"><span class="cl">    <span class="c">% Output:</span>
</span></span><span class="line"><span class="cl">    <span class="c">%   Nbar       - Input scaling factor</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">% Error check</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">nargin</span> <span class="o">&lt;</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">        <span class="n">error</span><span class="p">(</span><span class="s">&#39;Usage: Nbar = rscale(A, B, C, D, K)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">% Compute system size</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">% Form augmented system matrix</span>
</span></span><span class="line"><span class="cl">    <span class="n">A_cl</span> <span class="p">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">K</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">I</span> <span class="p">=</span> <span class="nb">eye</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">A</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">% Compute Nbar using the formula</span>
</span></span><span class="line"><span class="cl">    <span class="n">Nbar</span> <span class="p">=</span> <span class="o">-</span><span class="n">inv</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="n">inv</span><span class="p">(</span><span class="n">A_cl</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="n">D</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="/img/sys_airplane/23.png" alt="描述" style="width: 70%;">
<p>现在系统已经稳定在 $1$ 附近，设计要求达到了。</p>
<p>(14) 注意：</p>
<ul>
<li>
<p>添加的预补偿器 $N$ （-）并不位于反馈回路中，这意味着如果存在未知干扰，预补偿器无法消除这部分偏差。换句话说，预补偿器的作用仅是对输入进行放大或缩小。例如，在此设计中，将输入放大了 $7$ 倍，从而使输出从原来的 $0.14$ 变为我们设定的 $1$（仅是振幅提高）。但从本质上说，稳态误差并未真正被消除。可以观察图中输出并未完全稳定在 $1$，原因在于 $N$ 不在反馈回路内，因此无法真正改变输出的波形，也不能有效减少稳态误差。</p>
</li>
<li>
<p>一种改进的方法是将预补偿器与积分控制相结合。这样不仅可以缩放输出波形，同时还能在一定程度上减小稳态误差。</p>
</li>
</ul>
<h2 id="4离散状态空间法-数字控制器设计法">4.离散状态空间法-数字控制器设计法<a hidden class="anchor" aria-hidden="true" href="#4离散状态空间法-数字控制器设计法">#</a></h2>
<p>(1)原连续时间状态方程如下，还是利用这个状态方程，但是现在想要得到新的离散时间状态空间方程</p>
<div>
$$
\begin{bmatrix}
\dot{\alpha} \\
\dot{q} \\
\dot{\theta}
\end{bmatrix}
=
\begin{bmatrix}
-0.313 & 56.7 & 0 \\
-0.0139 & -0.426 & 0 \\
0 & 56.7 & 0
\end{bmatrix}
\begin{bmatrix}
\alpha \\
q \\
\theta
\end{bmatrix}
+
\begin{bmatrix}
0.232 \\
0.0203 \\
0
\end{bmatrix}
\begin{bmatrix}
\delta
\end{bmatrix}
$$
</div>
<div>
$$
y = 
\begin{bmatrix}
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
\alpha \\
q \\
\theta
\end{bmatrix}
+ 
\begin{bmatrix}
0
\end{bmatrix}
\begin{bmatrix}
\delta
\end{bmatrix}
$$
</div>
<h3 id="离散状态空间">离散状态空间<a hidden class="anchor" aria-hidden="true" href="#离散状态空间">#</a></h3>
<p>(2) 要想设计数字控制系统，第一步必须使用 <code>c2d</code> 命令生成系统的采样数据模型（用编程从连续时间模型得到此模型）。而 <code>c2d</code> 命令需要三个参数：系统模型 + 采样时间 + 保持电路的类型。本实例中加入的是一个零阶保持电路（zoh）。</p>
<p>为了选择采样时间（防止漏信号），将采样频率与系统动态相比较，通常来讲，采样频率至少比闭环波特图的带宽频率大 30 倍。（带宽频率也称为闭环截止频率，是指当闭环幅频特性下降到频率为零时的分贝值以下 3 dB 时，对应的频率）</p>
<p>（额外补充：开环截止频率也称为剪切频率，是 <strong>开环幅频特性</strong> 中，幅频特性曲线穿越 0 dB 线的频率，记为 $\omega_c$；闭环截止频率也称为带宽频率，是指当 <strong>闭环幅频特性曲线</strong> 下降到 <strong>-3 dB</strong> 时，对应的频率，记作 $\omega_b$。开环 bode 图 ≠ 闭环 bode 图）</p>
<p>根据闭环波特图可得，带宽频率为 $2 , \text{rad/sec}$，因此得到 $0.01 , \text{s}$ 的采样时间。</p>
<p>(3)使用c2d函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 离散状态空间法 - 离散化与能控性检查</span>
</span></span><span class="line"><span class="cl"><span class="c">% 将连续系统离散化</span>
</span></span><span class="line"><span class="cl"><span class="n">Ts</span> <span class="p">=</span> <span class="mf">0.01</span><span class="p">;</span> <span class="c">% 采样时间 (秒)</span>
</span></span><span class="line"><span class="cl"><span class="n">sys_d</span> <span class="p">=</span> <span class="n">c2d</span><span class="p">(</span><span class="n">ss</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">),</span> <span class="n">Ts</span><span class="p">,</span> <span class="s">&#39;zoh&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>(4)因此就得到了离散时间状态空间模型</p>
<div>
$$
\begin{bmatrix}
\alpha(k+1) \\
q(k+1) \\
\theta(k+1)
\end{bmatrix}
=
\begin{bmatrix}
0.9969 & 0.05649 & 0 \\
-0.0001 & 0.9957 & 0 \\
0 & 0.5658 & 1
\end{bmatrix}
\begin{bmatrix}
\alpha(k) \\
q(k) \\
\theta(k)
\end{bmatrix}
+
\begin{bmatrix}
0.0024 \\
0.0002 \\
0.0001
\end{bmatrix}
\begin{bmatrix}
\delta(k)
\end{bmatrix}
$$
</div>
<div>
$$
y(k) = 
\begin{bmatrix}
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
\alpha(k) \\
q(k) \\
\theta(k)
\end{bmatrix}
+ 
\begin{bmatrix}
0
\end{bmatrix}
\begin{bmatrix}
\delta(k)
\end{bmatrix}
$$
</div>
<h3 id="能控性">能控性<a hidden class="anchor" aria-hidden="true" href="#能控性">#</a></h3>
<p>(5)与连续一样，必须验证离散系统可控性，依旧是算秩，方法同之前连续系统。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% 检查离散系统能控性</span>
</span></span><span class="line"><span class="cl"><span class="n">co_d</span> <span class="p">=</span> <span class="n">ctrb</span><span class="p">(</span><span class="n">sys_d</span><span class="p">.</span><span class="n">A</span><span class="p">,</span> <span class="n">sys_d</span><span class="p">.</span><span class="n">B</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Controllability_d</span> <span class="p">=</span> <span class="n">rank</span><span class="p">(</span><span class="n">co_d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">([</span><span class="s">&#39;离散系统能控性: Rank = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">Controllability_d</span><span class="p">)]);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>离散系统能控性:  $Rank = 3$</p>
<h3 id="极点布置进行控制设计">极点布置进行控制设计<a hidden class="anchor" aria-hidden="true" href="#极点布置进行控制设计">#</a></h3>
<p>(6)和连续状态空间步骤一样，不过这次是离散全状态反馈控制系统</p>
<p>其中 $q^-1$是延迟算子，依旧假设 $D=0$</p>
<p>(7)同理得到矩阵</p>
<p>$$
\mathbf{x}(k+1) = (A - BK)\mathbf{x}(k) + B\theta_{\text{des}}(k)
$$</p>
<p>$$
\theta(k) = C\mathbf{x}(k)
$$</p>
<p>(8)同理使用 $LQR$ 来找 $K$，不过是 $LQR$ 方法的离散版本</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% LQR离散版本</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span> <span class="p">=</span> <span class="mi">50</span><span class="p">;</span> <span class="c">% 状态加权因子</span>
</span></span><span class="line"><span class="cl"><span class="n">Q_d</span> <span class="p">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">sys_d</span><span class="p">.</span><span class="n">C</span><span class="o">&#39;</span> <span class="o">*</span> <span class="n">sys_d</span><span class="p">.</span><span class="n">C</span><span class="p">;</span> <span class="c">% 离散状态成本加权矩阵</span>
</span></span><span class="line"><span class="cl"><span class="n">R_d</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>                     <span class="c">% 控制权重矩阵</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 求解离散状态反馈增益矩阵K</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">K_d</span><span class="p">]</span> <span class="p">=</span> <span class="n">dlqr</span><span class="p">(</span><span class="n">sys_d</span><span class="p">.</span><span class="n">A</span><span class="p">,</span> <span class="n">sys_d</span><span class="p">.</span><span class="n">B</span><span class="p">,</span> <span class="n">Q_d</span><span class="p">,</span> <span class="n">R_d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="s">&#39;离散LQR设计的反馈增益矩阵K:&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">(</span><span class="n">K_d</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
K =
\begin{bmatrix}
-0.6436 &amp; 168.3611 &amp; 6.9555
\end{bmatrix}
$$</p>
<p>(9) $K$ 有了$A-BK$ 就有了，离散状态方程所有量就都有了，直接看输出波形</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% 构造离散闭环系统</span>
</span></span><span class="line"><span class="cl"><span class="n">sys_cl_d</span> <span class="p">=</span> <span class="n">ss</span><span class="p">(</span><span class="n">sys_d</span><span class="p">.</span><span class="n">A</span> <span class="o">-</span> <span class="n">sys_d</span><span class="p">.</span><span class="n">B</span> <span class="o">*</span> <span class="n">K_d</span><span class="p">,</span> <span class="n">sys_d</span><span class="p">.</span><span class="n">B</span><span class="p">,</span> <span class="n">sys_d</span><span class="p">.</span><span class="n">C</span><span class="p">,</span> <span class="n">sys_d</span><span class="p">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Ts</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">time</span> <span class="p">=</span> <span class="mi">0</span><span class="p">:</span><span class="n">Ts</span><span class="p">:</span><span class="mi">10</span><span class="p">;</span> <span class="c">% 仿真时间</span>
</span></span><span class="line"><span class="cl"><span class="n">theta_des</span> <span class="p">=</span> <span class="nb">ones</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">time</span><span class="p">));</span> <span class="c">% 阶跃输入</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="p">=</span> <span class="n">lsim</span><span class="p">(</span><span class="n">sys_cl_d</span><span class="p">,</span> <span class="n">theta_des</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 绘制离散闭环系统的响应</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">stairs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;离散LQR下的闭环阶跃响应&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;时间 (秒)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;俯仰角 (度)&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="/img/sys_airplane/24.png" alt="描述" style="width: 70%;">
<p>依旧还是离1差老远。</p>
<h3 id="预补偿器">预补偿器<a hidden class="anchor" aria-hidden="true" href="#预补偿器">#</a></h3>
<p>(10) 与连续不同的是，Nbar不能通过函数文件来自动算得了，因此只能手动调调改改。最后选定N=6.95</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 离散状态空间法 - 添加预补偿器</span>
</span></span><span class="line"><span class="cl"><span class="c">% 手动调整预补偿器比例因子</span>
</span></span><span class="line"><span class="cl"><span class="n">Nbar_d</span> <span class="p">=</span> <span class="mf">6.95</span><span class="p">;</span> <span class="c">% 根据仿真调整的比例因子</span>
</span></span><span class="line"><span class="cl"><span class="nb">disp</span><span class="p">([</span><span class="s">&#39;离散系统预补偿器比例因子Nbar = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">Nbar_d</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 构造加入预补偿器后的离散闭环系统</span>
</span></span><span class="line"><span class="cl"><span class="n">sys_cl_comp_d</span> <span class="p">=</span> <span class="n">ss</span><span class="p">(</span><span class="n">sys_d</span><span class="p">.</span><span class="n">A</span> <span class="o">-</span> <span class="n">sys_d</span><span class="p">.</span><span class="n">B</span> <span class="o">*</span> <span class="n">K_d</span><span class="p">,</span> <span class="n">sys_d</span><span class="p">.</span><span class="n">B</span> <span class="o">*</span> <span class="n">Nbar_d</span><span class="p">,</span> <span class="n">sys_d</span><span class="p">.</span><span class="n">C</span><span class="p">,</span> <span class="n">sys_d</span><span class="p">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Ts</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">y_comp</span><span class="p">,</span> <span class="n">t_comp</span><span class="p">]</span> <span class="p">=</span> <span class="n">lsim</span><span class="p">(</span><span class="n">sys_cl_comp_d</span><span class="p">,</span> <span class="n">theta_des</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 绘制加入预补偿器后的离散闭环响应</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">stairs</span><span class="p">(</span><span class="n">t_comp</span><span class="p">,</span> <span class="n">y_comp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;加入预补偿器后的离散LQR闭环阶跃响应&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;时间 (秒)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;俯仰角 (度)&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="/img/sys_airplane/25.png" alt="描述" style="width: 70%;">
<p>设计成功</p>
<h2 id="5pid法不带脑子法">5.PID法（不带脑子法）<a hidden class="anchor" aria-hidden="true" href="#5pid法不带脑子法">#</a></h2>
<p>PID的传函如下
$$
C(s) = K_p + \frac{K_i}{s} + K_d s = \frac{K_d s^2 + K_p s + K_i}{s}
$$</p>
<p>我认为再多解释一个字都是对这个方法的不尊重</p>
<h2 id="6利用simulink建立状况空间模型法">6.利用simulink建立状况空间模型法<a hidden class="anchor" aria-hidden="true" href="#6利用simulink建立状况空间模型法">#</a></h2>
<h3 id="lqr">LQR<a hidden class="anchor" aria-hidden="true" href="#lqr">#</a></h3>
<p>初步构建模型</p>
<img src="/img/sys_airplane/26.png" alt="描述" style="width: 80%;">
<p>状态空间参数如下</p>
<img src="/img/sys_airplane/28.png" alt="描述" style="width: 50%;">
<p>注：$C$ 矩阵必须为 $3 \times 3$ 的矩阵，而不是原方程中的 $[0 , 0 , 1]$。这意味着 $C$ 矩阵的维度必须与矩阵 $A$ 保持一致。可以使用 <code>eye(3)</code> 生成 $3 \times 3$ 的单位矩阵。</p>
<p>在这种情况下，不仅将 $\theta$ 视为输出，还将 $\alpha$ 和 $q$ 一起算作输出。因此，输出包含三条线，但实际上只有 $\theta$ 的波形是需要重点关注的，其他两条可以忽略。</p>
<p>运行后，得到了开环阶跃响应（原始状态空间方程下）的输出波形</p>
<img src="/img/sys_airplane/29.png" alt="描述" style="width: 70%;">
<p>可见系统不稳定。参照以前的做法，我们将引入全状态反馈控制系统，这会将系统的状态矩阵变为 $A - BK$。接下来需要确定增益矩阵 $K$，这里利用 LQR 方法求解。为了提升稳态值，还引入了预补偿器。Simulink 模型中依旧按照这一流程进行。</p>
<p>通过代码计算，得到反馈增益矩阵：
$$
K = [-0.6435, 169.6950, 7.0711]
$$
将 $K$ 加入系统后，全状态反馈控制系统就构成了。</p>
<img src="/img/sys_airplane/30.png" alt="描述" style="width: 80%;">
<h3 id="预补偿器-1">预补偿器<a hidden class="anchor" aria-hidden="true" href="#预补偿器-1">#</a></h3>
<p>接下来加入预补偿器。由于上面计算得出 $N(-) = 7.0711$，因此只需在系统中增加一个增益块，将输入乘以 $N$ 即可实现预补偿。</p>
<img src="/img/sys_airplane/31.png" alt="描述" style="width: 80%;">
<p>观察θ输出波形已经稳定了，但是差点火候。特别是如果再添加一个扰动，那完蛋了，因为LQR的设计中并没有考虑到模型不确定性的鲁棒性，这也就是为什么LQR渐渐被PID淘汰，后面可以用PID来控制状态空间方程.</p>
<h3 id="pid">PID<a hidden class="anchor" aria-hidden="true" href="#pid">#</a></h3>
<img src="/img/sys_airplane/33.png" alt="描述" style="width: 80%;">
<img src="/img/sys_airplane/38.png" alt="描述" style="width: 60%;">
<img src="/img/sys_airplane/37.png" alt="描述" style="width: 70%;">
<ul>
<li>
<p>其中的滤波器系数 $N$ 定义了微分项上一阶低通滤波器的时间常数，用于平滑微分信号，减少噪声对控制系统的影响。</p>
</li>
<li>
<p>可以在 PID 控制块的 <code>Limit Output</code> 中设置控制器输出的饱和上下限。例如，对于飞机的升降角度，其范围很可能被限制在 $-25^\circ$ 到 $+25^\circ$。加入饱和限制可以防止控制信号超出此范围，并用于自动调节 PID 参数以避免失控。</p>
</li>
<li>
<p>但是，这样的设计也会引入积分饱和问题：当输出已经达到饱和限制时，积分器仍然继续工作，导致系统响应变得缓慢。为了解决这一问题，PID 控制块中提供了积分器抗饱和策略（在 <code>PID Advanced</code> 选项中选择 <code>Anti-windup method</code>）。这个模块会在积分饱和时立刻停止积分器的工作，而当输出恢复到非饱和状态时重新启用积分器。</p>
</li>
</ul>
<div
    class="alert alert-info"    role="alert"><text><p><strong>版权说明</strong></p>
<p>​	本内容框架和主题是基于 <a href="http://218.75.197.120:6900/218_project/home.html">湖南工业大学控制实验室</a> 所发布的教学内容的整理和进一步解释，仅供个人学习及复习回顾使用，我只是一个快乐的调包侠</p>
</text></div>



  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://zehua.eu/zh/posts/probability_cn/%E5%90%84%E7%B1%BB%E6%8E%A7%E5%88%B6%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/">
    <span class="title">« 上一页</span>
    <br>
    <span>各类控制方法实现思路及代码</span>
  </a>
</nav>

  </footer>
</article>

<div class="post-password"></div>
  
</div>
    </main>
    
<footer class="footer">
        <span><a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod</a></span> · 


    <span>
        
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a>  
        
    </span>
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <br>
    <span id="busuanzi_container_page_pv" style='display:none'>
        一共有<span id="busuanzi_value_page_pv"></span>人来过这里
    </span>
    · <span id="last_change">
        最后更新于2024年11月25日
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
