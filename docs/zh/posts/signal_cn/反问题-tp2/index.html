<!DOCTYPE html>
<html lang="zh" dir="ltr">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>反问题 TP2 | 主页</title>
<meta name="keywords" content="信号处理, 统计分析, 反问题, 贝叶斯方法">
<meta name="description" content="第二次实验内容">
<meta name="author" content="Zehua">
<link rel="canonical" href="http://zehua.eu/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98-tp2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.ee21873c327aa7fc241123060ddbab930c94142d0d52b8a4c9e8f756a6b57911.css" integrity="sha256-7iGHPDJ6p/wkESMGDdurkwyUFC0NUrikyej3Vqa1eRE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://zehua.eu/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://zehua.eu/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://zehua.eu/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://zehua.eu/apple-touch-icon.png">
<link rel="mask-icon" href="http://zehua.eu/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://zehua.eu/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98-tp2/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
    integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
    integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
    integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    }); 
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

<meta property="og:title" content="反问题 TP2" />
<meta property="og:description" content="第二次实验内容" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://zehua.eu/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98-tp2/" />
<meta property="og:image" content="http://zehua.eu/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-11-05T16:25:17+01:00" />
<meta property="article:modified_time" content="2024-11-06T17:12:35+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://zehua.eu/images/papermod-cover.png" />
<meta name="twitter:title" content="反问题 TP2"/>
<meta name="twitter:description" content="第二次实验内容"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://zehua.eu/zh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "信号处理",
      "item": "http://zehua.eu/zh/posts/signal_cn/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "反问题 TP2",
      "item": "http://zehua.eu/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98-tp2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "反问题 TP2",
  "name": "反问题 TP2",
  "description": "第二次实验内容",
  "keywords": [
    "信号处理", "统计分析", "反问题", "贝叶斯方法"
  ],
  "articleBody": "Wiener-Hunt 方法：无监督方面 在上一个实践内容中，我们介绍了去卷积问题的困难，即在应用卷积或者低通滤波器后所导致的观测数据缺失高频相关信息的情况。我们使用了 $Wiener$-$Hunt$ 方法：将量化解的误差的二次项和数据相结合，并在损失函数中使用带有正则化系数的二次惩罚标准以量化解的粗糙度。我们得到了相对来说不错的结果。但是这个方法的缺点是它需要调节一个参数，即正则化参数 $\\mu$。我们最开始由经验选择到观察选择，一直到最后循环找到 $\\mu$ 的最优值，使得去卷积后的图像既不过于不规则也不过于平滑。下面的工作重点在于介绍一种自动调节超参数的方法。\n1. 超参数与全后验分布 这个方法基于 $Wiener$-$Hunt$ 解的贝叶斯解释。该解释本身基于关于误差 $e$ 和关于图像 $x$ 的两个高斯概率模型。\n1.1 误差分布 误差被建模为白色、零均值同质高斯向量。白色指的是像白噪音一样，在其频谱特性中，所有频率分量有相同的功率密度，即信号在不同频率上的能量分布是均匀的，在数学层面，它具有零相关性，即不同时间点的误差值是统计独立的（不相关的）。\n对于高斯分布，选择了一个涉及所谓精度参数 $\\gamma_e$（方差的倒数）的替代参数化。根据这种参数化，其表达式可写为：\n$$f(e \\mid \\gamma_e) = (2\\pi)^{-N/2} \\gamma_e^{N/2} \\exp\\left( -\\frac{\\gamma_e \\|e\\|^2}{2} \\right)$$ 根据 $y = Hx + e$，数据 $y$ 和感兴趣信号 $x$ 的似然函数表达式：\n$$f(y \\mid x, \\gamma_e) = (2\\pi)^{-N/2} \\gamma_e^{N/2} \\exp\\left( -\\frac{\\gamma_e \\|y - Hx\\|^2}{2} \\right)$$ 根据所给的似然表达式 $f(y \\mid x, \\gamma_e)$，量化重建物体 $x$ 相对于观测数据 $y$ 的充分性可以通过协对数（log-likelihood）的形式表示。这种表达经常用于概率模型中，特别是最大似然估计（MLE）或贝叶斯推断中，用于评估模型参数的适配程度。\n再补充一下协对数相关内容，就是似然函数取对数，对于上述似然函数表达式，取其对数后为：\n$$\\log f(y \\mid x, \\gamma_e) = \\log\\left( (2\\pi)^{-N/2} \\gamma_e^{N/2} \\exp\\left( -\\frac{\\gamma_e \\|y - Hx\\|^2}{2} \\right) \\right)$$ 利用对数的性质：$\\ln(a \\cdot b) = \\ln a + \\ln b$，将三部分拆分开：\n$$\\log f(y \\mid x, \\gamma_e) = \\log\\left( (2\\pi)^{-N/2} \\right) + \\log\\left( \\gamma_e^{N/2} \\right) + \\log\\left( \\exp\\left( -\\frac{\\gamma_e \\|y - Hx\\|^2}{2} \\right) \\right)$$ 逐项计算：\n$$\\log\\left( (2\\pi)^{-N/2} \\right) = -\\frac{N}{2} \\log(2\\pi)$$ $$\\log\\left( \\gamma_e^{N/2} \\right) = \\frac{N}{2} \\log(\\gamma_e)$$ $$\\log\\left( \\exp\\left( -\\frac{\\gamma_e \\|y - Hx\\|^2}{2} \\right) \\right) = -\\frac{\\gamma_e}{2} \\|y - Hx\\|^2$$ 合并得到：\n$$\\log f(y \\mid x, \\gamma_e) = -\\frac{N}{2} \\log(2\\pi) + \\frac{N}{2} \\log(\\gamma_e) - \\frac{\\gamma_e}{2} \\|y - Hx\\|^2$$ 回到之前的内容，我们使用了协对数来表达数据能否充分重建原信号，我们给出这种拟合程度的量化指标：\n$$\\mathcal{J}_{LS}(x) = \\|y - Hx\\|^2 = -k_y \\log f(y \\mid x, \\gamma_e) + C_y$$ ​\t•\t$|y - Hx|^2$ 是重建信号（模型参数 $x$）与观测数据 $y$ 的误差平方和，称为残差平方和（Residual Sum of Squares, RSS）。\n​\t•\t$-k_y \\log f(y \\mid x, \\gamma_e)$ 是协对数的负加权形式，其中 $k_y \u003e 0$，是一个常数。\n​\t•\t$C_y$ 也是一个常数。\n我们现在给出两个常数 $k_y$ 和 $C_y$ 的对应表达式：\n前面得到：\n$$\\log f(y \\mid x, \\gamma_e) = -\\frac{N}{2} \\log(2\\pi) + \\frac{N}{2} \\log(\\gamma_e) - \\frac{\\gamma_e \\|y - Hx\\|^2}{2}$$ 将上述结果带入 $\\mathcal{J}_{LS}(x) = -k_y \\log f(y \\mid x, \\gamma_e) + C_y$ 得：\n$$\\mathcal{J}_{LS}(x) = -k_y \\left( -\\frac{N}{2} \\log(2\\pi) + \\frac{N}{2} \\log(\\gamma_e) - \\frac{\\gamma_e \\|y - Hx\\|^2}{2} \\right) + C_y$$ $$\\mathcal{J}_{LS}(x) = k_y \\left( \\frac{N}{2} \\log(2\\pi) - \\frac{N}{2} \\log(\\gamma_e) + \\frac{\\gamma_e \\|y - Hx\\|^2}{2} \\right) + C_y$$ 将上述结果和原公式 $\\mathcal{J}_{LS}(x) = |y - Hx|^2$ 做对比得到结果：\n$$k_y = \\frac{2}{\\gamma_e} \\quad\\quad\\quad C_y = -\\frac{N}{\\gamma_e} \\left( \\log(2\\pi) - \\log(\\gamma_e) \\right)$$ 1.2 感兴趣信号的分布 贝叶斯解释要求为感兴趣的信号 $x$ 提供一个概率分布。其模型也是高斯分布，只是这里它不是白色的，也就是说，它的各组成部分之间存在相关性。在接下来的内容中，相关性实际上是通过协方差矩阵 $R$ 来建模的。\n贝叶斯解释的核心思想是为感兴趣的信号 $x$ 提供一个概率分布，而不是一个确定值。这种概率分布反映了我们对 $x$ 的不确定性以及其任何可能的取值。因此我们假设在模型中，$x$ 服从一个高斯分布。\n但是它是一个非白色的高斯分布，也就是它的各组成部分之间存在相关性，协方差矩阵 $R$ 是一个非对角矩阵，其非零非对角元素表示信号的不同分量之间的相关性。后续我们就使用这个协方差矩阵 $R$ 在贝叶斯框架中建模信号的相关性。\n补充一下关于协方差矩阵的相关内容\n协方差矩阵 $R$ 提供了对信号相关性的精确描述。元素 $R_{ij}$ 表示信号第 $i$ 和第 $j$ 个分量之间的协方差：\n$$R_{ij} = \\mathbb{E}[(x_i - \\mu_i)(x_j - \\mu_j)]$$ 根据相关性，$R$ 可能是一个稀疏矩阵或者满矩阵。\n在贝叶斯建模中：\n​\t1.\t信号 $x$ 的 先验 分布 $p(x)$ 使用协方差矩阵 $R$ 的描述公式为：\n$$p(x) = \\frac{1}{(2\\pi)^{N/2} |R|^{1/2}} \\exp\\left( -\\frac{1}{2} x^T R^{-1} x \\right)$$ 其中，$R^{-1}$ 是协方差矩阵的逆，也称为精度矩阵，定义了 $x$ 的相关性强度。\n​\t2.\t最大后验估计（MAP）：\n利用先验分布 $p(x)$ 和观测数据 $y$ 的似然函数 $p(y \\mid x)$，可以通过贝叶斯法则计算 $x$ 的后验概率分布 $p(x \\mid y)$，并基于该分布选择最优解。\n回到之前，我们通过逆矩阵 $R^{-1} = \\gamma_x \\Pi$ 来表示建模信号的相关性，\n其中：\n​\t•\t精度参数 $\\gamma_x$ 控制相关性的强度\n​\t•\t矩阵 $\\Pi$ 决定了相关性的结构\n我们将 $R^{-1} = \\gamma_x \\Pi$ 带入之前的 $f(x \\mid \\gamma_x)$ 公式可得：\n$$f(x \\mid \\gamma_x) = (2\\pi)^{-N/2} \\det[\\Pi]^{1/2} \\gamma_x^{N/2} \\exp\\left( -\\frac{\\gamma_x}{2} x^T \\Pi x \\right)$$ 也就是说：\n$$f(x \\mid \\gamma_x) \\propto \\exp\\left( -\\frac{\\gamma_x}{2} x^T \\Pi x \\right)$$ 量化物体相对于先验信息充分性的项表现为密度的协对数：\n$$\\mathcal{J}_0(x) = -k_x \\log f(x \\mid \\gamma_x) + C_x = x^T \\Pi x$$ 其中：\n​\t•\t$\\mathcal{J}_0(x)$ 是对信号 $x$ 的量化，用来描述 $x$ 相对于先验信息（即对 $x$ 的已知假设或统计特性）是否充分匹配。其形式以密度的协对数（具体是取对数的负数）表示，结合了贝叶斯模型中的先验分布。\n​\t•\t$f(x \\mid \\gamma_x)$ 是 $x$ 的先验概率密度函数，反映了 $x$ 如何符合假设的先验模型，我们之前在假设 $x$ 服从高斯分布的前提下，得到了其表达式（见上面）。\n​\t•\t正则化项 $x^T \\Pi x$ 描述了信号 $x$ 的“复杂度”或“平滑性”，由 $\\Pi$ 决定其结构，精度参数 $\\gamma_x$ 控制正则化的强度，当 $\\gamma_x$ 较大时，正则化约束更强。\n同样，在上述公式中，我们添加了加法常数 $C_x$ 和乘法常数 $k_x$。为了与之前已经计算过的 Wiener-Hunt 方法联系起来，只需选择 $\\Pi = D^T D$。\n现在我们要给出两个常数的对应表达式。\n已知原公式：\n$$f(x \\mid \\gamma_x) = (2\\pi)^{-N/2} \\det(\\Pi)^{1/2} \\gamma_x^{N/2} \\exp\\left( -\\frac{\\gamma_x x^T \\Pi x}{2} \\right)$$ 两边取对数：\n$$\\log f(x \\mid \\gamma_x) = \\log\\left( (2\\pi)^{-N/2} \\det(\\Pi)^{1/2} \\gamma_x^{N/2} \\exp\\left( -\\frac{\\gamma_x x^T \\Pi x}{2} \\right) \\right)$$ $$\\log f(x \\mid \\gamma_x) = -\\frac{N}{2} \\log(2\\pi) + \\frac{1}{2} \\log\\left( \\det(\\Pi) \\right) + \\frac{N}{2} \\log(\\gamma_x) - \\frac{\\gamma_x x^T \\Pi x}{2}$$ 根据公式：\n$$\\mathcal{J}_0(x) = -k_x \\log f(x \\mid \\gamma_x) + C_x$$ 将上述结果带入其中得到：\n$$\\mathcal{J}_0(x) = -k_x \\left( -\\frac{N}{2} \\log(2\\pi) + \\frac{1}{2} \\log\\left( \\det(\\Pi) \\right) + \\frac{N}{2} \\log(\\gamma_x) - \\frac{\\gamma_x x^T \\Pi x}{2} \\right) + C_x$$ $$\\mathcal{J}_0(x) = k_x \\left( \\frac{N}{2} \\log(2\\pi) - \\frac{1}{2} \\log\\left( \\det(\\Pi) \\right) - \\frac{N}{2} \\log(\\gamma_x) + \\frac{\\gamma_x x^T \\Pi x}{2} \\right) + C_x$$ 对比：\n$$\\mathcal{J}_0(x) = x^T \\Pi x$$ 得到：\n$$k_x = \\frac{2}{\\gamma_x} \\quad\\quad\\quad C_x = \\frac{N}{\\gamma_x} \\log(2\\pi) - \\frac{1}{\\gamma_x} \\log\\left( \\det(\\Pi) \\right) - \\frac{N}{\\gamma_x} \\log(\\gamma_x)$$ 但是严格来说，上述解释并不完全正确，因为 $D^T D$。常量图像只不过是对应于特征值为零的特征向量（这对应于零频率）。严格的发展要求引入一个用于零频率下能量的惩罚项（通过一个可以设定为任意小值的参数）。不懂，后面补充\n上面提到的这个 $f(x \\mid \\gamma_x) = (2\\pi)^{-N/2} \\det(\\Pi)^{1/2} \\gamma_x^{N/2} \\exp\\left( -\\frac{\\gamma_x x^T \\Pi x}{2} \\right)$ 先验分布（a priori），因为它使人们能够处理先验信息，从而更倾向于具有更高规则性的图像。对于给定图像的概率越高，则图像越规则。\n其中的 $\\gamma_x$ 精度参数我们非常关注，因为它控制着图像的平滑度，进而影响着概率分布的整体趋势。\n​\t•\t当 $\\gamma_x$ 较大时，指数项中的 $x^T \\Pi x$ 会被放大。\n​\t•\t当 $\\gamma_x$ 较小时，指数项中的 $x^T \\Pi x$ 对总的概率密度的影响较小。待补充\n1.3 后验分布 借助前面定义的两个成分，并使用概率的乘法规则，现在可以构造重构信号 $x$ 和数据 $y$ 的联合密度：\n$$f(x, y \\mid \\gamma_e, \\gamma_x) = f(y \\mid x, \\gamma_e) f(x \\mid \\gamma_x)$$ 将之前得到的结果代入：\n$$f(x, y \\mid \\gamma_e, \\gamma_x) = (2\\pi)^{-N} \\det[\\Pi]^{1/2} \\gamma_x^{N/2} \\gamma_e^{N/2} \\exp\\left( -\\left[ \\gamma_e \\|y - Hx\\|^2 + \\gamma_x x^T \\Pi x \\right] / 2 \\right)$$ 这个表达式由两个精度参数 $\\gamma_e$ 和 $\\gamma_x$ 参数化。可以注意到在指数项内部，我们得到了加权最小二乘准则的表达式：\n$$\\mathcal{J}_{PLS}(x) = \\mathcal{J}_{LS}(x) + \\mu \\mathcal{J}_0(x)$$ $$\\mathcal{J}_{PLS}(x) = \\|y - Hx\\|^2 + \\mu x^T \\Pi x$$ 其中，正则化参数 $\\mu$ 表示为信噪比的倒数 $\\mu = \\gamma_x / \\gamma_e$。正则化参数 $\\mu$ 在 $\\gamma_e$ 和 $\\gamma_x$ 中的作用是？\n待补充\n通过贝叶斯定理可以确定感兴趣信号的后验分布（后验概率分布）：\n$$f(x \\mid y, \\gamma_e, \\gamma_x) = \\frac{f(x, y \\mid \\gamma_e, \\gamma_x)}{f(y \\mid \\gamma_e, \\gamma_x)} \\propto \\exp\\left( -\\gamma_e \\mathcal{J}_{PLS}(x) / 2 \\right)$$ 这就是给定数据（已观测到的）和参数下的感兴趣信号的分布。\n我们希望为感兴趣信号构造的任何估计器都基于上述分布。最常见的估计器是后验分布的均值、中位数或众数（即后验的最大化者）。在当前情况下，当后验分布是高斯分布时，这三者是相等的。众数或后验最大化者（MAP），记为 $\\hat{x} _{MAP}$ 。也就是最小化准则 $\\mathcal{J} _{PLS}(x)$ 的解\n$$\\hat{x}_{MAP} = \\arg \\max_{x} f(x \\mid y, \\gamma_e, \\gamma_x) = \\arg \\min_{x} \\mathcal{J}_{PLS}(x) = \\hat{x}_{PLS}$$ 结论是，最小二乘准则的解 $\\hat{x} _{MAP}$ 就是之前的工作中推导出来的后验分布的众数 $ \\hat{x} _{MAP}$。\n1.4 扩展的后验分布 到目前为止，贝叶斯方法只允许我们对已经存在的超参数值的估计给出概率解释。将之前的框架扩展到包含超参数的估计，需要为两个精度参数 $\\gamma_e$ 和 $\\gamma_x$ 引入一个先验分布。在多种可选方案中，接下来我们将重点关注伽马分布：\n$$f(\\gamma) = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} \\gamma^{\\alpha - 1} \\exp[-\\beta \\gamma] \\cdot 1_{\\mathbb{R}^+}(\\gamma)$$ 它由两个正实数参数 $(\\alpha, \\beta)$ 驱动，具有均值 $\\alpha / \\beta$ 和方差 $\\alpha / \\beta^2$。这种选择的理由如下：\n​\t•\t选择伽马分布作为先验分布确保了条件后验分布也是伽马分布（我们正在讨论共轭先验）。在算法上，这意味着只需要更新分布参数的值（具体见下面）。\n​\t•\t这种选择允许在参数值的信息较少（也称为“非信息先验”）或精确（如名义值或某种不确定性）的情况下进行处理。该工作中特别感兴趣的是“非信息先验”的极限情况，即 $(\\alpha, \\beta) = (0, 0)$。\n此外，关于变量 $\\gamma_e$ 和 $\\gamma_x$ 的组合，它们被建模为独立的。\n从伽马分布：\n$$f(\\gamma) = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} \\gamma^{\\alpha - 1} \\exp[-\\beta \\gamma] \\cdot 1_{\\mathbb{R}^+}(\\gamma)$$ 和部分联合分布：\n$$f(x, y \\mid \\gamma_e, \\gamma_x) = f(y \\mid x, \\gamma_e) f(x \\mid \\gamma_x) = (2\\pi)^{-N} \\det[\\Pi]^{1/2} \\gamma_x^{N/2} \\gamma_e^{N/2} \\exp\\left( -\\left[ \\gamma_e \\|y - Hx\\|^2 + \\gamma_x x^T \\Pi x \\right] / 2 \\right)$$ 的表达式出发，我们推导出对于 $y, x, \\gamma_e$ 和 $\\gamma_x$ 的完整联合分布的表达式为：\n$$f(y, x, \\gamma_e, \\gamma_x) = f(y, x \\mid \\gamma_e, \\gamma_x) f(\\gamma_e) f(\\gamma_x)$$ 其明确表达为：\n$$f(x, y, \\gamma_e, \\gamma_x) = (2\\pi)^{-N} \\det[\\Pi]^{1/2} \\frac{\\beta_e^{\\alpha_e} \\beta_x^{\\alpha_x}}{\\Gamma(\\alpha_e) \\Gamma(\\alpha_x)} \\gamma_e^{\\alpha_e + N/2 - 1} \\gamma_x^{\\alpha_x + N/2 - 1} \\exp\\left( -\\left[ \\gamma_e \\left( \\beta_e + \\|y - Hx\\|^2 / 2 \\right) + \\gamma_x \\left( \\beta_x + x^T \\Pi x / 2 \\right) \\right] \\right)$$ 注意: 这个密度非常重要，因为它允许推导出所有相关的联合、边缘和条件密度。\n现在我们可以通过贝叶斯规则推导出完整的后验分布，即给定观测数据$y$时，感兴趣信号$x$和超参数$\\gamma_e$, $\\gamma_x$的分布：\n$$f(x, \\gamma_e, \\gamma_x | y) = \\frac{f(x, y, \\gamma_e, \\gamma_x)}{f(y)}$$ $$f(x, \\gamma_e, \\gamma_x | y) \\quad \\propto \\quad \\gamma_e^{\\alpha_e + N/2 - 1} \\gamma_x^{\\alpha_x + N/2 - 1} \\exp \\left( - \\left[ \\gamma_e \\left( \\beta_e + \\|y - Hx\\|^2 / 2 \\right) + \\gamma_x \\left( \\beta_x + \\|x\\|_\\Pi^2 / 2 \\right) \\right] \\right)$$ 这汇总了所有关于感兴趣信号和超参数在数据视角下的可用信息：对于三重项 $x$, $\\gamma_e$, $\\gamma_x$，它量化了后验密度，即在给定观测数据下三重项的概率。感兴趣信号和超参数的估计器是从这个分布中构造出来的。我们可以查看后验分布的均值、中位数或众数。每种方法都有其优缺点。在接下来的内容中，我们将重点讨论均值。\n1.5 后验均值 考虑到后验分布（上面这个）的复杂性，获得均值的解析公式是不可行的。为了计算后验均值，有几种方法可用，在这里我们将重点关注随机采样技术。最终，它归结为对后验分布进行随机采样，然后取样本的经验均值，从而近似后验均值。\n后验分布的采样可以通过马尔可夫链蒙特卡洛（MCMC）方法来实现。它要求构建一个迭代过程，以生成随机样本，经过一定的时间（称为 burn-in），这些样本将根据目标分布进行分布。构建这样一个过程并不容易，但在当前情况下，存在一个标准算法可以轻松使用：Gibbs 采样算法。它将对三重项 $x$, $\\gamma_e$, $\\gamma_x$ 的后验分布进行采样的问题，转换为它们三个各自的更简单分布的采样问题。每个分布实际上是条件分布，给定其余参数的条件下对其中一个参数进行采样。该算法的工作原理在下表中给出，接下来的部分我们将详细说明这些步骤。\n$$\\begin{aligned} \u0026\\bullet \\, \\text{Initialize } x^{[0]} = y \\\\ \u0026\\bullet \\, \\text{For } k = 1, 2, \\dots \\, \\text{repeat} \\\\ \u0026\\quad \\text{(a) \\ sample } \\gamma_e^{[k]} \\text{ under } f(\\gamma_e \\mid \\gamma_x^{[k-1]}, x^{[k-1]}, y) \\\\ \u0026\\quad \\text{(b) \\ sample } \\gamma_x^{[k]} \\text{ under } f(\\gamma_x \\mid \\gamma_e^{[k]}, x^{[k-1]}, y) \\\\ \u0026\\quad \\text{(c) \\ sample } x^{[k]} \\text{ under } f(x \\mid \\gamma_e^{[k]}, \\gamma_x^{[k]}, y) \\end{aligned}$$ 1.5.1 采样逆误差功率 采样对应于步骤 (a) 的超参数 $\\gamma_e$ 需要从条件后验分布 $f(\\gamma_e | x, \\gamma_x, y)$ 中采样。该分布由完整的联合分布 $f(x, y, \\gamma_e, \\gamma_x)$ 获得，如下所示：\n$$\\text{posterior distribution }: \\quad f(\\gamma_e | x, \\gamma_x, y) = \\frac{f(x, y, \\gamma_e, \\gamma_x)}{f(x, \\gamma_x, y)}$$ 仅保留包含 $\\gamma_e$ 的项（与 $\\gamma_e$ 相关的部分），并且由于分母不依赖于 $\\gamma_e$，我们得到\n$$f(\\gamma_e | x, \\gamma_x, y) \\propto f(x, y, \\gamma_e, \\gamma_x)$$ $$f(\\gamma_e | x, \\gamma_x, y) \\quad \\propto \\quad \\gamma_e^{\\alpha_e + N/2 - 1} \\exp \\left( - \\gamma_e \\left( \\beta_e + \\| y - Hx \\|^2 / 2 \\right) \\right)$$ 由此获得的条件分布实际上是具有参数 $(\\alpha, \\beta)$ 的伽马分布：\n$$\\alpha = \\alpha_e + N/2 \\quad \\text{and} \\quad \\beta = \\beta_e + \\| y - Hx \\|^2 / 2$$ 在先验参数 $(\\alpha_e, \\beta_e)$ 等于 $(0, 0)$ 的极限情况下，后验的参数为：\n$$\\alpha = N/2 \\quad \\text{and} \\quad \\beta = \\| y - Hx \\|^2 / 2$$ 因此我们关注于这个 $f(\\gamma_e | x, \\gamma_x, y)$ 分布的均值和方差表达式，并将它与输出误差 $y - Hx$ 的功率相关联。\n已知伽马分布的概率密度函数：\n$$f(\\gamma) = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} \\gamma^{\\alpha - 1} \\exp[-\\beta \\gamma] \\cdot 1_{\\mathbb{R}+}(\\gamma)$$ 其中：$\\alpha$ 是形状参数，$\\beta$ 是尺度参数。\n对于伽马分布 $\\text{Gamma}(\\alpha, \\beta)$，其均值和方差的标准表达式分别为：\n均值：\n$$\\mathbb{E}[\\gamma_e] = \\frac{\\alpha}{\\beta}$$ 方差：\n$$\\text{Var}[\\gamma_e] = \\frac{\\alpha}{\\beta^2}$$ 已知：\n$$\\alpha = N/2 \\quad \\text{and} \\quad \\beta = \\| y - Hx \\|^2 / 2$$ 误差精度参数 $\\gamma_e$ 的均值：\n$$\\mathbb{E}[\\gamma_e] = \\frac{\\alpha_e + N/2}{\\beta_e + \\frac{\\| y - Hx \\|^2}{2}}$$ 误差精度参数 $\\gamma_e$ 的方差：\n$$\\text{Var}[\\gamma_e] = \\frac{\\alpha_e + N/2}{\\left( \\beta_e + \\frac{\\| y - Hx \\|^2}{2} \\right)^2}$$ 伽马分布中的 $\\beta$ 参数直接依赖于 $| y - Hx |^2$。\n当误差 $| y - Hx |^2$ 较大时，$\\beta$ 参数也会增大，表示模型拟合较差，这意味着伽马分布的均值和方差会减小，反映了误差增加时对数据的信任度降低。 反之，误差 $| y - Hx |^2$ 较小时，精度参数 $\\gamma_e$ 的均值增大，表示对数据的信任度较高。 因此为了实现步骤 (a)：$\\gamma_e^{[k]}$ 的样本从具有上述两个参数 $\\alpha$ 和 $\\beta$ 的伽马分布中抽取，我们可以使用 Matlab 中的 RNDGamma(Alpha, Beta); 函数，具体代码为：\n1 2 3 4 function SamplePrecision = RNDGamma(Alpha,Beta)\t% The Precision variable is a sample of the gamma distribution with parameters Alpha and Beta % Tirage d'un échantillon Gamma approché par du Gauss (JFG+TBC) SamplePrecision = Alpha/Beta + sqrt( Alpha/(Beta*Beta) ) * randn; 注意：计算参数 $\\beta$ 涉及计算建模误差 $| y - Hx |^2$ 的范数。计算空间域中的范数通常成本较高，但是可以在傅里叶域中进行计算以降低成本。\n1.5.2 采样感兴趣信号的逆功率 现在我们将重点放在采样超参数 $\\gamma_x$ 上，对应于表 1 中算法的步骤 (b)。\n这需要采样条件后验分布 $f(\\gamma_x | x, \\gamma_e, y)$。使用与上一节类似的方法，我们得到：\n$$f(\\gamma_x | x, \\gamma_e, y) \\propto \\gamma_x^{\\alpha_x + N/2 - 1} \\exp \\left( - \\gamma_x \\left( \\beta_x + \\| x \\|_\\Pi^2 / 2 \\right) \\right)$$ 可以看出，这个条件后验分布也是伽马分布。在先验参数 $(\\alpha_x, \\beta_x)$ 等于 $(0, 0)$ 的极限情况下，后验参数为：\n$$\\alpha = N/2 \\quad \\text{and} \\quad \\beta = \\| x \\|_\\Pi^2 / 2$$ 因此我们关注于 $f(\\gamma_x | x, \\gamma_e, y)$ 这个分布的均值和方差表达式，并将它与输出误差 $y - Hx$ 的功率相关联。\n均值：\n$$\\mathbb{E}[\\gamma_x] = \\frac{\\alpha_x}{\\beta_x}$$ 方差：\n$$\\text{Var}[\\gamma_x] = \\frac{\\alpha_x}{\\beta_x^2}$$ $$\\mathbb{E}[\\gamma_x] = \\frac{\\alpha_x + N/2}{\\beta_x + \\frac{\\| x \\|_{\\Pi}^2}{2}}$$ $$\\text{Var}[\\gamma_x] = \\frac{\\alpha_x + N/2}{\\left( \\beta_x + \\frac{\\| x \\|_{\\Pi}^2}{2} \\right)^2}$$ 当图像 $x$ 的二次形式较小时（即图像较为平滑），均值会相应增大。这表明我们更信任较为平滑的图像。\n因此为了实现步骤 (b) $\\gamma_x^{[k]}$ 的样本从具有上述两个参数的伽马分布中抽取，同样使用 RNDGamma 函数。\n注意：计算参数 $\\beta$ 涉及计算建模误差 $| y - Hx |^2$ 的范数。计算空间域中的范数通常成本较高，但是可以在傅里叶域中进行计算以降低成本。\n1.6 采样感兴趣的物体 最后但同样重要的是，我们将处理对应于表 1 中算法步骤 (c) 的感兴趣物体 $x$ 的采样。这意味着采样条件后验分布 $f(x | \\gamma_x, \\gamma_e, y)$，其表达式已经推导出\n$$f(x | \\gamma_e, \\gamma_x, y) = \\frac{f(x, y | \\gamma_e, \\gamma_x)}{f(y | \\gamma_e, \\gamma_x)} \\propto \\exp \\left( - \\gamma_e \\mathcal{J}_{PLS}(x) / 2 \\right)$$ 并且它便捷地重新写为：\n$$f(x | \\gamma_e, \\gamma_x, y) \\propto \\exp \\left( - \\left[ \\gamma_e \\| y - Hx \\|^2 + \\gamma_x \\| x \\|_\\Pi^2 \\right] / 2 \\right) = \\exp \\left( - \\gamma_e \\mathcal{J}_{PLS}(x) / 2 \\right)$$ 该密度本身是高斯分布，因为指数项内的变量 $x$ 是正定的二次项。它由均值和协方差矩阵完全表征。在这种情况下：\n均值 $\\mu_{x|*}$ 也是众数，作为最小化 $\\mathcal{J}_{PLS}(x)$ 的解，即之前实践工作中讨论的 Wiener-Hunt 解。 协方差矩阵 $\\Sigma_{x|*}$ 通过计算 $\\mathcal{J}_{PLS}(x)$ 的 Hessian（即二阶导数矩阵）获得。 我们得到以下表达式：\n$$\\mu_{x|*} = \\gamma_e \\Sigma_{x|*} H^T y$$ $$\\Sigma_{x|*} = \\left( \\gamma_e H^T H + \\gamma_x \\Pi \\right)^{-1}$$ 当前面临的数值问题是对可能具有高维的高斯分布进行采样。这个高维度性阻止了协方差矩阵 $\\Sigma_{x|*}$ 的求逆或分解，这意味着没有简单的采样方案可用。为了解决这个问题，我们采用循环矩阵的近似方法，从而能够在傅里叶域中进行快速的矩阵运算。给出了以下表达式：\n$$\\overset{\\circ}{\\mu}_{x|*} = \\gamma_e \\Lambda_{x|*} \\Lambda_H^{\\dagger} \\overset{\\circ}{y}$$ $$\\Lambda_{x|*} = \\left( \\gamma_e \\Lambda_H^\\dagger \\Lambda_H + \\gamma_x \\Lambda_D^\\dagger \\Lambda_D \\right)^{-1}$$ 在傅里叶域中，协方差矩阵是对角线形式的，这意味着其各个分量是解相关的。因此，每个分量是独立的，这使得可以并行采样。\n接下来我们给出上面两个表达式的推导过程，基于循环矩阵对角化的思想。\n由于矩阵 $H$ 是实数矩阵，因此它也是它的复共轭矩阵，且 $H^t = H^\\dagger$。$D$ 同理。\n因此我们将利用循环矩阵的对角化性质，由于 $H$ 和 $D$ 是循环矩阵，且循环矩阵是具有特殊结构的方阵，矩阵的每一行元素是前一行元素循环右移一位。基于这一性质，循环矩阵的一个重要性质是，它可以通过傅里叶变换对角化。具体来说，任何 $N \\times N$ 的循环矩阵 $C$ 都可以写成：\n$$C = F \\Lambda F^\\dagger$$ $F$ 是离散傅里叶变换矩阵，$F^\\dagger$ 是其共轭转置（逆傅里叶变换）。 $\\Lambda$ 是一个对角矩阵，其元素为矩阵 $C$ 的特征值（傅里叶系数）。 之前我们得到的方程为：\n$$\\mu_{x|*} = \\gamma_e \\Sigma_{x|*} H^T y$$ $$\\Sigma_{x|*} = \\left( \\gamma_e H^T H + \\gamma_x \\Pi \\right)^{-1}$$ 我们的目标是利用循环矩阵的性质将其转换到频域，从而得到新的表达式。先将 $H$ 和 $D$ 对角化：\n$$H = F \\Lambda_H F^\\dagger$$ $$\\Pi = F \\Lambda_\\Pi F^\\dagger$$ 带入原方程：\n$$\\Sigma_{x|*} = \\left( \\gamma_e H^T H + \\gamma_x \\Pi \\right)^{-1}$$ 将 $F$ 和 $F^\\dagger$ 提到外面：\n$$\\Sigma_{x|*} = F \\left( \\gamma_e \\Lambda_H^\\dagger \\Lambda_H + \\gamma_x \\Lambda_\\Pi \\right)^{-1} F^\\dagger$$ 第一个公式证明完毕：\n$$\\Lambda_{x|*} = \\left( \\gamma_e \\Lambda_H^\\dagger \\Lambda_H + \\gamma_x \\Lambda_D^\\dagger \\Lambda_D \\right)^{-1}$$ 回到开始，我们有：\n$$H = F \\Lambda_H F^\\dagger$$ $$\\Pi = F \\Lambda_\\Pi F^\\dagger$$ 把上述公式带入原方程：\n$$\\mu_{x|*} = \\gamma_e \\Sigma_{x|*} H^T y$$ 计算得：\n$$\\mu_{x|*} = \\gamma_e F \\left( \\gamma_e \\Lambda_H^\\dagger \\Lambda_H + \\gamma_x \\Lambda_D^\\dagger \\Lambda_D \\right)^{-1} F^\\dagger F \\Lambda_H^\\dagger \\hat{y}$$ 由于 $F^\\dagger F = I$，可以简化为：\n$$\\mu_{x|*} = \\gamma_e \\Lambda_{x|*} \\Lambda_H^\\dagger \\hat{y}$$ 第二个公式证毕。\n在进行步骤 (c) 时，对图像 $x^{[k]}$ 的样本应从具有在傅里叶域中给定的第一和第二矩中的高斯分布中抽取。可以使用自定义的 Matlab 函数 RNDGauss(Moy, Cov)，Moy 和 Cov 必须在傅里叶域中给出，函数具体内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 function SampleImage = RNDGauss(MoyGauss,Covariance)\t% Generate an image sample under a Gaussian distribution, with the mean given by Moy and the covariance given by Cov. % The parameters Moy and Cov, and Image, are all in the Fourier domain, not in the spatial domain. % Paramètre de Taille Taille = length(MoyGauss); % Tirage d'un bruit blanc avec la bonne symétrie BoutGauss = randn(Taille,Taille) + sqrt(-1) * randn(Taille,Taille); BoutGauss = MyFFT2( real( MyIFFT2(BoutGauss) ) ); % Filtrage du bruit blanc SampleImage = MoyGauss + BoutGauss .* sqrt(Covariance); 2 实现 在 Matlab 实践中，我们使用和上次内容相同的数据集，最后结果理论上应该相似。因为我们做出的改进只是自动调整正则化参数。我们之前介绍了算法步骤，并且详细解释了涉及两个超参数 $\\gamma_e$ 和 $\\gamma_x$ 的条件分布采样，以及图像 $x$ 的条件分布采样，所以这里直接给代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 clear all close all clc %% 加载数据 (与TP1保持一致) Data1 = load('DataOne.mat'); % 包含Data, TrueImage, IR Data = Data1.Data; TrueImage = Data1.TrueImage; IR = Data1.IR; [M,N] = size(Data); %% 构建频域传递函数 (与TP1一致) Long = length(Data); % 假设Data为方阵 H = MyFFT2RI(IR,Long); % 构建正则化滤波器频域 (Dh,Dv) 与 TP1中介绍的 D 矩阵类似 Dh = [0 0 0;0 -1 1;0 0 0]; Dv = [0 0 0;0 -1 0;0 1 0]; F_Dh = MyFFT2RI(Dh, Long); F_Dv = MyFFT2RI(Dv, Long); abs_D_squared = abs(F_Dh).^2 + abs(F_Dv).^2; Y = MyFFT2(Data); %% 超参数先验 (无信息先验) alpha_e = 0; beta_e = 0; alpha_x = 0; beta_x = 0; % 初始化参数 x = Data; % 初始化x为观测图像 gamma_e = 1; % 初始化误差精度参数 gamma_x = 1; % 初始化信号精度参数 numIter = 500; % MCMC迭代次数，可根据实际需要调整 burnIn = 200; % burn-in期长度 X_samples = zeros(M,N,numIter); gamma_e_samples = zeros(numIter,1); gamma_x_samples = zeros(numIter,1); %% MCMC (Gibbs) 迭代 for k = 1:numIter % ---- (a) 更新gamma_e ---- % 残差计算：r = y - Hx r = Data - MyIFFT2( H .* MyFFT2(x) ); norm_r2 = sum(abs(r(:)).^2); alpha_e_post = alpha_e + (M*N)/2; beta_e_post = beta_e + norm_r2/2; % 使用自定义RNDGamma函数(请确保RNDGamma.m未修改) gamma_e = RNDGamma(alpha_e_post, beta_e_post); % ---- (b) 更新gamma_x ---- % 计算 x^T Pi x 的值：在频域中为 sum(|X|^2 * |D|^2) Xf = MyFFT2(x); norm_x_Pi2 = sum(abs(Xf(:)).^2 .* abs_D_squared(:)); alpha_x_post = alpha_x + (M*N)/2; beta_x_post = beta_x + norm_x_Pi2/2; % 使用自定义RNDGamma函数 gamma_x = RNDGamma(alpha_x_post, beta_x_post); % ---- (c) 更新x ---- % 协方差的对角阵(频域)：var_x_f = 1 / (gamma_e|H|^2 + gamma_x|D|^2) denom = gamma_e*(abs(H).^2) + gamma_x*(abs_D_squared); % 均值: MU_freq = (gamma_e * conj(H).*Y)./denom MU_freq = (gamma_e * conj(H) .* Y) ./ denom; % 使用自定义RNDGauss函数进行高斯分布采样 (RNDGauss.m未修改) % RNDGauss要求参数 (MoyGauss, Covariance)，此处 Covariance = var_x_f X_f_new = RNDGauss(MU_freq, 1./denom); x = MyIFFT2(X_f_new); X_samples(:,:,k) = x; gamma_e_samples(k) = gamma_e; gamma_x_samples(k) = gamma_x; end %% 后验均值计算(去掉burn-in部分) x_posterior_mean = mean(X_samples(:,:,burnIn+1:end), 3); % 每次迭代计算与真实图像的MSE MSE_iterations = zeros(numIter,1); for i=1:numIter MSE_iterations(i) = mean((X_samples(:,:,i)-TrueImage).^2,'all'); end % 找到MSE最小的迭代次序及对应MSE值 [best_mse, best_iter] = min(MSE_iterations); % 计算最终后验均值与真实图像的评价指标 mse_val = mean((x_posterior_mean(:)-TrueImage(:)).^2); psnr_val = 10*log10(max(TrueImage(:))^2 / mse_val); %% 打印最优值信息 fprintf('在所有迭代中，MSE最小值为 %.3e，对应迭代次数为 %d\\n', best_mse, best_iter); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 %% 绘图 figure('Name','结果','NumberTitle','off','Color','w'); % 使用subplot将观测图像、真实图像、恢复图像对比展示（2行2列布局） subplot(1,3,1); imagesc(Data); colormap gray; axis image off; title('观测(模糊)图像','FontWeight','bold','FontSize',12); subplot(1,3,2); imagesc(TrueImage); colormap gray; axis image off; title('真实图像','FontWeight','bold','FontSize',12); subplot(1,3,3); imagesc(abs(x_posterior_mean)); colormap gray; axis image off; title({['恢复图像(后验均值)'],... ['MSE: ' num2str(mse_val, '%.3e') ', PSNR: ' num2str(psnr_val,'%.2f') ' dB']}, ... 'FontWeight','bold','FontSize',12); 1 2 3 4 5 6 7 8 9 10 11 12 % 显示水平中心线处的像素值对比 figure('Name','截面对比','NumberTitle','off','Color','w'); mid_row = round(M/2); plot(TrueImage(mid_row,:),'r-','LineWidth',2); hold on; plot(x_posterior_mean(mid_row,:),'b--','LineWidth',2); legend('真实图像','恢复图像','Location','best','FontSize',12); xlabel('像素索引','FontWeight','bold','FontSize',12); ylabel('像素值','FontWeight','bold','FontSize',12); title('水平中心线像素截面比较','FontWeight','bold','FontSize',12); grid on; 1 2 3 4 5 6 7 8 9 10 11 12 13 % 显示超参数迭代收敛情况 figure('Name','超参数收敛情况','NumberTitle','off','Color','w'); subplot(2,1,1); plot(gamma_e_samples,'LineWidth',1.5); xlabel('迭代次数','FontWeight','bold','FontSize',12); ylabel('\\gamma_e','FontWeight','bold','FontSize',12); title('\\gamma_e 的迭代变化','FontWeight','bold','FontSize',12); grid on; subplot(2,1,2); plot(gamma_x_samples,'LineWidth',1.5,'Color','m'); xlabel('迭代次数','FontWeight','bold','FontSize',12); ylabel('\\gamma_x','FontWeight','bold','FontSize',12); title('\\gamma_x 的迭代变化','FontWeight','bold','FontSize',12); grid on; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 %% 对比展示：观测图像 vs 第一份结果 vs 本次恢复后验均值 vs 真实图像 load('x_first_method.mat','x_first_method'); figure('Name','最终对比展示','NumberTitle','off','Color','w'); subplot(1,4,1); imagesc(Data); colormap gray; axis image off; title('观测图像','FontWeight','bold','FontSize',12); subplot(1,4,2); % 假设 x_first_method 是从第一份内容中得到的恢复图像结果变量 % 请在运行此代码前确保 x_first_method 已经在工作区中存在 imagesc(abs(x_first_method)); colormap gray; axis image off; title('Wiener - Hunt 恢复结果','FontWeight','bold','FontSize',12); subplot(1,4,3); imagesc(abs(x_posterior_mean)); colormap gray; axis image off; title('后验均值恢复结果','FontWeight','bold','FontSize',12); subplot(1,4,4); imagesc(TrueImage); colormap gray; axis image off; title('真实图像','FontWeight','bold','FontSize',12); ",
  "wordCount" : "9327",
  "inLanguage": "zh",
  "image": "http://zehua.eu/images/papermod-cover.png","datePublished": "2024-11-05T16:25:17+01:00",
  "dateModified": "2024-11-06T17:12:35+08:00",
  "author":{
    "@type": "Person",
    "name": "Zehua"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://zehua.eu/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98-tp2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "主页",
    "logo": {
      "@type": "ImageObject",
      "url": "http://zehua.eu/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://zehua.eu/zh/" accesskey="h" title="主页 (Alt + H)">主页</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://zehua.eu/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://zehua.eu/zh/posts/" title="列表">
                    <span>列表</span>
                </a>
            </li>
            <li>
                <a href="http://zehua.eu/zh/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://zehua.eu/zh/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="http://zehua.eu/zh/about/" title="版权说明">
                    <span>版权说明</span>
                </a>
            </li>
            <li>
                <a href="http://zehua.eu/zh/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://zehua.eu/zh/">主页</a>&nbsp;»&nbsp;<a href="http://zehua.eu/zh/posts/">Posts</a>&nbsp;»&nbsp;<a href="http://zehua.eu/zh/posts/signal_cn/">信号处理</a></div>
    <h1 class="post-title entry-hint-parent">
      反问题 TP2
    </h1>
    <div class="post-description">
      第二次实验内容
    </div>
    <div class="post-meta">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/all.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/v4-shims.css"><span class="meta-tag"><span class="fa fa-calendar-plus-o"></span>&nbsp;<span title='2024-11-05 16:25:17 +0100 CET'>11月5日, 2024</span></span>&nbsp; | &nbsp;<span class="meta-tag"><span class="fa fa-file-word-o"></span>&nbsp;<span>共9327字</span></span>&nbsp; | &nbsp;<span class="meta-tag"><span class="fa fa-user-circle-o"></span>&nbsp;<span>Zehua</span></span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#wiener-hunt-%e6%96%b9%e6%b3%95%e6%97%a0%e7%9b%91%e7%9d%a3%e6%96%b9%e9%9d%a2" aria-label="Wiener-Hunt 方法：无监督方面">Wiener-Hunt 方法：无监督方面</a><ul>
                            
                    <li>
                        <a href="#1-%e8%b6%85%e5%8f%82%e6%95%b0%e4%b8%8e%e5%85%a8%e5%90%8e%e9%aa%8c%e5%88%86%e5%b8%83" aria-label="1. 超参数与全后验分布">1. 超参数与全后验分布</a><ul>
                            
                    <li>
                        <a href="#11-%e8%af%af%e5%b7%ae%e5%88%86%e5%b8%83" aria-label="1.1 误差分布">1.1 误差分布</a></li>
                    <li>
                        <a href="#12-%e6%84%9f%e5%85%b4%e8%b6%a3%e4%bf%a1%e5%8f%b7%e7%9a%84%e5%88%86%e5%b8%83" aria-label="1.2 感兴趣信号的分布">1.2 感兴趣信号的分布</a></li>
                    <li>
                        <a href="#13-%e5%90%8e%e9%aa%8c%e5%88%86%e5%b8%83" aria-label="1.3 后验分布">1.3 后验分布</a></li>
                    <li>
                        <a href="#14-%e6%89%a9%e5%b1%95%e7%9a%84%e5%90%8e%e9%aa%8c%e5%88%86%e5%b8%83" aria-label="1.4 扩展的后验分布">1.4 扩展的后验分布</a></li>
                    <li>
                        <a href="#15-%e5%90%8e%e9%aa%8c%e5%9d%87%e5%80%bc" aria-label="1.5 后验均值">1.5 后验均值</a><ul>
                            
                    <li>
                        <a href="#151-%e9%87%87%e6%a0%b7%e9%80%86%e8%af%af%e5%b7%ae%e5%8a%9f%e7%8e%87" aria-label="1.5.1 采样逆误差功率">1.5.1 采样逆误差功率</a></li>
                    <li>
                        <a href="#152-%e9%87%87%e6%a0%b7%e6%84%9f%e5%85%b4%e8%b6%a3%e4%bf%a1%e5%8f%b7%e7%9a%84%e9%80%86%e5%8a%9f%e7%8e%87" aria-label="1.5.2 采样感兴趣信号的逆功率">1.5.2 采样感兴趣信号的逆功率</a></li></ul>
                    </li>
                    <li>
                        <a href="#16-%e9%87%87%e6%a0%b7%e6%84%9f%e5%85%b4%e8%b6%a3%e7%9a%84%e7%89%a9%e4%bd%93" aria-label="1.6 采样感兴趣的物体">1.6 采样感兴趣的物体</a></li></ul>
                    </li>
                    <li>
                        <a href="#2-%e5%ae%9e%e7%8e%b0" aria-label="2 实现">2 实现</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="wiener-hunt-方法无监督方面">Wiener-Hunt 方法：无监督方面<a hidden class="anchor" aria-hidden="true" href="#wiener-hunt-方法无监督方面">#</a></h1>
<p>在上一个实践内容中，我们介绍了去卷积问题的困难，即在应用卷积或者低通滤波器后所导致的观测数据缺失高频相关信息的情况。我们使用了 $Wiener$-$Hunt$ 方法：将量化解的误差的二次项和数据相结合，并在损失函数中使用带有正则化系数的二次惩罚标准以量化解的粗糙度。我们得到了相对来说不错的结果。但是这个方法的缺点是它需要调节一个参数，即正则化参数 $\mu$。我们最开始由经验选择到观察选择，一直到最后循环找到 $\mu$ 的最优值，使得去卷积后的图像既不过于不规则也不过于平滑。下面的工作重点在于介绍一种自动调节超参数的方法。</p>
<h2 id="1-超参数与全后验分布">1. 超参数与全后验分布<a hidden class="anchor" aria-hidden="true" href="#1-超参数与全后验分布">#</a></h2>
<p>这个方法基于 $Wiener$-$Hunt$ 解的贝叶斯解释。该解释本身基于关于误差 $e$ 和关于图像 $x$ 的两个高斯概率模型。</p>
<h3 id="11-误差分布">1.1 误差分布<a hidden class="anchor" aria-hidden="true" href="#11-误差分布">#</a></h3>
<p>误差被建模为白色、零均值同质高斯向量。白色指的是像白噪音一样，在其频谱特性中，所有频率分量有相同的功率密度，即信号在不同频率上的能量分布是均匀的，在数学层面，它具有零相关性，即不同时间点的误差值是统计独立的（不相关的）。</p>
<p>对于高斯分布，选择了一个涉及所谓精度参数 $\gamma_e$（方差的倒数）的替代参数化。根据这种参数化，其表达式可写为：</p>
<div>$$f(e \mid \gamma_e) = (2\pi)^{-N/2} \gamma_e^{N/2} \exp\left( -\frac{\gamma_e \|e\|^2}{2} \right)$$</div>
<p>根据 $y = Hx + e$，数据 $y$ 和感兴趣信号 $x$ 的似然函数表达式：</p>
<div>$$f(y \mid x, \gamma_e) = (2\pi)^{-N/2} \gamma_e^{N/2} \exp\left( -\frac{\gamma_e \|y - Hx\|^2}{2} \right)$$</div>
<p>根据所给的似然表达式 $f(y \mid x, \gamma_e)$，量化重建物体 $x$ 相对于观测数据 $y$ 的充分性可以通过协对数（log-likelihood）的形式表示。这种表达经常用于概率模型中，特别是最大似然估计（MLE）或贝叶斯推断中，用于评估模型参数的适配程度。</p>
<p><strong>再补充一下协对数相关内容，就是似然函数取对数，对于上述似然函数表达式，取其对数后为：</strong></p>
<div>$$\log f(y \mid x, \gamma_e) = \log\left( (2\pi)^{-N/2} \gamma_e^{N/2} \exp\left( -\frac{\gamma_e \|y - Hx\|^2}{2} \right) \right)$$</div>
<p>利用对数的性质：$\ln(a \cdot b) = \ln a + \ln b$，将三部分拆分开：</p>
<div>$$\log f(y \mid x, \gamma_e) = \log\left( (2\pi)^{-N/2} \right) + \log\left( \gamma_e^{N/2} \right) + \log\left( \exp\left( -\frac{\gamma_e \|y - Hx\|^2}{2} \right) \right)$$</div>
<p>逐项计算：</p>
<div>$$\log\left( (2\pi)^{-N/2} \right) = -\frac{N}{2} \log(2\pi)$$</div>
<div>$$\log\left( \gamma_e^{N/2} \right) = \frac{N}{2} \log(\gamma_e)$$</div>
<div>$$\log\left( \exp\left( -\frac{\gamma_e \|y - Hx\|^2}{2} \right) \right) = -\frac{\gamma_e}{2} \|y - Hx\|^2$$</div>
<p>合并得到：</p>
<div>$$\log f(y \mid x, \gamma_e) = -\frac{N}{2} \log(2\pi) + \frac{N}{2} \log(\gamma_e) - \frac{\gamma_e}{2} \|y - Hx\|^2$$</div>
<p>回到之前的内容，我们使用了协对数来表达数据能否充分重建原信号，我们给出这种拟合程度的量化指标：</p>
<div>$$\mathcal{J}_{LS}(x) = \|y - Hx\|^2 = -k_y \log f(y \mid x, \gamma_e) + C_y$$</div>
<p>​	•	$|y - Hx|^2$ 是重建信号（模型参数 $x$）与观测数据 $y$ 的误差平方和，称为残差平方和（Residual Sum of Squares, RSS）。</p>
<p>​	•	$-k_y \log f(y \mid x, \gamma_e)$ 是协对数的负加权形式，其中 $k_y &gt; 0$，是一个常数。</p>
<p>​	•	$C_y$ 也是一个常数。</p>
<p>我们现在给出两个常数 $k_y$ 和 $C_y$ 的对应表达式：</p>
<p>前面得到：</p>
<div>$$\log f(y \mid x, \gamma_e) = -\frac{N}{2} \log(2\pi) + \frac{N}{2} \log(\gamma_e) - \frac{\gamma_e \|y - Hx\|^2}{2}$$</div>
<p>将上述结果带入 $\mathcal{J}_{LS}(x) = -k_y \log f(y \mid x, \gamma_e) + C_y$ 得：</p>
<div>$$\mathcal{J}_{LS}(x) = -k_y \left( -\frac{N}{2} \log(2\pi) + \frac{N}{2} \log(\gamma_e) - \frac{\gamma_e \|y - Hx\|^2}{2} \right) + C_y$$</div>
<div>$$\mathcal{J}_{LS}(x) = k_y \left( \frac{N}{2} \log(2\pi) - \frac{N}{2} \log(\gamma_e) + \frac{\gamma_e \|y - Hx\|^2}{2} \right) + C_y$$</div>
<p>将上述结果和原公式 $\mathcal{J}_{LS}(x) = |y - Hx|^2$ 做对比得到结果：</p>
<div>$$k_y = \frac{2}{\gamma_e} \quad\quad\quad C_y = -\frac{N}{\gamma_e} \left( \log(2\pi) - \log(\gamma_e) \right)$$</div>
<h3 id="12-感兴趣信号的分布">1.2 感兴趣信号的分布<a hidden class="anchor" aria-hidden="true" href="#12-感兴趣信号的分布">#</a></h3>
<p>贝叶斯解释要求为感兴趣的信号 $x$ 提供一个概率分布。其模型也是高斯分布，只是这里它不是白色的，也就是说，它的各组成部分之间存在相关性。在接下来的内容中，相关性实际上是通过协方差矩阵 $R$ 来建模的。</p>
<p><strong>贝叶斯解释</strong>的核心思想是为感兴趣的信号 $x$ 提供一个概率分布，而不是一个确定值。这种概率分布反映了我们对 $x$ 的不确定性以及其任何可能的取值。因此我们假设在模型中，$x$ 服从一个高斯分布。</p>
<p>但是它是一个非白色的高斯分布，也就是它的各组成部分之间存在相关性，协方差矩阵 $R$ 是一个非对角矩阵，其非零非对角元素表示信号的不同分量之间的相关性。后续我们就使用这个协方差矩阵 $R$ 在贝叶斯框架中建模信号的相关性。</p>
<p><strong>补充一下关于协方差矩阵的相关内容</strong></p>
<p>协方差矩阵 $R$ 提供了对信号相关性的精确描述。元素 $R_{ij}$ 表示信号第 $i$ 和第 $j$ 个分量之间的协方差：</p>
<div>$$R_{ij} = \mathbb{E}[(x_i - \mu_i)(x_j - \mu_j)]$$</div>
<p>根据相关性，$R$ 可能是一个稀疏矩阵或者满矩阵。</p>
<p>在贝叶斯建模中：</p>
<p>​	1.	信号 $x$ 的 <strong>先验</strong> 分布 $p(x)$ 使用协方差矩阵 $R$ 的描述公式为：</p>
<div>$$p(x) = \frac{1}{(2\pi)^{N/2} |R|^{1/2}} \exp\left( -\frac{1}{2} x^T R^{-1} x \right)$$</div>
<p>其中，$R^{-1}$ 是协方差矩阵的逆，也称为精度矩阵，定义了 $x$ 的相关性强度。</p>
<p>​	2.	最大后验估计（MAP）：</p>
<p>利用先验分布 $p(x)$ 和观测数据 $y$ 的似然函数 $p(y \mid x)$，可以通过贝叶斯法则计算 $x$ 的后验概率分布 $p(x \mid y)$，并基于该分布选择最优解。</p>
<p>回到之前，我们通过逆矩阵 $R^{-1} = \gamma_x \Pi$ 来表示建模信号的相关性，</p>
<p>其中：</p>
<p>​	•	<strong>精度参数</strong> $\gamma_x$ 控制相关性的强度</p>
<p>​	•	<strong>矩阵</strong> $\Pi$ 决定了相关性的结构</p>
<p>我们将 $R^{-1} = \gamma_x \Pi$ 带入之前的 $f(x \mid \gamma_x)$ 公式可得：</p>
<div>$$f(x \mid \gamma_x) = (2\pi)^{-N/2} \det[\Pi]^{1/2} \gamma_x^{N/2} \exp\left( -\frac{\gamma_x}{2} x^T \Pi x \right)$$</div>
<p>也就是说：</p>
<div>$$f(x \mid \gamma_x) \propto \exp\left( -\frac{\gamma_x}{2} x^T \Pi x \right)$$</div>
<p>量化物体相对于先验信息充分性的项表现为密度的协对数：</p>
<div>$$\mathcal{J}_0(x) = -k_x \log f(x \mid \gamma_x) + C_x = x^T \Pi x$$</div>
<p>其中：</p>
<p>​	•	$\mathcal{J}_0(x)$ 是对信号 $x$ 的量化，用来描述 $x$ 相对于先验信息（即对 $x$ 的已知假设或统计特性）是否充分匹配。其形式以密度的协对数（具体是取对数的负数）表示，结合了贝叶斯模型中的先验分布。</p>
<p>​	•	$f(x \mid \gamma_x)$ 是 $x$ 的先验概率密度函数，反映了 $x$ 如何符合假设的先验模型，我们之前在假设 $x$ 服从高斯分布的前提下，得到了其表达式（见上面）。</p>
<p>​	•	<strong>正则化项</strong> $x^T \Pi x$ 描述了信号 $x$ 的“复杂度”或“平滑性”，由 $\Pi$ 决定其结构，精度参数 $\gamma_x$ 控制正则化的强度，当 $\gamma_x$ 较大时，正则化约束更强。</p>
<p>同样，在上述公式中，我们添加了加法常数 $C_x$ 和乘法常数 $k_x$。为了与之前已经计算过的 Wiener-Hunt 方法联系起来，只需选择 $\Pi = D^T D$。</p>
<p>现在我们要给出两个常数的对应表达式。</p>
<p>已知原公式：</p>
<div>$$f(x \mid \gamma_x) = (2\pi)^{-N/2} \det(\Pi)^{1/2} \gamma_x^{N/2} \exp\left( -\frac{\gamma_x x^T \Pi x}{2} \right)$$</div>
<p>两边取对数：</p>
<div>$$\log f(x \mid \gamma_x) = \log\left( (2\pi)^{-N/2} \det(\Pi)^{1/2} \gamma_x^{N/2} \exp\left( -\frac{\gamma_x x^T \Pi x}{2} \right) \right)$$</div>
<div>$$\log f(x \mid \gamma_x) = -\frac{N}{2} \log(2\pi) + \frac{1}{2} \log\left( \det(\Pi) \right) + \frac{N}{2} \log(\gamma_x) - \frac{\gamma_x x^T \Pi x}{2}$$</div>
<p>根据公式：</p>
<div>$$\mathcal{J}_0(x) = -k_x \log f(x \mid \gamma_x) + C_x$$</div>
<p>将上述结果带入其中得到：</p>
<div>$$\mathcal{J}_0(x) = -k_x \left( -\frac{N}{2} \log(2\pi) + \frac{1}{2} \log\left( \det(\Pi) \right) + \frac{N}{2} \log(\gamma_x) - \frac{\gamma_x x^T \Pi x}{2} \right) + C_x$$</div>
<div>$$\mathcal{J}_0(x) = k_x \left( \frac{N}{2} \log(2\pi) - \frac{1}{2} \log\left( \det(\Pi) \right) - \frac{N}{2} \log(\gamma_x) + \frac{\gamma_x x^T \Pi x}{2} \right) + C_x$$</div>
<p>对比：</p>
<div>$$\mathcal{J}_0(x) = x^T \Pi x$$</div>
<p>得到：</p>
<div>$$k_x = \frac{2}{\gamma_x} \quad\quad\quad C_x = \frac{N}{\gamma_x} \log(2\pi) - \frac{1}{\gamma_x} \log\left( \det(\Pi) \right) - \frac{N}{\gamma_x} \log(\gamma_x)$$</div>
<p>但是严格来说，上述解释并不完全正确，因为 $D^T D$。常量图像只不过是对应于特征值为零的特征向量（这对应于零频率）。严格的发展要求引入一个用于零频率下能量的惩罚项（通过一个可以设定为任意小值的参数）。<strong>不懂，后面补充</strong></p>
<p>上面提到的这个 $f(x \mid \gamma_x) = (2\pi)^{-N/2} \det(\Pi)^{1/2} \gamma_x^{N/2} \exp\left( -\frac{\gamma_x x^T \Pi x}{2} \right)$ 先验分布（a priori），因为它使人们能够处理先验信息，从而更倾向于具有更高规则性的图像。对于给定图像的概率越高，则图像越规则。</p>
<p>其中的 $\gamma_x$ 精度参数我们非常关注，因为它控制着图像的平滑度，进而影响着概率分布的整体趋势。</p>
<p>​	•	当 $\gamma_x$ 较大时，指数项中的 $x^T \Pi x$ 会被放大。</p>
<p>​	•	当 $\gamma_x$ 较小时，指数项中的 $x^T \Pi x$ 对总的概率密度的影响较小。<strong>待补充</strong></p>
<h3 id="13-后验分布">1.3 后验分布<a hidden class="anchor" aria-hidden="true" href="#13-后验分布">#</a></h3>
<p>借助前面定义的两个成分，并使用概率的乘法规则，现在可以构造重构信号 $x$ 和数据 $y$ 的联合密度：</p>
<div>$$f(x, y \mid \gamma_e, \gamma_x) = f(y \mid x, \gamma_e) f(x \mid \gamma_x)$$</div>
<p>将之前得到的结果代入：</p>
<div>$$f(x, y \mid \gamma_e, \gamma_x) = (2\pi)^{-N} \det[\Pi]^{1/2} \gamma_x^{N/2} \gamma_e^{N/2} \exp\left( -\left[ \gamma_e \|y - Hx\|^2 + \gamma_x x^T \Pi x \right] / 2 \right)$$</div>
<p>这个表达式由两个精度参数 $\gamma_e$ 和 $\gamma_x$ 参数化。可以注意到在指数项内部，我们得到了加权最小二乘准则的表达式：</p>
<div>$$\mathcal{J}_{PLS}(x) = \mathcal{J}_{LS}(x) + \mu \mathcal{J}_0(x)$$</div>
<div>$$\mathcal{J}_{PLS}(x) = \|y - Hx\|^2 + \mu x^T \Pi x$$</div>
<p>其中，正则化参数 $\mu$ 表示为信噪比的倒数 $\mu = \gamma_x / \gamma_e$。正则化参数 $\mu$ 在 $\gamma_e$ 和 $\gamma_x$ 中的作用是？</p>
<p><strong>待补充</strong></p>
<p>通过贝叶斯定理可以确定感兴趣信号的后验分布（后验概率分布）：</p>
<div>$$f(x \mid y, \gamma_e, \gamma_x) = \frac{f(x, y \mid \gamma_e, \gamma_x)}{f(y \mid \gamma_e, \gamma_x)} \propto \exp\left( -\gamma_e \mathcal{J}_{PLS}(x) / 2 \right)$$</div>
<p>这就是给定数据（已观测到的）和参数下的感兴趣信号的分布。</p>
<p>我们希望为感兴趣信号构造的任何估计器都基于上述分布。最常见的估计器是后验分布的均值、中位数或众数（即后验的最大化者）。在当前情况下，当后验分布是高斯分布时，这三者是相等的。众数或后验最大化者（MAP），记为 $\hat{x} _{MAP}$ 。也就是最小化准则 $\mathcal{J} _{PLS}(x)$ 的解</p>
<div>$$\hat{x}_{MAP} = \arg \max_{x} f(x \mid y, \gamma_e, \gamma_x) = \arg \min_{x} \mathcal{J}_{PLS}(x) = \hat{x}_{PLS}$$</div>
<p>结论是，最小二乘准则的解 	 $\hat{x} _{MAP}$  	就是之前的工作中推导出来的后验分布的众数 $ \hat{x} _{MAP}$。</p>
<h3 id="14-扩展的后验分布">1.4 扩展的后验分布<a hidden class="anchor" aria-hidden="true" href="#14-扩展的后验分布">#</a></h3>
<p>到目前为止，贝叶斯方法只允许我们对已经存在的超参数值的估计给出概率解释。将之前的框架扩展到包含超参数的估计，需要为两个精度参数 $\gamma_e$ 和 $\gamma_x$ 引入一个先验分布。在多种可选方案中，接下来我们将重点关注伽马分布：</p>
<div>$$f(\gamma) = \frac{\beta^\alpha}{\Gamma(\alpha)} \gamma^{\alpha - 1} \exp[-\beta \gamma] \cdot 1_{\mathbb{R}^+}(\gamma)$$</div>
<p>它由两个正实数参数 $(\alpha, \beta)$ 驱动，具有均值 $\alpha / \beta$ 和方差 $\alpha / \beta^2$。这种选择的理由如下：</p>
<p>​	•	选择伽马分布作为先验分布确保了条件后验分布也是伽马分布（我们正在讨论共轭先验）。在算法上，这意味着只需要更新分布参数的值（具体见下面）。</p>
<p>​	•	这种选择允许在参数值的信息较少（也称为“非信息先验”）或精确（如名义值或某种不确定性）的情况下进行处理。该工作中特别感兴趣的是“非信息先验”的极限情况，即 $(\alpha, \beta) = (0, 0)$。</p>
<p>此外，关于变量 $\gamma_e$ 和 $\gamma_x$ 的组合，它们被建模为独立的。</p>
<p>从伽马分布：</p>
<div>$$f(\gamma) = \frac{\beta^\alpha}{\Gamma(\alpha)} \gamma^{\alpha - 1} \exp[-\beta \gamma] \cdot 1_{\mathbb{R}^+}(\gamma)$$</div>
<p>和部分联合分布：</p>
<div>$$f(x, y \mid \gamma_e, \gamma_x) = f(y \mid x, \gamma_e) f(x \mid \gamma_x) = (2\pi)^{-N} \det[\Pi]^{1/2} \gamma_x^{N/2} \gamma_e^{N/2} \exp\left( -\left[ \gamma_e \|y - Hx\|^2 + \gamma_x x^T \Pi x \right] / 2 \right)$$</div>
<p>的表达式出发，我们推导出对于 $y, x, \gamma_e$ 和 $\gamma_x$ 的完整联合分布的表达式为：</p>
<div>$$f(y, x, \gamma_e, \gamma_x) = f(y, x \mid \gamma_e, \gamma_x) f(\gamma_e) f(\gamma_x)$$</div>
<p>其明确表达为：</p>
<div>$$f(x, y, \gamma_e, \gamma_x) = (2\pi)^{-N} \det[\Pi]^{1/2} \frac{\beta_e^{\alpha_e} \beta_x^{\alpha_x}}{\Gamma(\alpha_e) \Gamma(\alpha_x)} \gamma_e^{\alpha_e + N/2 - 1} \gamma_x^{\alpha_x + N/2 - 1} \exp\left( -\left[ \gamma_e \left( \beta_e + \|y - Hx\|^2 / 2 \right) + \gamma_x \left( \beta_x + x^T \Pi x / 2 \right) \right] \right)$$</div>
<p>注意: 这个密度非常重要，因为它允许推导出所有相关的联合、边缘和条件密度。</p>
<p>现在我们可以通过贝叶斯规则推导出完整的后验分布，即给定观测数据$y$时，感兴趣信号$x$和超参数$\gamma_e$, $\gamma_x$的分布：</p>
<div>$$f(x, \gamma_e, \gamma_x | y) = \frac{f(x, y, \gamma_e, \gamma_x)}{f(y)}$$</div>
<div>$$f(x, \gamma_e, \gamma_x | y) \quad \propto \quad \gamma_e^{\alpha_e + N/2 - 1} \gamma_x^{\alpha_x + N/2 - 1} \exp \left( - \left[ \gamma_e \left( \beta_e + \|y - Hx\|^2 / 2 \right) + \gamma_x \left( \beta_x + \|x\|_\Pi^2 / 2 \right) \right] \right)$$</div>
<p>这汇总了所有关于感兴趣信号和超参数在数据视角下的可用信息：对于三重项 $x$, $\gamma_e$, $\gamma_x$，它量化了后验密度，即在给定观测数据下三重项的概率。感兴趣信号和超参数的估计器是从这个分布中构造出来的。我们可以查看后验分布的均值、中位数或众数。每种方法都有其优缺点。在接下来的内容中，我们将重点讨论均值。</p>
<h3 id="15-后验均值">1.5 后验均值<a hidden class="anchor" aria-hidden="true" href="#15-后验均值">#</a></h3>
<p>考虑到后验分布（上面这个）的复杂性，获得均值的解析公式是不可行的。为了计算后验均值，有几种方法可用，在这里我们将重点关注随机采样技术。最终，它归结为对后验分布进行随机采样，然后取样本的经验均值，从而近似后验均值。</p>
<p>后验分布的采样可以通过<strong>马尔可夫链蒙特卡洛（MCMC）方法</strong>来实现。它要求构建一个迭代过程，以生成随机样本，经过一定的时间（称为 burn-in），这些样本将根据目标分布进行分布。构建这样一个过程并不容易，但在当前情况下，存在一个标准算法可以轻松使用：Gibbs 采样算法。它将对三重项 $x$, $\gamma_e$, $\gamma_x$ 的后验分布进行采样的问题，转换为它们三个各自的更简单分布的采样问题。每个分布实际上是条件分布，给定其余参数的条件下对其中一个参数进行采样。该算法的工作原理在下表中给出，接下来的部分我们将详细说明这些步骤。</p>
<div>$$\begin{aligned} &\bullet \, \text{Initialize } x^{[0]} = y \\ &\bullet \, \text{For } k = 1, 2, \dots \, \text{repeat} \\ &\quad \text{(a) \ sample } \gamma_e^{[k]} \text{ under } f(\gamma_e \mid \gamma_x^{[k-1]}, x^{[k-1]}, y) \\ &\quad \text{(b) \ sample } \gamma_x^{[k]} \text{ under } f(\gamma_x \mid \gamma_e^{[k]}, x^{[k-1]}, y) \\ &\quad \text{(c) \ sample } x^{[k]} \text{ under } f(x \mid \gamma_e^{[k]}, \gamma_x^{[k]}, y) \end{aligned}$$</div>
<h4 id="151-采样逆误差功率">1.5.1 采样逆误差功率<a hidden class="anchor" aria-hidden="true" href="#151-采样逆误差功率">#</a></h4>
<p>采样对应于步骤 (a) 的超参数 $\gamma_e$ 需要从条件后验分布 $f(\gamma_e | x, \gamma_x, y)$ 中采样。该分布由完整的联合分布 $f(x, y, \gamma_e, \gamma_x)$ 获得，如下所示：</p>
<div>$$\text{posterior distribution }: \quad f(\gamma_e | x, \gamma_x, y) = \frac{f(x, y, \gamma_e, \gamma_x)}{f(x, \gamma_x, y)}$$</div>
<p>仅保留包含 $\gamma_e$ 的项（与 $\gamma_e$ 相关的部分），并且由于分母不依赖于 $\gamma_e$，我们得到</p>
<div>$$f(\gamma_e | x, \gamma_x, y) \propto f(x, y, \gamma_e, \gamma_x)$$</div>
<div>$$f(\gamma_e | x, \gamma_x, y) \quad \propto \quad \gamma_e^{\alpha_e + N/2 - 1} \exp \left( - \gamma_e \left( \beta_e + \| y - Hx \|^2 / 2 \right) \right)$$</div>
<p>由此获得的条件分布实际上是具有参数 $(\alpha, \beta)$ 的伽马分布：</p>
<div>$$\alpha = \alpha_e + N/2 \quad \text{and} \quad \beta = \beta_e + \| y - Hx \|^2 / 2$$</div>
<p>在先验参数 $(\alpha_e, \beta_e)$ 等于 $(0, 0)$ 的极限情况下，后验的参数为：</p>
<div>$$\alpha = N/2 \quad \text{and} \quad \beta = \| y - Hx \|^2 / 2$$</div>
<p>因此我们关注于这个 $f(\gamma_e | x, \gamma_x, y)$ 分布的均值和方差表达式，并将它与输出误差 $y - Hx$ 的功率相关联。</p>
<p>已知伽马分布的概率密度函数：</p>
<div>$$f(\gamma) = \frac{\beta^\alpha}{\Gamma(\alpha)} \gamma^{\alpha - 1} \exp[-\beta \gamma] \cdot 1_{\mathbb{R}+}(\gamma)$$</div>
<p>其中：$\alpha$ 是形状参数，$\beta$ 是尺度参数。</p>
<p>对于伽马分布 $\text{Gamma}(\alpha, \beta)$，其均值和方差的标准表达式分别为：</p>
<p>均值：</p>
<div>$$\mathbb{E}[\gamma_e] = \frac{\alpha}{\beta}$$</div>
<p>方差：</p>
<div>$$\text{Var}[\gamma_e] = \frac{\alpha}{\beta^2}$$</div>
<p>已知：</p>
<div>$$\alpha = N/2 \quad \text{and} \quad \beta = \| y - Hx \|^2 / 2$$</div>
<p>误差精度参数 $\gamma_e$ 的均值：</p>
<div>$$\mathbb{E}[\gamma_e] = \frac{\alpha_e + N/2}{\beta_e + \frac{\| y - Hx \|^2}{2}}$$</div>
<p>误差精度参数 $\gamma_e$ 的方差：</p>
<div>$$\text{Var}[\gamma_e] = \frac{\alpha_e + N/2}{\left( \beta_e + \frac{\| y - Hx \|^2}{2} \right)^2}$$</div>
<p>伽马分布中的 $\beta$ 参数直接依赖于 $| y - Hx |^2$。</p>
<ul>
<li>当误差 $| y - Hx |^2$ 较大时，$\beta$ 参数也会增大，表示模型拟合较差，这意味着伽马分布的均值和方差会减小，反映了误差增加时对数据的信任度降低。</li>
<li>反之，误差 $| y - Hx |^2$ 较小时，精度参数 $\gamma_e$ 的均值增大，表示对数据的信任度较高。</li>
</ul>
<p>因此为了实现步骤 (a)：$\gamma_e^{[k]}$ 的样本从具有上述两个参数 $\alpha$ 和 $\beta$ 的伽马分布中抽取，我们可以使用 Matlab 中的 <code>RNDGamma(Alpha, Beta);</code> 函数，具体代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">function</span><span class="w"> </span>SamplePrecision <span class="p">=</span><span class="w"> </span><span class="nf">RNDGamma</span><span class="p">(</span>Alpha,Beta<span class="p">)</span><span class="w">	
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c">% The Precision variable is a sample of the gamma distribution with parameters Alpha and Beta</span>
</span></span><span class="line"><span class="cl">    <span class="c">% Tirage d&#39;un échantillon Gamma approché par du Gauss (JFG+TBC)</span>
</span></span><span class="line"><span class="cl">    <span class="n">SamplePrecision</span> <span class="p">=</span> <span class="n">Alpha</span><span class="o">/</span><span class="n">Beta</span> <span class="o">+</span> <span class="nb">sqrt</span><span class="p">(</span> <span class="n">Alpha</span><span class="o">/</span><span class="p">(</span><span class="n">Beta</span><span class="o">*</span><span class="n">Beta</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="nb">randn</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：计算参数 $\beta$ 涉及计算建模误差 $| y - Hx |^2$ 的范数。计算空间域中的范数通常成本较高，但是可以在傅里叶域中进行计算以降低成本。</p>
<h4 id="152-采样感兴趣信号的逆功率">1.5.2 采样感兴趣信号的逆功率<a hidden class="anchor" aria-hidden="true" href="#152-采样感兴趣信号的逆功率">#</a></h4>
<p>现在我们将重点放在采样超参数 $\gamma_x$ 上，对应于表 1 中算法的步骤 (b)。</p>
<p>这需要采样条件后验分布 $f(\gamma_x | x, \gamma_e, y)$。使用与上一节类似的方法，我们得到：</p>
<div>$$f(\gamma_x | x, \gamma_e, y) \propto \gamma_x^{\alpha_x + N/2 - 1} \exp \left( - \gamma_x \left( \beta_x + \| x \|_\Pi^2 / 2 \right) \right)$$</div>
<p>可以看出，这个条件后验分布也是伽马分布。在先验参数 $(\alpha_x, \beta_x)$ 等于 $(0, 0)$ 的极限情况下，后验参数为：</p>
<div>$$\alpha = N/2 \quad \text{and} \quad \beta = \| x \|_\Pi^2 / 2$$</div>
<p>因此我们关注于 $f(\gamma_x | x, \gamma_e, y)$ 这个分布的均值和方差表达式，并将它与输出误差 $y - Hx$ 的功率相关联。</p>
<p>均值：</p>
<div>$$\mathbb{E}[\gamma_x] = \frac{\alpha_x}{\beta_x}$$</div>
<p>方差：</p>
<div>$$\text{Var}[\gamma_x] = \frac{\alpha_x}{\beta_x^2}$$</div>
<div>$$\mathbb{E}[\gamma_x] = \frac{\alpha_x + N/2}{\beta_x + \frac{\| x \|_{\Pi}^2}{2}}$$</div>
<div>$$\text{Var}[\gamma_x] = \frac{\alpha_x + N/2}{\left( \beta_x + \frac{\| x \|_{\Pi}^2}{2} \right)^2}$$</div>
<p>当图像 $x$ 的二次形式较小时（即图像较为平滑），均值会相应增大。这表明我们更信任较为平滑的图像。</p>
<p>因此为了实现步骤 (b) $\gamma_x^{[k]}$ 的样本从具有上述两个参数的伽马分布中抽取，同样使用 <code>RNDGamma</code> 函数。</p>
<p>注意：计算参数 $\beta$ 涉及计算建模误差 $| y - Hx |^2$ 的范数。计算空间域中的范数通常成本较高，但是可以在傅里叶域中进行计算以降低成本。</p>
<h3 id="16-采样感兴趣的物体">1.6 采样感兴趣的物体<a hidden class="anchor" aria-hidden="true" href="#16-采样感兴趣的物体">#</a></h3>
<p>最后但同样重要的是，我们将处理对应于表 1 中算法步骤 (c) 的感兴趣物体 $x$ 的采样。这意味着采样条件后验分布 $f(x | \gamma_x, \gamma_e, y)$，其表达式已经推导出</p>
<div>$$f(x | \gamma_e, \gamma_x, y) = \frac{f(x, y | \gamma_e, \gamma_x)}{f(y | \gamma_e, \gamma_x)} \propto \exp \left( - \gamma_e \mathcal{J}_{PLS}(x) / 2 \right)$$</div>
<p>并且它便捷地重新写为：</p>
<div>$$f(x | \gamma_e, \gamma_x, y) \propto \exp \left( - \left[ \gamma_e \| y - Hx \|^2 + \gamma_x \| x \|_\Pi^2 \right] / 2 \right) = \exp \left( - \gamma_e \mathcal{J}_{PLS}(x) / 2 \right)$$</div>
<p>该密度本身是高斯分布，因为指数项内的变量 $x$ 是正定的二次项。它由均值和协方差矩阵完全表征。在这种情况下：</p>
<ul>
<li>均值 $\mu_{x|*}$ 也是众数，作为最小化 $\mathcal{J}_{PLS}(x)$ 的解，即之前实践工作中讨论的 Wiener-Hunt 解。</li>
<li>协方差矩阵 $\Sigma_{x|*}$ 通过计算 $\mathcal{J}_{PLS}(x)$ 的 Hessian（即二阶导数矩阵）获得。</li>
</ul>
<p>我们得到以下表达式：</p>
<div>$$\mu_{x|*} = \gamma_e \Sigma_{x|*} H^T y$$</div>
<div>$$\Sigma_{x|*} = \left( \gamma_e H^T H + \gamma_x \Pi \right)^{-1}$$</div>
<p>当前面临的数值问题是对可能具有高维的高斯分布进行采样。这个高维度性阻止了协方差矩阵 $\Sigma_{x|*}$ 的求逆或分解，这意味着没有简单的采样方案可用。为了解决这个问题，我们采用循环矩阵的近似方法，从而能够在傅里叶域中进行快速的矩阵运算。给出了以下表达式：</p>
<div>$$\overset{\circ}{\mu}_{x|*} = \gamma_e \Lambda_{x|*} \Lambda_H^{\dagger} \overset{\circ}{y}$$</div>
<div>$$\Lambda_{x|*} = \left( \gamma_e \Lambda_H^\dagger \Lambda_H + \gamma_x \Lambda_D^\dagger \Lambda_D \right)^{-1}$$</div>
<p>在傅里叶域中，协方差矩阵是对角线形式的，这意味着其各个分量是解相关的。因此，每个分量是独立的，这使得可以并行采样。</p>
<div
    class="alert alert-warning"    role="alert"><text><p><strong>接下来我们给出上面两个表达式的推导过程，基于循环矩阵对角化的思想。</strong></p>
<p>由于矩阵 $H$ 是实数矩阵，因此它也是它的复共轭矩阵，且 $H^t = H^\dagger$。$D$ 同理。</p>
<p>因此我们将利用循环矩阵的对角化性质，由于 $H$ 和 $D$ 是循环矩阵，且循环矩阵是具有特殊结构的方阵，矩阵的每一行元素是前一行元素循环右移一位。基于这一性质，循环矩阵的一个重要性质是，它可以通过傅里叶变换对角化。具体来说，任何 $N \times N$ 的循环矩阵 $C$ 都可以写成：</p>
<div>$$C = F \Lambda F^\dagger$$</div>
<ul>
<li>$F$ 是离散傅里叶变换矩阵，$F^\dagger$ 是其共轭转置（逆傅里叶变换）。</li>
<li>$\Lambda$ 是一个对角矩阵，其元素为矩阵 $C$ 的特征值（傅里叶系数）。</li>
</ul>
<p>之前我们得到的方程为：</p>
<div>$$\mu_{x|*} = \gamma_e \Sigma_{x|*} H^T y$$</div>
<div>$$\Sigma_{x|*} = \left( \gamma_e H^T H + \gamma_x \Pi \right)^{-1}$$</div>
<p>我们的目标是利用循环矩阵的性质将其转换到频域，从而得到新的表达式。先将 $H$ 和 $D$ 对角化：</p>
<div>$$H = F \Lambda_H F^\dagger$$</div>
<div>$$\Pi = F \Lambda_\Pi F^\dagger$$</div>
<p>带入原方程：</p>
<div>$$\Sigma_{x|*} = \left( \gamma_e H^T H + \gamma_x \Pi \right)^{-1}$$</div>
<p>将 $F$ 和 $F^\dagger$ 提到外面：</p>
<div>$$\Sigma_{x|*} = F \left( \gamma_e \Lambda_H^\dagger \Lambda_H + \gamma_x \Lambda_\Pi \right)^{-1} F^\dagger$$</div>
<p>第一个公式证明完毕：</p>
<div>$$\Lambda_{x|*} = \left( \gamma_e \Lambda_H^\dagger \Lambda_H + \gamma_x \Lambda_D^\dagger \Lambda_D \right)^{-1}$$</div>
<p>回到开始，我们有：</p>
<div>$$H = F \Lambda_H F^\dagger$$</div>
<div>$$\Pi = F \Lambda_\Pi F^\dagger$$</div>
<p>把上述公式带入原方程：</p>
<div>$$\mu_{x|*} = \gamma_e \Sigma_{x|*} H^T y$$</div>
<p>计算得：</p>
<div>$$\mu_{x|*} = \gamma_e F \left( \gamma_e \Lambda_H^\dagger \Lambda_H + \gamma_x \Lambda_D^\dagger \Lambda_D \right)^{-1} F^\dagger F \Lambda_H^\dagger \hat{y}$$</div>
<p>由于 $F^\dagger F = I$，可以简化为：</p>
<div>$$\mu_{x|*} = \gamma_e \Lambda_{x|*} \Lambda_H^\dagger \hat{y}$$</div>
<p>第二个公式证毕。</p>
</text></div>

<p>在进行步骤 (c) 时，对图像 $x^{[k]}$ 的样本应从具有在傅里叶域中给定的第一和第二矩中的高斯分布中抽取。可以使用自定义的 Matlab 函数 <code>RNDGauss(Moy, Cov)</code>，<code>Moy</code> 和 <code>Cov</code> 必须在傅里叶域中给出，函数具体内容为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">function</span><span class="w"> </span>SampleImage <span class="p">=</span><span class="w"> </span><span class="nf">RNDGauss</span><span class="p">(</span>MoyGauss,Covariance<span class="p">)</span><span class="w">	
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c">% Generate an image sample under a Gaussian distribution, with the mean given by Moy and the covariance given by Cov.</span>
</span></span><span class="line"><span class="cl"><span class="c">% The parameters Moy and Cov, and Image, are all in the Fourier domain, not in the spatial domain.</span>
</span></span><span class="line"><span class="cl"><span class="c">% Paramètre de Taille</span>
</span></span><span class="line"><span class="cl">	<span class="n">Taille</span> <span class="p">=</span> <span class="nb">length</span><span class="p">(</span><span class="n">MoyGauss</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="c">% Tirage d&#39;un bruit blanc avec la bonne symétrie</span>
</span></span><span class="line"><span class="cl">	<span class="n">BoutGauss</span> <span class="p">=</span> <span class="nb">randn</span><span class="p">(</span><span class="n">Taille</span><span class="p">,</span><span class="n">Taille</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">randn</span><span class="p">(</span><span class="n">Taille</span><span class="p">,</span><span class="n">Taille</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">BoutGauss</span> <span class="p">=</span> <span class="n">MyFFT2</span><span class="p">(</span> <span class="nb">real</span><span class="p">(</span> <span class="n">MyIFFT2</span><span class="p">(</span><span class="n">BoutGauss</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Filtrage du bruit blanc</span>
</span></span><span class="line"><span class="cl">	<span class="n">SampleImage</span> <span class="p">=</span> <span class="n">MoyGauss</span> <span class="o">+</span> <span class="n">BoutGauss</span> <span class="o">.*</span> <span class="nb">sqrt</span><span class="p">(</span><span class="n">Covariance</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="2-实现">2 实现<a hidden class="anchor" aria-hidden="true" href="#2-实现">#</a></h2>
<p>在 Matlab 实践中，我们使用和上次内容相同的数据集，最后结果理论上应该相似。因为我们做出的改进只是自动调整正则化参数。我们之前介绍了算法步骤，并且详细解释了涉及两个超参数 $\gamma_e$ 和 $\gamma_x$ 的条件分布采样，以及图像 $x$ 的条件分布采样，所以这里直接给代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">clear</span> <span class="n">all</span>
</span></span><span class="line"><span class="cl"><span class="n">close</span> <span class="n">all</span>
</span></span><span class="line"><span class="cl"><span class="n">clc</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">%% 加载数据 (与TP1保持一致)</span>
</span></span><span class="line"><span class="cl"><span class="n">Data1</span> <span class="p">=</span> <span class="n">load</span><span class="p">(</span><span class="s">&#39;DataOne.mat&#39;</span><span class="p">);</span> <span class="c">% 包含Data, TrueImage, IR</span>
</span></span><span class="line"><span class="cl"><span class="n">Data</span> <span class="p">=</span> <span class="n">Data1</span><span class="p">.</span><span class="n">Data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">TrueImage</span> <span class="p">=</span> <span class="n">Data1</span><span class="p">.</span><span class="n">TrueImage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">IR</span> <span class="p">=</span> <span class="n">Data1</span><span class="p">.</span><span class="n">IR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">]</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">Data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">%% 构建频域传递函数 (与TP1一致)</span>
</span></span><span class="line"><span class="cl"><span class="n">Long</span> <span class="p">=</span> <span class="nb">length</span><span class="p">(</span><span class="n">Data</span><span class="p">);</span> <span class="c">% 假设Data为方阵</span>
</span></span><span class="line"><span class="cl"><span class="n">H</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">IR</span><span class="p">,</span><span class="n">Long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 构建正则化滤波器频域 (Dh,Dv) 与 TP1中介绍的 D 矩阵类似</span>
</span></span><span class="line"><span class="cl"><span class="n">Dh</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span><span class="mi">0</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">;</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl"><span class="n">Dv</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span><span class="mi">0</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">F_Dh</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">Dh</span><span class="p">,</span> <span class="n">Long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">F_Dv</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">Dv</span><span class="p">,</span> <span class="n">Long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">abs_D_squared</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">F_Dh</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">F_Dv</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Y</span> <span class="p">=</span> <span class="n">MyFFT2</span><span class="p">(</span><span class="n">Data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">%% 超参数先验 (无信息先验)</span>
</span></span><span class="line"><span class="cl"><span class="n">alpha_e</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">beta_e</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="n">alpha_x</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">beta_x</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 初始化参数</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="p">=</span> <span class="n">Data</span><span class="p">;</span>        <span class="c">% 初始化x为观测图像</span>
</span></span><span class="line"><span class="cl"><span class="n">gamma_e</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="c">% 初始化误差精度参数</span>
</span></span><span class="line"><span class="cl"><span class="n">gamma_x</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="c">% 初始化信号精度参数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">numIter</span> <span class="p">=</span> <span class="mi">500</span><span class="p">;</span>   <span class="c">% MCMC迭代次数，可根据实际需要调整</span>
</span></span><span class="line"><span class="cl"><span class="n">burnIn</span> <span class="p">=</span> <span class="mi">200</span><span class="p">;</span>    <span class="c">% burn-in期长度</span>
</span></span><span class="line"><span class="cl"><span class="n">X_samples</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">numIter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">gamma_e_samples</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">numIter</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">gamma_x_samples</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">numIter</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">%% MCMC (Gibbs) 迭代</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">k</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">numIter</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">% ---- (a) 更新gamma_e ----</span>
</span></span><span class="line"><span class="cl">    <span class="c">% 残差计算：r = y - Hx</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span> <span class="p">=</span> <span class="n">Data</span> <span class="o">-</span> <span class="n">MyIFFT2</span><span class="p">(</span> <span class="n">H</span> <span class="o">.*</span> <span class="n">MyFFT2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">norm_r2</span> <span class="p">=</span> <span class="n">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">(:))</span><span class="o">.^</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">alpha_e_post</span> <span class="p">=</span> <span class="n">alpha_e</span> <span class="o">+</span> <span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">beta_e_post</span> <span class="p">=</span> <span class="n">beta_e</span> <span class="o">+</span> <span class="n">norm_r2</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c">% 使用自定义RNDGamma函数(请确保RNDGamma.m未修改)</span>
</span></span><span class="line"><span class="cl">    <span class="n">gamma_e</span> <span class="p">=</span> <span class="n">RNDGamma</span><span class="p">(</span><span class="n">alpha_e_post</span><span class="p">,</span> <span class="n">beta_e_post</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">% ---- (b) 更新gamma_x ----</span>
</span></span><span class="line"><span class="cl">    <span class="c">% 计算 x^T Pi x 的值：在频域中为 sum(|X|^2 * |D|^2)</span>
</span></span><span class="line"><span class="cl">    <span class="n">Xf</span> <span class="p">=</span> <span class="n">MyFFT2</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">norm_x_Pi2</span> <span class="p">=</span> <span class="n">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Xf</span><span class="p">(:))</span><span class="o">.^</span><span class="mi">2</span> <span class="o">.*</span> <span class="n">abs_D_squared</span><span class="p">(:));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">alpha_x_post</span> <span class="p">=</span> <span class="n">alpha_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">beta_x_post</span> <span class="p">=</span> <span class="n">beta_x</span> <span class="o">+</span> <span class="n">norm_x_Pi2</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c">% 使用自定义RNDGamma函数</span>
</span></span><span class="line"><span class="cl">    <span class="n">gamma_x</span> <span class="p">=</span> <span class="n">RNDGamma</span><span class="p">(</span><span class="n">alpha_x_post</span><span class="p">,</span> <span class="n">beta_x_post</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">% ---- (c) 更新x ----</span>
</span></span><span class="line"><span class="cl">    <span class="c">% 协方差的对角阵(频域)：var_x_f = 1 / (gamma_e|H|^2 + gamma_x|D|^2)</span>
</span></span><span class="line"><span class="cl">    <span class="n">denom</span> <span class="p">=</span> <span class="n">gamma_e</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">H</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">gamma_x</span><span class="o">*</span><span class="p">(</span><span class="n">abs_D_squared</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c">% 均值: MU_freq = (gamma_e * conj(H).*Y)./denom</span>
</span></span><span class="line"><span class="cl">    <span class="n">MU_freq</span> <span class="p">=</span> <span class="p">(</span><span class="n">gamma_e</span> <span class="o">*</span> <span class="nb">conj</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">.*</span> <span class="n">Y</span><span class="p">)</span> <span class="o">./</span> <span class="n">denom</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">% 使用自定义RNDGauss函数进行高斯分布采样 (RNDGauss.m未修改)</span>
</span></span><span class="line"><span class="cl">    <span class="c">% RNDGauss要求参数 (MoyGauss, Covariance)，此处 Covariance = var_x_f</span>
</span></span><span class="line"><span class="cl">    <span class="n">X_f_new</span> <span class="p">=</span> <span class="n">RNDGauss</span><span class="p">(</span><span class="n">MU_freq</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="n">denom</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="p">=</span> <span class="n">MyIFFT2</span><span class="p">(</span><span class="n">X_f_new</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">X_samples</span><span class="p">(:,:,</span><span class="n">k</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">gamma_e_samples</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">=</span> <span class="n">gamma_e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">gamma_x_samples</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">=</span> <span class="n">gamma_x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">%% 后验均值计算(去掉burn-in部分)</span>
</span></span><span class="line"><span class="cl"><span class="n">x_posterior_mean</span> <span class="p">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">X_samples</span><span class="p">(:,:,</span><span class="n">burnIn</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 每次迭代计算与真实图像的MSE</span>
</span></span><span class="line"><span class="cl"><span class="n">MSE_iterations</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">numIter</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nb">i</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">numIter</span>
</span></span><span class="line"><span class="cl">    <span class="n">MSE_iterations</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="p">=</span> <span class="n">mean</span><span class="p">((</span><span class="n">X_samples</span><span class="p">(:,:,</span><span class="nb">i</span><span class="p">)</span><span class="o">-</span><span class="n">TrueImage</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;all&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 找到MSE最小的迭代次序及对应MSE值</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">best_mse</span><span class="p">,</span> <span class="n">best_iter</span><span class="p">]</span> <span class="p">=</span> <span class="n">min</span><span class="p">(</span><span class="n">MSE_iterations</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 计算最终后验均值与真实图像的评价指标</span>
</span></span><span class="line"><span class="cl"><span class="n">mse_val</span> <span class="p">=</span> <span class="n">mean</span><span class="p">((</span><span class="n">x_posterior_mean</span><span class="p">(:)</span><span class="o">-</span><span class="n">TrueImage</span><span class="p">(:))</span><span class="o">.^</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">psnr_val</span> <span class="p">=</span> <span class="mi">10</span><span class="o">*</span><span class="nb">log10</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">TrueImage</span><span class="p">(:))</span>^<span class="mi">2</span> <span class="o">/</span> <span class="n">mse_val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">%% 打印最优值信息</span>
</span></span><span class="line"><span class="cl"><span class="n">fprintf</span><span class="p">(</span><span class="s">&#39;在所有迭代中，MSE最小值为 %.3e，对应迭代次数为 %d\n&#39;</span><span class="p">,</span> <span class="n">best_mse</span><span class="p">,</span> <span class="n">best_iter</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 绘图</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">(</span><span class="s">&#39;Name&#39;</span><span class="p">,</span><span class="s">&#39;结果&#39;</span><span class="p">,</span><span class="s">&#39;NumberTitle&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">,</span><span class="s">&#39;Color&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 使用subplot将观测图像、真实图像、恢复图像对比展示（2行2列布局）</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Data</span><span class="p">);</span> <span class="n">colormap</span> <span class="n">gray</span><span class="p">;</span> <span class="n">axis</span> <span class="n">image</span> <span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;观测(模糊)图像&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">TrueImage</span><span class="p">);</span> <span class="n">colormap</span> <span class="n">gray</span><span class="p">;</span> <span class="n">axis</span> <span class="n">image</span> <span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;真实图像&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x_posterior_mean</span><span class="p">));</span> <span class="n">colormap</span> <span class="n">gray</span><span class="p">;</span> <span class="n">axis</span> <span class="n">image</span> <span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">({[</span><span class="s">&#39;恢复图像(后验均值)&#39;</span><span class="p">],</span><span class="c">...</span>
</span></span><span class="line"><span class="cl">       <span class="p">[</span><span class="s">&#39;MSE: &#39;</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mse_val</span><span class="p">,</span> <span class="s">&#39;%.3e&#39;</span><span class="p">)</span> <span class="s">&#39;, PSNR: &#39;</span> <span class="n">num2str</span><span class="p">(</span><span class="n">psnr_val</span><span class="p">,</span><span class="s">&#39;%.2f&#39;</span><span class="p">)</span> <span class="s">&#39; dB&#39;</span><span class="p">]},</span> <span class="c">...</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP2/6.png" alt="TP1_1"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% 显示水平中心线处的像素值对比</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">(</span><span class="s">&#39;Name&#39;</span><span class="p">,</span><span class="s">&#39;截面对比&#39;</span><span class="p">,</span><span class="s">&#39;NumberTitle&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">,</span><span class="s">&#39;Color&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">mid_row</span> <span class="p">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">TrueImage</span><span class="p">(</span><span class="n">mid_row</span><span class="p">,:),</span><span class="s">&#39;r-&#39;</span><span class="p">,</span><span class="s">&#39;LineWidth&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">hold</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">x_posterior_mean</span><span class="p">(</span><span class="n">mid_row</span><span class="p">,:),</span><span class="s">&#39;b--&#39;</span><span class="p">,</span><span class="s">&#39;LineWidth&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">legend</span><span class="p">(</span><span class="s">&#39;真实图像&#39;</span><span class="p">,</span><span class="s">&#39;恢复图像&#39;</span><span class="p">,</span><span class="s">&#39;Location&#39;</span><span class="p">,</span><span class="s">&#39;best&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;像素索引&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;像素值&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;水平中心线像素截面比较&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="/img/Problem_inverse/TP2/3.png" alt="TP1_1" style="width:90%;" />
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% 显示超参数迭代收敛情况</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">(</span><span class="s">&#39;Name&#39;</span><span class="p">,</span><span class="s">&#39;超参数收敛情况&#39;</span><span class="p">,</span><span class="s">&#39;NumberTitle&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">,</span><span class="s">&#39;Color&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">gamma_e_samples</span><span class="p">,</span><span class="s">&#39;LineWidth&#39;</span><span class="p">,</span><span class="mf">1.5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;迭代次数&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;\gamma_e&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;\gamma_e 的迭代变化&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span> <span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">gamma_x_samples</span><span class="p">,</span><span class="s">&#39;LineWidth&#39;</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="s">&#39;Color&#39;</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;迭代次数&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;\gamma_x&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;\gamma_x 的迭代变化&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span> <span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img src="/img/Problem_inverse/TP2/4.png" alt="TP1_1" style="width:90%;" />
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% 对比展示：观测图像 vs 第一份结果 vs 本次恢复后验均值 vs 真实图像</span>
</span></span><span class="line"><span class="cl"><span class="n">load</span><span class="p">(</span><span class="s">&#39;x_first_method.mat&#39;</span><span class="p">,</span><span class="s">&#39;x_first_method&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">(</span><span class="s">&#39;Name&#39;</span><span class="p">,</span><span class="s">&#39;最终对比展示&#39;</span><span class="p">,</span><span class="s">&#39;NumberTitle&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">,</span><span class="s">&#39;Color&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Data</span><span class="p">);</span> <span class="n">colormap</span> <span class="n">gray</span><span class="p">;</span> <span class="n">axis</span> <span class="n">image</span> <span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;观测图像&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% 假设 x_first_method 是从第一份内容中得到的恢复图像结果变量 </span>
</span></span><span class="line"><span class="cl"><span class="c">% 请在运行此代码前确保 x_first_method 已经在工作区中存在</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x_first_method</span><span class="p">));</span> <span class="n">colormap</span> <span class="n">gray</span><span class="p">;</span> <span class="n">axis</span> <span class="n">image</span> <span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Wiener - Hunt 恢复结果&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x_posterior_mean</span><span class="p">));</span> <span class="n">colormap</span> <span class="n">gray</span><span class="p">;</span> <span class="n">axis</span> <span class="n">image</span> <span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;后验均值恢复结果&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">TrueImage</span><span class="p">);</span> <span class="n">colormap</span> <span class="n">gray</span><span class="p">;</span> <span class="n">axis</span> <span class="n">image</span> <span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;真实图像&#39;</span><span class="p">,</span><span class="s">&#39;FontWeight&#39;</span><span class="p">,</span><span class="s">&#39;bold&#39;</span><span class="p">,</span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP2/final1.png" alt="TP1_1"  />
</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://zehua.eu/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98tp1/">
    <span class="title">« 上一页</span>
    <br>
    <span>反问题 TP1</span>
  </a>
  <a class="next" href="http://zehua.eu/zh/posts/signal_cn/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/">
    <span class="title">下一页 »</span>
    <br>
    <span>图像基础处理</span>
  </a>
</nav>

  </footer>
</article>

<div class="post-password"></div>
  
</div>
    </main>
    
<footer class="footer">
        <span><a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod</a></span> · 


    <span>
        
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a>  
        
    </span>
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <br>
    <span id="busuanzi_container_page_pv" style='display:none'>
        一共有<span id="busuanzi_value_page_pv"></span>人来过这里
    </span>
    · <span id="last_change">
        最后更新于2024年12月4日
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
