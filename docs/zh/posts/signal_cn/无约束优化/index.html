<!DOCTYPE html>
<html lang="zh" dir="ltr">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>无约束优化 | 主页</title>
<meta name="keywords" content="信号处理, Optimisation">
<meta name="description" content="本内容为Optimisation实验内容，所有代码和结果是和Darwin Wang Cheou 共同完成的">
<meta name="author" content="Zehua">
<link rel="canonical" href="https://zehua716.github.io/zh/posts/signal_cn/%E6%97%A0%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.27abbf28894f6aa4fb20918f453526b3b1b2f9f8d0085a8f4f4470f04aaf6081.css" integrity="sha256-J6u/KIlPaqT7IJGPRTUms7Gy&#43;fjQCFqPT0Rw8EqvYIE=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zehua716.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zehua716.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zehua716.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zehua716.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zehua716.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://zehua716.github.io/zh/posts/signal_cn/%E6%97%A0%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
    integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
    integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
    integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    }); 
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet"><meta property="og:title" content="无约束优化" />
<meta property="og:description" content="本内容为Optimisation实验内容，所有代码和结果是和Darwin Wang Cheou 共同完成的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zehua716.github.io/zh/posts/signal_cn/%E6%97%A0%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96/" />
<meta property="og:image" content="https://zehua716.github.io/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-06-05T16:25:17+01:00" />
<meta property="article:modified_time" content="2024-11-20T17:12:35+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://zehua716.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="无约束优化"/>
<meta name="twitter:description" content="本内容为Optimisation实验内容，所有代码和结果是和Darwin Wang Cheou 共同完成的"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://zehua716.github.io/zh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "信号处理",
      "item": "https://zehua716.github.io/zh/posts/signal_cn/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "无约束优化",
      "item": "https://zehua716.github.io/zh/posts/signal_cn/%E6%97%A0%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "无约束优化",
  "name": "无约束优化",
  "description": "本内容为Optimisation实验内容，所有代码和结果是和Darwin Wang Cheou 共同完成的",
  "keywords": [
    "信号处理", "Optimisation"
  ],
  "articleBody": "问题描述 我们将先研究Rosenbrock函数的最小化问题，其定义如下：\n$$x = (x_1, x_2) \\in \\mathbb{R}^2\\quad \\rightarrow f(x) = (1 - x_1)^2 + 100(x_2 - x_1^2)^2$$\n涉及的具体内容如下\n(a) 创建和可视化Rosenbrock函数的二维和三维图像。\n(b) 分析函数的性质，特别是其凸性和优化难度。\n(c) 计算并实现函数的梯度和Hessian矩阵。\n(d) 利用梯度下降法以寻找函数的最小值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 % Creation de la fonction de Rosenbrock f = @ ( x1 , x2 ) (1 - x1 ) .^2 + 100*( x2 - x1 .^2) .^2; % Evaluation de la fonction sur une grille de points x1 = linspace ( -2 ,2 ,150) ; x2 = linspace ( -.5 ,3 ,150) ; [X2,X1] = meshgrid(x2,x1) ; F = f( X1 , X2 ) ; % Affichage 3D figure , surf ( x2 , x1 , F ) ; xlabel ('X1') , ylabel ('X2') , zlabel ('f') , shading interp ; camlight ; axis tight ; colormap jet ; % Af fichage 2 D figure , imagesc ( F ) ; colormap jet (256) ; ​\t图1：Rosenbrock函数凸性的3D显示\n可以注意到，Rosenbrock函数并非严格凸的，有点类似局部凸的感觉，其形状类似倒置的抛物线。随便在这个范围内两个点之间画一条直线，该直线会超出集合的界限。\n因此，优化Rosenbrock函数具有一定难度。下降法可能会很容易陷入局部极小值，或在其周围振荡而无法收敛到全局极小值。\n1 2 3 figure , contour ( x2 , x1 , F ,10) xlabel ('X1') , ylabel ('X2') ​\t图2：Rosenbrock函数的等高线图\n可以观察到曲线并非均匀分布。它们表示函数的梯度，等高线的密集区域表明梯度更陡（函数值变化更快），而等高线较稀疏的区域表明梯度更缓（函数值变化较慢）。\n前置计算 我们下面计算函数$f$的梯度\n$$f(x_1, x_2) = (1 - x_1)^2 + 100(x_2 - x_1^2)^2$$\n梯度的表达方式如下：\n$$\\nabla f(x) = \\left( \\frac{\\partial f}{\\partial x_1}, \\frac{\\partial f}{\\partial x_2} \\right)$$\n计算$\\frac{\\partial f}{\\partial x_1}$：\n$$\\frac{\\partial f}{\\partial x_1} = -2 + 2x_1 - 400x_1x_2 + 400x_1^3$$\n计算$\\frac{\\partial f}{\\partial x_2}$：\n$$\\frac{\\partial f}{\\partial x_2} = 200x_2 - 200x_1^2$$\n因此，函数$f$的梯度为：\n$$\\nabla f(x) = \\left( -2 + 2x_1 - 400x_1x_2 + 400x_1^3, ; 200x_2 - 200x_1^2 \\right)$$\n可以进一步计算Hessian矩阵：\n$$ H_f(x) = \\begin{pmatrix}2 - 400x_2 + 1200x_1^2 \u0026 -400x_1 \\\\ -400x_1 \u0026 200 \\end{pmatrix} $$\n下面我们验证函数在$x^* = (1, 1)$处是否有极值，使其梯度为零：\n$$\\nabla f(x^*) = 0$$\n因此需要解以下系统方程：\n$$-2 + 2x _1^* - 400x _1^*x_2^* + 400x _1^{*3} = 0$$ $$ 200x_2^* - 200x_1^{*2} = 0 $$\n可得到:\n$$x_1^{*2} = x_2^*$$ 重新排列项后：\n$$-2 + 2x_1^* - 400x_1^*x_2^* + 400x_1^{*3} = 0$$ 得到平衡点： $$ x_1^* = x_2^* = 1 $$\n在平衡点 $x^* = (1, 1)$ 处计算Hessian矩阵：\n$$ H_f(x) = \\begin{bmatrix} 802 \u0026 -400 \\\\ -400 \u0026 200 \\end{bmatrix} $$\n我们利用Matlab求解Hessian矩阵的特征值，如果特征值为正，那么可以说明点 $x^{*} = (1, 1)$是一个最小值\n1 2 Hj = [802 -400; -400 200]; eig(Hj) % lambda i \u003e 0 donc définie positive donc min local $$ \\lambda_1 = 0.4 $$\n$$ \\lambda_2 = 1001.6 $$\n因此，两个特征值均为严格正值，表明Hessian矩阵是正定的，点$x^* = (1, 1)$是一个局部最小值。\n编程实现梯度 和 Hessian矩阵\n1 2 3 4 5 6 % Le gradient de la fonction f gradf = @ ( x1 , x2 ) [-2 + 2*x1 - 400*x1*x2 + 400*x1^3; 200*x2 - 200*x1^2]; Gradf = @ ( x ) gradf ( x (1) ,x (2) ) ; % La matrice Hessienne de la fonction f hessf = @ ( x1 , x2 ) [2 - 400*x2 + 1200*x1^2, -400*x1; -400*x1, 200]; Hessf = @ ( x ) hessf ( x (1) ,x (2) ) ; 后续我们将比较两种优化方法：一种是经典梯度下降法，另一种是牛顿法。\n梯度下降法 梯度下降法是一种迭代优化技术，用于寻找可微函数的最小值。其基本思想是沿着目标函数梯度的反方向移动，因为这一方向可以使函数值下降最快。其过程如下：\n(a) 选择初始点$x_0$，该点位于函数定义域内。\n(b) 在每次迭代$k$中，计算函数的梯度$\\nabla f(x_k)$。\n(c) 根据以下规则更新当前点：\n$$ x_{k+1} = x_k - \\alpha \\cdot \\nabla f(x_k) $$\n其中，$\\alpha$是下降步长（学习率），为控制步长大小的正参数。 (d) 迭代过程重复，直到梯度足够接近于零（或者达到最大迭代次数）。\n(e) 在每次迭代中使用相同的$\\alpha$。选择合适的$\\alpha$至关重要：步长太大会导致算法震荡甚至发散，而步长太小会减慢收敛速度。\n梯度下降法的优点在于其简单易用，并且可以适用于广泛的可微函数和优化问题。然而，它也存在以下缺点：\n收敛速度可能较慢，特别是对于类似于 Rosenbrock函数 的问题。\n不适当的步长选择可能会阻止收敛。\n对于非凸函数，梯度下降可能陷入局部最小值。\n接下来我们将通过编程，在Rosenbrock函数上实现梯度下降法，以确定函数$f$的最小值。\n1 2 3 4 5 6 7 8 9 10 figure, hold on; contour ( x2 , x1 , F ,10) alpha = 1e-3; x0 = [1.5;2.5]; N = 1e4; %10e4; [x, fx] = descente_gradient(f, Gradf, N, alpha, x0); plot(x(2,:), x(1,:), 'k', 'linewidth', 1.5); axis ([ -.5 3 -2 2]) ; 1 2 3 4 5 6 7 8 9 10 function [x, fx] = descente_gradient(f, Gradf, N, alpha, x0) x = zeros(length(x0), N+1); fx = zeros(1, N+1); x(:,1) = x0; fx(1) = f(x0(1),x0(2)); for i = 1:N x(:,i+1) = x(:,i) - alpha*Gradf(x(:,i)); fx(i+1) = f(x(1,i+1), x(2,i+1)); end end 得到以下图像：\n​\t图3：Rosenbrock函数的梯度下降轨迹（$N = 10^4$）\n通过图3可以观察到，轨迹一开始出现了明显的震荡，并向最小值方向下移。下降初期的震荡表明在初始几步中很难找到最佳下降方向，这是由于Rosenbrock函数的特性所致。然而，随着轨迹的推进，震荡逐渐减小，路径变得更加规则。这意味着算法开始逐步收敛至全局最小值，该最小值位于等高线较密集的中心区域。\n为了说明迭代次数和步长的重要性，我们尝试不同参数下的下降过程。\n首先，将迭代次数从10000减少到1000。\n​\t图4：Rosenbrock函数的梯度下降轨迹（$N = 10^3$）\n正如预期的那样，将迭代次数从$10^4$减少到$10^3$，明显表明算法没有足够的时间显著接近全局最小值。有限的轨迹强调了迭代次数的重要性。足够的迭代次数是保证梯度下降算法能够正确收敛的关键。也就是说，正确设置迭代次数和下降步长对于确保算法适当的收敛非常重要。\n​\t图5：Rosenbrock函数的梯度下降轨迹（$N = 10^5$）\n几乎没有变化。因为迭代次数过大，算法早就稳定并收敛了，即达到极值了。过高的迭代次数是没有意义的。\n现在对于梯度下降轨迹已经分析完了，下面调步长$\\alpha$，看看它对算法性能的影响，并理解如何影响优化的稳定性、收敛速度以及精度。\n​\t图6：Rosenbrock函数的梯度下降轨迹（$\\alpha = 10^{-2}$）\n轨迹不再收敛，开始震荡并发散。步长$\\alpha = 10^{-2}$ 过大，远离最优解。\n​\t图7：Rosenbrock函数的梯度下降轨迹（$\\alpha = 10^{-4}$）\n步长$\\alpha = 10^{-4}$非常小，算法向最小值的推进极慢，和乌龟一样。\n给出最优解\n​\t图8：Rosenbrock函数的梯度下降轨迹（$\\alpha = 10^{-4}, N = 10^5$）\n非常漂亮，不需要解释了\n然而，我们也可以从另一个角度解释结果，认为需要在步长和迭代次数之间找到一个良好的平衡，以使算法在有限的迭代次数和适当的步长下收敛到最小值，同时避免过多的震荡，从而节省计算成本和时间。\n改进方法:\n每次迭代中，不仅考虑当前梯度，还要考虑先前迭代的方向，这可以减少震荡并加速收敛。或者结合其他优化方法，例如牛顿法，其利用了 Hessian矩阵来提高收敛速度和精度。\n牛顿法 牛顿法是一种迭代优化技术，用于寻找可导函数的驻点。与梯度下降法不同，牛顿法不仅利用梯度信息，还使用函数曲率信息（Hessian矩阵）来确定下降方向。\n其过程如下：\n​\t选择一个初始点$x_0$，位于函数定义域内。\n​\t在每次迭代$k$中，计算函数的梯度$\\nabla f(x_k)$和Hessian矩阵$H_f(x_k)$。\n​\t根据以下规则更新当前点：\n$$x_{k+1} = x_k - H_f(x_k)^{-1} \\cdot \\nabla f(x_k)$$\n其中，$H_f(x_k)^{-1}$是函数在点$x_k$处的Hessian矩阵的逆矩阵。 重复该过程，直到梯度足够接近于零或更新步长的范数小于预设阈值。\n牛顿法通过利用梯度和曲率信息，让更新更高效、收敛更快。但是，计算成本高，且需要反转Hessian矩阵，并且在函数条件差或非凸时不是很好用。\n继续对Rosenbrock函数动手，利用Matlab实现，首先选择$N = 10$和$x_0 = [1.7; 2.7]$\n1 2 3 4 5 6 7 8 9 figure, hold on; contour ( x2 , x1 , F ,10) x0 = [1.7;2.7]; N = 10; [x, fx] = descente_Newton(f, Gradf, Hessf, N, x0); plot(x(2,:), x(1,:), 'k', 'linewidth', 1.5); axis ([ -.5 3 -2 2]); 1 2 3 4 5 6 7 8 9 10 function [x, fx] = descente_Newton(f, Gradf, Hessf, N, x0) x = zeros(length(x0), N+1); fx = zeros(1, N+1); x(:,1) = x0; fx(1) = f(x0(1),x0(2)); for i = 1:N x(:,i+1) = x(:,i) - inv(Hessf(x(:,i)))*Gradf(x(:,i)); fx(i+1) = f(x(1,i+1), x(2,i+1)); end end ​\t图9：$f$的变化与范数$E$关于迭代次数的演变\n与梯度下降法类似，轨迹从右上角 向 最优点靠近。\n牛顿法显示了快速的收敛，其轨迹表现出其步长较大，这就是使用Hessian矩阵的特性，最终收敛到最小值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 x_star = [1; 1]; E = sqrt(sum((x - x_star).^2, 1)); % for i = 1:N % E(:,i)= norm(x(:,i)-x_star); % end figure; subplot(2,1,1); plot(log10(1:N+1), log10(fx)); xlabel('Log10(Iteration)'); ylabel('Log10(Valeur de la fonction)'); title('Congergence de la fonction de Rosenbrock'); subplot(2,1,2); plot(log10(1:N+1), log10(E)); xlabel('Log10(Iteration)'); ylabel('Log10(Norme de x - x*)'); title('Congergence de la fonction de Newton'); % Affichage en echelle logarithmique % figure , plot (log10(E(E \u003e eps))); ​\t图9：$f$的变化与范数$E$关于迭代次数的演变\n图10：不同初始化条件下解 $x$ 的演变\n我们绘制了两个图，用于描述函数$f$和范数$E$随迭代次数的变化。\n对于Rosenbrock函数，纵轴表示函数值的对数刻度$\\log_{10}$，横轴表示迭代次数的对数刻度$\\log_{10}$。可以看到，在大约$10^{0.6}$次迭代后，函数值迅速下降（约4次迭代）。然后曲线趋于稳定，接近$10^{-30}$，表明函数基本收敛到全局最小值。\n对于牛顿算法，纵轴表示误差范数$|x - x^|$的对数刻度（$\\log_{10}$），横轴表示迭代次数的对数刻度（$\\log_{10}$）。可见误差范数随着迭代次数迅速下降，显示出算法的 快速收敛 性，因为通过利用Hessian矩阵加速了向最优解的下降。最后稳定在极低的值（$10^{-15}$），这表明$x$与$x^$之间的误差几乎为零，显示牛顿法精确地收敛到最优解。\n可见牛顿法在优化Rosenbrock函数时非常不错，快速且精确\n​\t图10：不同初始化条件下解 $x$ 的演变\n我们从三个不同初始点（分别用红色、蓝色和绿色表示）来出发并显示它的轨迹。它们最终收敛到不同的点，但是距离非常接近，特别是绿色和蓝色。这表明牛顿法到达局部最小值或非常接近全局最小值的能力。即使初始条件不同，但是我们可能获得同样的最优解结果，这让初始点的策略选择变得不那么紧张了。\n为增强牛顿法的鲁棒性，可以使用技术来稳定Hessian矩阵，或者将算法与线搜索方法结合，不过还是那句话，时代变了，当模型又高纬又复杂，直接上神经网络，近似 Hessian 矩阵或其逆 $H^{-1}$。或者动态学习每一步的最优步长 $\\alpha_k$，不用自己纠结选步长。\n或者直接暴力一点，传统优化算法都不要了，直接学习一个端到端的优化器，它通过输入 函数的梯度或样本点，直接输出下一步的迭代结果，比如用RNN（递归神经网络）学习迭代规则： $$ x_{k+1} = \\text{RNN}(x_k, \\nabla f(x_k), H_f(x_k)) $$ 但是一般没有足够的数据。\n综上所述，梯度下降法可能收敛速度慢，步长选择要求高。此外，对于局部凸函数，梯度下降法容易陷入局部极小值。因此，牛顿法更适合用于优化Rosenbrock这样的函数，收敛快速且精确，并且对局部凸函数表现良好。然而，牛顿法也有局限性，即计算Hessian矩阵逆的高昂成本。\n",
  "wordCount" : "887",
  "inLanguage": "zh",
  "image": "https://zehua716.github.io/images/papermod-cover.png","datePublished": "2024-06-05T16:25:17+01:00",
  "dateModified": "2024-11-20T17:12:35+08:00",
  "author":{
    "@type": "Person",
    "name": "Zehua"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zehua716.github.io/zh/posts/signal_cn/%E6%97%A0%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "主页",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zehua716.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zehua716.github.io/zh/" accesskey="h" title="主页 (Alt + H)">主页</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://zehua716.github.io/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zehua716.github.io/zh/posts/" title="列表">
                    <span>列表</span>
                </a>
            </li>
            <li>
                <a href="https://zehua716.github.io/zh/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://zehua716.github.io/zh/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://zehua716.github.io/zh/about/" title="版权说明">
                    <span>版权说明</span>
                </a>
            </li>
            <li>
                <a href="https://zehua716.github.io/zh/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://zehua716.github.io/zh/">主页</a>&nbsp;»&nbsp;<a href="https://zehua716.github.io/zh/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://zehua716.github.io/zh/posts/signal_cn/">信号处理</a></div>
    <h1 class="post-title entry-hint-parent">
      无约束优化
    </h1>
    <div class="post-description">
      本内容为Optimisation实验内容，所有代码和结果是和Darwin Wang Cheou 共同完成的
    </div>
    <div class="post-meta">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/all.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/v4-shims.css"><span class="meta-tag"><span class="fa fa-calendar-plus-o"></span>&nbsp;<span title='2024-06-05 16:25:17 +0100 +0100'>6月5日, 2024</span></span>&nbsp; | &nbsp;<span class="meta-tag"><span class="fa fa-file-word-o"></span>&nbsp;<span>共887字</span></span>&nbsp; | &nbsp;<span class="meta-tag"><span class="fa fa-user-circle-o"></span>&nbsp;<span>Zehua</span></span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0" aria-label="问题描述">问题描述</a></li>
                    <li>
                        <a href="#%e5%89%8d%e7%bd%ae%e8%ae%a1%e7%ae%97" aria-label="前置计算">前置计算</a></li>
                    <li>
                        <a href="#%e6%a2%af%e5%ba%a6%e4%b8%8b%e9%99%8d%e6%b3%95" aria-label="梯度下降法"><strong>梯度下降法</strong></a></li>
                    <li>
                        <a href="#%e7%89%9b%e9%a1%bf%e6%b3%95" aria-label="牛顿法"><strong>牛顿法</strong></a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h2 id="问题描述">问题描述<a hidden class="anchor" aria-hidden="true" href="#问题描述">#</a></h2>
<p>我们将先研究Rosenbrock函数的最小化问题，其定义如下：</p>
<p>$$x = (x_1, x_2) \in \mathbb{R}^2\quad  \rightarrow f(x) = (1 - x_1)^2 + 100(x_2 - x_1^2)^2$$</p>
<p>涉及的具体内容如下</p>
<p>(a)  <strong>创建和可视化Rosenbrock函数的二维和三维图像。</strong></p>
<p>(b)  <strong>分析函数的性质，特别是其凸性和优化难度。</strong></p>
<p>(c)  <strong>计算并实现函数的梯度和Hessian矩阵。</strong></p>
<p>(d)  <strong>利用梯度下降法以寻找函数的最小值。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% Creation de la fonction de Rosenbrock</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span> <span class="p">=</span> <span class="p">@</span> <span class="p">(</span> <span class="n">x1</span> <span class="p">,</span> <span class="n">x2</span> <span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x1</span> <span class="p">)</span> <span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">100</span><span class="o">*</span><span class="p">(</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span> <span class="o">.^</span><span class="mi">2</span><span class="p">)</span> <span class="o">.^</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Evaluation de la fonction sur une grille de points</span>
</span></span><span class="line"><span class="cl"><span class="n">x1</span> <span class="p">=</span> <span class="nb">linspace</span> <span class="p">(</span> <span class="o">-</span><span class="mi">2</span> <span class="p">,</span><span class="mi">2</span> <span class="p">,</span><span class="mi">150</span><span class="p">)</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">x2</span> <span class="p">=</span> <span class="nb">linspace</span> <span class="p">(</span> <span class="o">-</span><span class="p">.</span><span class="mi">5</span> <span class="p">,</span><span class="mi">3</span> <span class="p">,</span><span class="mi">150</span><span class="p">)</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">X2</span><span class="p">,</span><span class="n">X1</span><span class="p">]</span> <span class="p">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">x1</span><span class="p">)</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">F</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span> <span class="n">X1</span> <span class="p">,</span> <span class="n">X2</span> <span class="p">)</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Affichage 3D</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span> <span class="p">,</span> <span class="n">surf</span> <span class="p">(</span> <span class="n">x2</span> <span class="p">,</span> <span class="n">x1</span> <span class="p">,</span> <span class="n">F</span> <span class="p">)</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span> <span class="p">(</span><span class="s">&#39;X1&#39;</span><span class="p">)</span> <span class="p">,</span> <span class="n">ylabel</span> <span class="p">(</span><span class="s">&#39;X2&#39;</span><span class="p">)</span> <span class="p">,</span> <span class="n">zlabel</span> <span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span> <span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">shading</span> <span class="n">interp</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">camlight</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="n">tight</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span> <span class="n">jet</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Af fichage 2 D</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span> <span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span> <span class="p">(</span> <span class="n">F</span> <span class="p">)</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span> <span class="n">jet</span> <span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>​	<img src="/img/optimisation/TP_2.png" alt="Optimisation TP 1" width="85%" /></p>
<p align="center">图1：Rosenbrock函数凸性的3D显示</p>
<p>可以注意到，Rosenbrock函数并非严格凸的，有点类似局部凸的感觉，其形状类似倒置的抛物线。随便在这个范围内两个点之间画一条直线，该直线会超出集合的界限。</p>
<p>因此，优化Rosenbrock函数具有一定难度。下降法可能会很容易陷入局部极小值，或在其周围振荡而无法收敛到全局极小值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">figure</span> <span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">contour</span> <span class="p">(</span> <span class="n">x2</span> <span class="p">,</span> <span class="n">x1</span> <span class="p">,</span> <span class="n">F</span> <span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span> <span class="p">(</span><span class="s">&#39;X1&#39;</span><span class="p">)</span> <span class="p">,</span> <span class="n">ylabel</span> <span class="p">(</span><span class="s">&#39;X2&#39;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>​	<img src="/img/optimisation/TP_3.png" alt="Optimisation TP 1" width="85%" /></p>
<p align="center">图2：Rosenbrock函数的等高线图</p>
<p>可以观察到曲线并非均匀分布。它们表示函数的梯度，等高线的密集区域表明梯度更陡（函数值变化更快），而等高线较稀疏的区域表明梯度更缓（函数值变化较慢）。</p>
<h2 id="前置计算">前置计算<a hidden class="anchor" aria-hidden="true" href="#前置计算">#</a></h2>
<p>我们下面计算函数$f$的梯度</p>
<p>$$f(x_1, x_2) = (1 - x_1)^2 + 100(x_2 - x_1^2)^2$$</p>
<p>梯度的表达方式如下：</p>
<p>$$\nabla f(x) = \left( \frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2} \right)$$</p>
<p><strong>计算$\frac{\partial f}{\partial x_1}$：</strong></p>
<p>$$\frac{\partial f}{\partial x_1} = -2 + 2x_1 - 400x_1x_2 + 400x_1^3$$</p>
<p><strong>计算$\frac{\partial f}{\partial x_2}$：</strong></p>
<p>$$\frac{\partial f}{\partial x_2} = 200x_2 - 200x_1^2$$</p>
<p>因此，函数$f$的梯度为：</p>
<p>$$\nabla f(x) = \left( -2 + 2x_1 - 400x_1x_2 + 400x_1^3, ; 200x_2 - 200x_1^2 \right)$$</p>
<p>可以进一步计算Hessian矩阵：</p>
<p>$$
H_f(x) = \begin{pmatrix}2 - 400x_2 + 1200x_1^2 &amp; -400x_1 \\ -400x_1 &amp; 200 \end{pmatrix}
$$</p>
<p>下面我们验证函数在$x^* = (1, 1)$处是否有极值，使其梯度为零：</p>
<p>$$\nabla f(x^*) = 0$$</p>
<p>因此需要解以下系统方程：</p>
<div>$$-2 + 2x _1^* - 400x _1^*x_2^* + 400x _1^{*3} = 0$$</div>
<p>$$
200x_2^* - 200x_1^{*2} = 0
$$</p>
<p>可得到:</p>
<div>$$x_1^{*2} = x_2^*$$</div>
<p><strong>重新排列项后：</strong></p>
<div>$$-2 + 2x_1^* - 400x_1^*x_2^* + 400x_1^{*3} = 0$$</div>
<p><strong>得到平衡点：</strong>
$$
x_1^* = x_2^* = 1
$$</p>
<p>在平衡点 $x^* = (1, 1)$ 处计算Hessian矩阵：</p>
<p>$$
H_f(x) = \begin{bmatrix}
802 &amp; -400 \\
-400 &amp; 200
\end{bmatrix}
$$</p>
<p><strong>我们利用Matlab求解Hessian矩阵的特征值，如果特征值为正，那么可以说明点 $x^{*} = (1, 1)$是一个最小值</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">Hj</span> <span class="p">=</span> <span class="p">[</span><span class="mi">802</span> <span class="o">-</span><span class="mi">400</span><span class="p">;</span> <span class="o">-</span><span class="mi">400</span> <span class="mi">200</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">eig</span><span class="p">(</span><span class="n">Hj</span><span class="p">)</span> <span class="c">% lambda i &gt; 0 donc définie positive donc min local</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\lambda_1 = 0.4
$$</p>
<p>$$
\lambda_2 = 1001.6
$$</p>
<p>因此，两个特征值均为严格正值，表明Hessian矩阵是正定的，点$x^* = (1, 1)$是一个局部最小值。</p>
<p>编程实现梯度 和 Hessian矩阵</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% Le gradient de la fonction f</span>
</span></span><span class="line"><span class="cl"><span class="n">gradf</span> <span class="p">=</span> <span class="p">@</span> <span class="p">(</span> <span class="n">x1</span> <span class="p">,</span> <span class="n">x2</span> <span class="p">)</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x1</span> <span class="o">-</span> <span class="mi">400</span><span class="o">*</span><span class="n">x1</span><span class="o">*</span><span class="n">x2</span> <span class="o">+</span> <span class="mi">400</span><span class="o">*</span><span class="n">x1</span>^<span class="mi">3</span><span class="p">;</span> <span class="mi">200</span><span class="o">*</span><span class="n">x2</span> <span class="o">-</span> <span class="mi">200</span><span class="o">*</span><span class="n">x1</span>^<span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">Gradf</span> <span class="p">=</span> <span class="p">@</span> <span class="p">(</span> <span class="n">x</span> <span class="p">)</span> <span class="n">gradf</span> <span class="p">(</span> <span class="n">x</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">,</span><span class="n">x</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c">% La matrice Hessienne de la fonction f</span>
</span></span><span class="line"><span class="cl"><span class="n">hessf</span> <span class="p">=</span> <span class="p">@</span> <span class="p">(</span> <span class="n">x1</span> <span class="p">,</span> <span class="n">x2</span> <span class="p">)</span> <span class="p">[</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">400</span><span class="o">*</span><span class="n">x2</span> <span class="o">+</span> <span class="mi">1200</span><span class="o">*</span><span class="n">x1</span>^<span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x1</span><span class="p">;</span> <span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x1</span><span class="p">,</span> <span class="mi">200</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">Hessf</span> <span class="p">=</span> <span class="p">@</span> <span class="p">(</span> <span class="n">x</span> <span class="p">)</span> <span class="n">hessf</span> <span class="p">(</span> <span class="n">x</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">,</span><span class="n">x</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>后续我们将比较两种优化方法：一种是经典梯度下降法，另一种是牛顿法。</p>
<h2 id="梯度下降法"><strong>梯度下降法</strong><a hidden class="anchor" aria-hidden="true" href="#梯度下降法">#</a></h2>
<p>梯度下降法是一种迭代优化技术，用于寻找可微函数的最小值。其基本思想是沿着目标函数梯度的反方向移动，因为这一方向可以使函数值下降最快。其过程如下：</p>
<p>(a) <strong>选择初始点$x_0$，该点位于函数定义域内。</strong></p>
<p>(b) <strong>在每次迭代$k$中，计算函数的梯度$\nabla f(x_k)$。</strong></p>
<p>(c) <strong>根据以下规则更新当前点：</strong></p>
<p>$$
x_{k+1} = x_k - \alpha \cdot \nabla f(x_k)
$$</p>
<ul>
<li>其中，$\alpha$是下降步长（学习率），为控制步长大小的正参数。</li>
</ul>
<p>(d) <strong>迭代过程重复，直到梯度足够接近于零（或者达到最大迭代次数）。</strong></p>
<p>(e) <strong>在每次迭代中使用相同的$\alpha$。选择合适的$\alpha$至关重要：步长太大会导致算法震荡甚至发散，而步长太小会减慢收敛速度。</strong></p>
<p>梯度下降法的优点在于其简单易用，并且可以适用于广泛的可微函数和优化问题。然而，它也存在以下缺点：</p>
<ul>
<li>
<p><strong>收敛速度可能较慢，特别是对于类似于 Rosenbrock函数 的问题。</strong></p>
</li>
<li>
<p><strong>不适当的步长选择可能会阻止收敛。</strong></p>
</li>
<li>
<p><strong>对于非凸函数，梯度下降可能陷入局部最小值。</strong></p>
</li>
</ul>
<p><strong>接下来我们将通过编程，在Rosenbrock函数上实现梯度下降法，以确定函数$f$的最小值。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">figure</span><span class="p">,</span> <span class="n">hold</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">contour</span> <span class="p">(</span> <span class="n">x2</span> <span class="p">,</span> <span class="n">x1</span> <span class="p">,</span> <span class="n">F</span> <span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">alpha</span> <span class="p">=</span> <span class="mf">1e-3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">x0</span> <span class="p">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">;</span><span class="mf">2.5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">N</span> <span class="p">=</span> <span class="mf">1e4</span><span class="p">;</span> <span class="c">%10e4;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">fx</span><span class="p">]</span> <span class="p">=</span> <span class="n">descente_gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Gradf</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">,:),</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">,:),</span> <span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="s">&#39;linewidth&#39;</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="p">([</span> <span class="o">-</span><span class="p">.</span><span class="mi">5</span> <span class="mi">3</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">2</span><span class="p">])</span> <span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">function</span><span class="w"> </span>[x, fx] <span class="p">=</span><span class="w"> </span><span class="nf">descente_gradient</span><span class="p">(</span>f, Gradf, N, alpha, x0<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">x</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">fx</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">x0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x0</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nb">i</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">(:,</span><span class="nb">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span><span class="p">(:,</span><span class="nb">i</span><span class="p">)</span> <span class="o">-</span> <span class="n">alpha</span><span class="o">*</span><span class="n">Gradf</span><span class="p">(</span><span class="n">x</span><span class="p">(:,</span><span class="nb">i</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">fx</span><span class="p">(</span><span class="nb">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">i</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>得到以下图像：</strong></p>
<p>​	<img src="/img/optimisation/TP_4.png" alt="Optimisation TP 1" width="85%" /></p>
<p align="center">图3：Rosenbrock函数的梯度下降轨迹（$N = 10^4$）</p>
<p>通过图3可以观察到，轨迹一开始出现了明显的震荡，并向最小值方向下移。下降初期的震荡表明在初始几步中很难找到最佳下降方向，这是由于Rosenbrock函数的特性所致。然而，随着轨迹的推进，震荡逐渐减小，路径变得更加规则。这意味着算法开始逐步收敛至全局最小值，该最小值位于等高线较密集的中心区域。</p>
<p><strong>为了说明迭代次数和步长的重要性，我们尝试不同参数下的下降过程。</strong></p>
<p>首先，将迭代次数从10000减少到1000。</p>
<p>​	<img src="/img/optimisation/TP_5.png" alt="Optimisation TP 1" width="85%" /></p>
<p><strong><p align="center">图4：Rosenbrock函数的梯度下降轨迹（$N = 10^3$）</p></strong></p>
<p>正如预期的那样，将迭代次数从$10^4$减少到$10^3$，明显表明算法没有足够的时间显著接近全局最小值。有限的轨迹强调了迭代次数的重要性。足够的迭代次数是保证梯度下降算法能够正确收敛的关键。也就是说，正确设置迭代次数和下降步长对于确保算法适当的收敛非常重要。</p>
<p>​	<img src="/img/optimisation/TP_6.png" alt="Optimisation TP 1" width="85%" /></p>
<p align="center">图5：Rosenbrock函数的梯度下降轨迹（$N = 10^5$）</p>
<p>几乎没有变化。因为迭代次数过大，算法早就稳定并收敛了，即达到极值了。过高的迭代次数是没有意义的。</p>
<p>现在对于梯度下降轨迹已经分析完了，下面调步长$\alpha$，看看它对算法性能的影响，并理解如何影响优化的稳定性、收敛速度以及精度。</p>
<p>​	<img src="/img/optimisation/TP_7.png" alt="Optimisation TP 1" width="85%" /></p>
<p align="center">图6：Rosenbrock函数的梯度下降轨迹（$\alpha = 10^{-2}$）</p>
<p>轨迹不再收敛，开始震荡并发散。步长$\alpha = 10^{-2}$ 过大，远离最优解。</p>
<p>​	<img src="/img/optimisation/TP_8.png" alt="Optimisation TP 1" width="85%" /></p>
<p align="center">图7：Rosenbrock函数的梯度下降轨迹（$\alpha = 10^{-4}$）</p>
<p>步长$\alpha = 10^{-4}$非常小，算法向最小值的推进极慢，和乌龟一样。</p>
<p><strong>给出最优解</strong></p>
<p>​	<img src="/img/optimisation/TP_9.png" alt="Optimisation TP 1" width="85%" /></p>
<p align="center">图8：Rosenbrock函数的梯度下降轨迹（$\alpha = 10^{-4}, N = 10^5$）</p>
<p>非常漂亮，不需要解释了</p>
<p>然而，我们也可以从另一个角度解释结果，认为需要在步长和迭代次数之间找到一个良好的平衡，以使算法在有限的迭代次数和适当的步长下收敛到最小值，同时避免过多的震荡，从而节省计算成本和时间。</p>
<p>改进方法:</p>
<p>每次迭代中，不仅考虑当前梯度，还要考虑先前迭代的方向，这可以减少震荡并加速收敛。或者结合其他优化方法，例如牛顿法，其利用了 Hessian矩阵来提高收敛速度和精度。</p>
<h2 id="牛顿法"><strong>牛顿法</strong><a hidden class="anchor" aria-hidden="true" href="#牛顿法">#</a></h2>
<p>牛顿法是一种迭代优化技术，用于寻找可导函数的驻点。与梯度下降法不同，牛顿法不仅利用梯度信息，还使用函数曲率信息（Hessian矩阵）来确定下降方向。</p>
<p>其过程如下：</p>
<ul>
<li>
<p>​	<strong>选择一个初始点$x_0$，位于函数定义域内。</strong></p>
</li>
<li>
<p>​	<strong>在每次迭代$k$中，计算函数的梯度$\nabla f(x_k)$和Hessian矩阵$H_f(x_k)$。</strong></p>
</li>
<li>
<p>​	<strong>根据以下规则更新当前点：</strong></p>
<p>$$x_{k+1} = x_k - H_f(x_k)^{-1} \cdot \nabla f(x_k)$$</p>
<ul>
<li>其中，$H_f(x_k)^{-1}$是函数在点$x_k$处的Hessian矩阵的逆矩阵。</li>
</ul>
</li>
<li>
<p><strong>重复该过程，直到梯度足够接近于零或更新步长的范数小于预设阈值。</strong></p>
</li>
</ul>
<p>牛顿法通过利用梯度和曲率信息，让更新更高效、收敛更快。但是，计算成本高，且需要反转Hessian矩阵，并且在函数条件差或非凸时不是很好用。</p>
<p>继续对Rosenbrock函数动手，利用Matlab实现，首先选择$N = 10$和$x_0 = [1.7; 2.7]$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">figure</span><span class="p">,</span> <span class="n">hold</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">contour</span> <span class="p">(</span> <span class="n">x2</span> <span class="p">,</span> <span class="n">x1</span> <span class="p">,</span> <span class="n">F</span> <span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">x0</span> <span class="p">=</span> <span class="p">[</span><span class="mf">1.7</span><span class="p">;</span><span class="mf">2.7</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">N</span> <span class="p">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">fx</span><span class="p">]</span> <span class="p">=</span> <span class="n">descente_Newton</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Gradf</span><span class="p">,</span> <span class="n">Hessf</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">x0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">,:),</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">,:),</span> <span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="s">&#39;linewidth&#39;</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span> <span class="p">([</span> <span class="o">-</span><span class="p">.</span><span class="mi">5</span> <span class="mi">3</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">2</span><span class="p">]);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">function</span><span class="w"> </span>[x, fx] <span class="p">=</span><span class="w"> </span><span class="nf">descente_Newton</span><span class="p">(</span>f, Gradf, Hessf, N, x0<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">x</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">fx</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">x0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x0</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">x0</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nb">i</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">(:,</span><span class="nb">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span><span class="p">(:,</span><span class="nb">i</span><span class="p">)</span> <span class="o">-</span> <span class="n">inv</span><span class="p">(</span><span class="n">Hessf</span><span class="p">(</span><span class="n">x</span><span class="p">(:,</span><span class="nb">i</span><span class="p">)))</span><span class="o">*</span><span class="n">Gradf</span><span class="p">(</span><span class="n">x</span><span class="p">(:,</span><span class="nb">i</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">fx</span><span class="p">(</span><span class="nb">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">i</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>​	<img src="/img/optimisation/TP_10.png" alt="Optimisation TP 1" width="85%" /></p>
<p align="center">图9：$f$的变化与范数$E$关于迭代次数的演变</p>
<p>与梯度下降法类似，轨迹从右上角 向 最优点靠近。</p>
<p>牛顿法显示了快速的收敛，其轨迹表现出其步长较大，这就是使用Hessian矩阵的特性，最终收敛到最小值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">x_star</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">E</span> <span class="p">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_star</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% for   i = 1:N</span>
</span></span><span class="line"><span class="cl"><span class="c">% E(:,i)= norm(x(:,i)-x_star);</span>
</span></span><span class="line"><span class="cl"><span class="c">% end </span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="nb">log10</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="nb">log10</span><span class="p">(</span><span class="n">fx</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Log10(Iteration)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Log10(Valeur de la fonction)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Congergence de la fonction de Rosenbrock&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="nb">log10</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="nb">log10</span><span class="p">(</span><span class="n">E</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Log10(Iteration)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Log10(Norme de x - x*)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Congergence de la fonction de Newton&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Affichage en echelle logarithmique</span>
</span></span><span class="line"><span class="cl"><span class="c">% figure , plot (log10(E(E &gt; eps)));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>​	<img src="/img/optimisation/TP_11.png" alt="Optimisation TP 1" width="85%" /></p>
<p><strong>图9：$f$的变化与范数$E$关于迭代次数的演变</strong></p>
<p align="center">图10：不同初始化条件下解 $x$ 的演变</p>
<p>我们绘制了两个图，用于描述函数$f$和范数$E$随迭代次数的变化。</p>
<p>对于Rosenbrock函数，纵轴表示函数值的对数刻度$\log_{10}$，横轴表示迭代次数的对数刻度$\log_{10}$。可以看到，在大约$10^{0.6}$次迭代后，函数值迅速下降（约4次迭代）。然后曲线趋于稳定，接近$10^{-30}$，表明函数基本收敛到全局最小值。</p>
<p>对于牛顿算法，纵轴表示误差范数$|x - x^<em>|$的对数刻度（$\log_{10}$），横轴表示迭代次数的对数刻度（$\log_{10}$）。可见误差范数随着迭代次数迅速下降，显示出算法的 快速收敛 性，因为通过利用Hessian矩阵加速了向最优解的下降。最后稳定在极低的值（$10^{-15}$），这表明$x$与$x^</em>$之间的误差几乎为零，显示牛顿法精确地收敛到最优解。</p>
<p>可见牛顿法在优化Rosenbrock函数时非常不错，快速且精确</p>
<p>​	<img src="/img/optimisation/TP_12.png" alt="Optimisation TP 1" width="85%" /></p>
<p align="center">图10：不同初始化条件下解 $x$ 的演变</p>
<p>我们从三个不同初始点（分别用红色、蓝色和绿色表示）来出发并显示它的轨迹。它们最终收敛到不同的点，但是距离非常接近，特别是绿色和蓝色。这表明牛顿法到达局部最小值或非常接近全局最小值的能力。即使初始条件不同，但是我们可能获得同样的最优解结果，这让初始点的策略选择变得不那么紧张了。</p>
<p>为增强牛顿法的鲁棒性，可以使用技术来稳定Hessian矩阵，或者将算法与线搜索方法结合，不过还是那句话，时代变了，当模型又高纬又复杂，直接上神经网络，近似 Hessian 矩阵或其逆 $H^{-1}$。或者动态学习每一步的最优步长 $\alpha_k$，不用自己纠结选步长。</p>
<p>或者直接暴力一点，传统优化算法都不要了，直接学习一个端到端的优化器，它通过输入 函数的梯度或样本点，直接输出下一步的迭代结果，比如用RNN（递归神经网络）学习迭代规则：
$$
x_{k+1} = \text{RNN}(x_k, \nabla f(x_k), H_f(x_k))
$$
但是一般没有足够的数据。</p>
<p>综上所述，梯度下降法可能收敛速度慢，步长选择要求高。此外，对于局部凸函数，梯度下降法容易陷入局部极小值。因此，牛顿法更适合用于优化Rosenbrock这样的函数，收敛快速且精确，并且对局部凸函数表现良好。然而，牛顿法也有局限性，即计算Hessian矩阵逆的高昂成本。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://zehua716.github.io/zh/posts/signal_cn/%E5%BA%94%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E4%BF%A1%E9%81%93%E5%9D%87%E8%A1%A1%E9%97%AE%E9%A2%98/">
    <span class="title">« 上一页</span>
    <br>
    <span>应用随机梯度算法解决信道均衡问题</span>
  </a>
  <a class="next" href="https://zehua716.github.io/zh/posts/signal_cn/%E5%9F%BA%E4%BA%8E%E5%88%B0%E5%A2%99%E5%A3%81%E8%B7%9D%E7%A6%BB%E6%B5%8B%E9%87%8F%E7%9A%84%E5%AE%9A%E4%BD%8D/">
    <span class="title">下一页 »</span>
    <br>
    <span>基于到墙壁距离测量的定位</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod</a></span> · 


    <span>
        
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a>  
        
    </span>
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <br>
    <span id="busuanzi_container_page_pv" style='display:none'>
        一共有<span id="busuanzi_value_page_pv"></span>人来过这里
    </span>
    · <span id="last_change">
        最后更新于2024年11月24日
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
