<!DOCTYPE html>
<html lang="zh" dir="ltr">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>		反问题 TP1 | 主页</title>
<meta name="keywords" content="信号处理, 图像处理">
<meta name="description" content="图像恢复中去卷积问题">
<meta name="author" content="Zehua">
<link rel="canonical" href="https://zehua716.github.io/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98tp1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b034bcbdc85c0327c027f6017d1f68525aa9b776bc91764ea833287e3d66c8da.css" integrity="sha256-sDS8vchcAyfAJ/YBfR9oUlqpt3a8kXZOqDMofj1myNo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zehua716.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zehua716.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zehua716.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zehua716.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zehua716.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://zehua716.github.io/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98tp1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
    integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
    integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
    integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    }); 
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet"><meta property="og:title" content="		反问题 TP1" />
<meta property="og:description" content="图像恢复中去卷积问题" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zehua716.github.io/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98tp1/" />
<meta property="og:image" content="https://zehua716.github.io/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-11-05T16:25:17+01:00" />
<meta property="article:modified_time" content="2024-11-06T17:12:35+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://zehua716.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="		反问题 TP1"/>
<meta name="twitter:description" content="图像恢复中去卷积问题"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://zehua716.github.io/zh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "信号处理",
      "item": "https://zehua716.github.io/zh/posts/signal_cn/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "\t\t反问题 TP1",
      "item": "https://zehua716.github.io/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98tp1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "\t\t反问题 TP1",
  "name": "\t\t反问题 TP1",
  "description": "图像恢复中去卷积问题",
  "keywords": [
    "信号处理", "图像处理"
  ],
  "articleBody": "图像反卷积：Wiener-Hunt 方法 主要针对图像去模糊问题，即从模糊(带噪)图像中恢复清晰图像。这属于逆问题的范畴，一半出现在处理真实测量系统时。由于每个测量系统（如温度计、CCD相机、光谱仪等）都受到基础物理学的限制，比如有限精度、有限动态范围、非零响应时间等。这意味着测得的量或多或少都有扭曲。因此这部分是对感兴趣物理量的某种扭曲程度的度量。\n大多数情况下，测量系统直接给出的测量数据通常具有足够的精度和鲁棒性。但是，也存在测量结果不准确的情况。为了解决精度问题，或者说至少部分地优化它，已经开发了特殊的信号和图像处理技术。在接下来的内容中，我们将通过一个简单的例子来展示此类方法。\n我们有一张未聚焦的图像。这种情况下，点的图像实际上会是一个斑点。捕获的图像将会因为模糊而受损，因为它是由真实图像中每个点生成的斑点的叠加结果。\n描述这种转换的最简单模型是线性不变滤波器，即卷积。示意图如下图所示。\n在上面的示意图中， $x_{n,m}$ 代表真实或原始图像，$y_{n,m}$ 代表观测到的图像，或者更确切地说，是我们通过相机拍到的未聚焦图像。添加分量 $b_{n,m}$ 是为了考虑测量和建模误差。\n描述测量过程的方程(二维)如下：\n$$ y_{n,m} = \\sum_{p=-P}^{P} \\sum_{q=-Q}^{Q} h_{p,q} x_{n-p,m-q} + b_{n,m} $$\n$y_{n,m}$ 是对于每个观测到的像素 $(n, m)$ 。在这个公式中，$P$ 和 $Q$ 是给定的整数。\n注意，滤波器通常来说都是低通滤波器，这就意味着它们无法准确地在输出中再现输入信号或图像中的所有分量，因为高频分量要么被强烈衰减，要么完全被拒绝，这也就是为什么 ‘‘恢复真实信号’‘或者说’‘图像的逆问题’’ 是如此困难：必须恢复那些要么完全不存在、要么“错误”观测到的高频分量。\n在下面的例子中，我们用线性方法来解决图像反卷积问题。这些线性方法依赖于最小二乘准则，并结合了二次惩罚。我们先介绍其理论部分，包括这些准则及其最小化器。此外，展示背后的技术细节，并提出了一种基于循环近似的方法，以实现快速的数值计算。\n1. 一维反卷积 为了简化理论概念，我们先讨论在一维情况下的信号反卷积。这种简化情况允许对反卷积问题的分析更加深入，同时更容易掌握概念和思路。随后再引入二维情况，并将其视为一维情况的扩展。Matlab 实现部分仅涉及二维情况。\n1.1 一维建模 在一维情况下，(1) 中给出的观测模型变为：\n$$ y_n = \\sum_{p=-P}^{P} h_p x_{n-p} + b_n $$\n如果我们有 $N$ 个样本，可以将相应的 $N$ 个方程写成矩阵形式：\n$$ \\mathbf{y} = \\mathbf{H} \\mathbf{x} + \\mathbf{b} $$\n​\t•\t向量 $\\mathbf{y}$ 包含了所有的 $N$ 个观测值（在二维情况下，它将包含模糊的图像）\n​\t•\t向量 $\\mathbf{x}$ 包含了恢复图像的样本，而 $\\mathbf{b}$ 是噪声样本。\n​\t•\t矩阵 $\\mathbf{H}$ ，称为模糊矩阵，具有以下经典结构：\n$$ H = \\begin{bmatrix} h_P \u0026 \\cdots \u0026 h_0 \u0026 \\cdots \u0026 h_{-P} \u0026 0 \u0026 0 \u0026 0 \u0026 \\cdots \\\\ 0 \u0026 h_P \u0026 \\cdots \u0026 h_0 \u0026 \\cdots \u0026 h_{-P} \u0026 0 \u0026 0 \u0026 \\cdots \\\\ 0 \u0026 0 \u0026 h_P \u0026 \\cdots \u0026 h_0 \u0026 \\cdots \u0026 h_{-P} \u0026 0 \u0026 \\cdots \\\\ 0 \u0026 0 \u0026 0 \u0026 h_P \u0026 \\cdots \u0026 h_0 \u0026 \\cdots \u0026 h_{-P} \u0026 \\cdots \\\\ \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \\end{bmatrix} $$\n​\t•\t$\\mathbf{H}$ 是一个 $N \\times N$ 的方阵，并且具有 Toeplitz 结构。\n因此，信号反卷积问题可以重新表述为: 在已知观测信号 $\\mathbf{y}$ 并知道卷积矩阵 $H$ 的情况下，估计向量 $\\mathbf{x}$\n1.2 带惩罚的最小二乘法 提出的重建策略 (损失函数) 是一种带惩罚的最小二乘法。它包含两个部分：\n​\t•\t一个重构损失项，用于量化恢复信号 $\\mathbf{x}$ 与观测信号 $\\mathbf{y}$ 进行重新卷积后的相似性，从而确保恢复的信号与观测信号一致。\n​\t•\t一个惩罚项，用于限制恢复信号的连续样本之间的差异，确保其具有一定的规则性结构。\n该准则采用以下表达式：\n$$ J_{\\text{PLS}}(x) = | y - Hx |^2 + \\mu | Dx |^2 = (y - Hx)^t (y - Hx) + \\mu x^t D^t D x $$\n其中，$D$ 是阶数为 1，大小为 $(N - 1) \\times N$ 的差分矩阵，定义如下：\n$$ D = \\begin{bmatrix} \\cdots \u0026 -1 \u0026 1 \u0026 0 \u0026 0 \u0026 \\cdots \\\\ \\cdots \u0026 0 \u0026 -1 \u0026 1 \u0026 0 \u0026 \\cdots \\\\ \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \\\\ \\cdots \u0026 0 \u0026 0 \u0026 -1 \u0026 1 \u0026 \\cdots\\\\ \\end{bmatrix} $$\n带惩罚的最小二乘准则的最小化器为：\n$$ \\hat{x} = (H^t H + \\mu D^t D)^{-1} H^t y $$\n证明:\n$$ \\hat{x} = (H^T H + \\mu D^T D)^{-1} H^T y $$\n我们已知损失准则为:\n$$ J_{\\text{PLS}}(x) = y^T y - 2x^T H^T y + x^T H^T H x + \\mu x^T D^T D x $$\n求偏导为0:\n$$ \\hat{x} = (H^T H + \\mu D^T D)^{-1} H^T y $$\n特殊情况：\n在特定情况下 $\\mu = 0$ 时准则和最小化器的结果表达式变为 $J_{\\text{PLS}}(x) = |y - Hx|^2$\n最小化器方程为：\n$$ \\hat{x} = (H^T H)^{-1} H^T y $$\n此时准则变为经典的最小二乘问题，没有正则化项，也就是说，模型仅考虑最小化观测值与预测值之间的误差，而不会惩罚解的复杂度或平滑性。其解是经典的 最小二乘解。\n1.2.1 循环近似 回到公式 (9) ，我们已知矩阵 $H^T H + \\mu D^T D$ 的大小为 $N \\times N$ ，当 $N$ 很大时，这种反演在计算上非常昂贵甚至不可行。\n比如说在处理图像时，比如对于 $1000 \\times 1000$ 的图像，矩阵的大小为 $10^6 \\times 10^6$ ，计算不了。在三维情况下，更复杂。\n因此为了计算 $\\hat{x}$ ，有几种方法可以克服这种大计算量的困难。\n下面我们考虑使用循环矩阵的特性，因为我们可以用对角矩阵来 “替换” 公式 (9) 中的矩阵 (通过快速傅里叶变换 FFT 可以将循环矩阵 “转化”为对角矩阵)。因此，使用对角矩阵进行计算时，乘法或反演等矩阵运算的复杂度将大大降低。\n但是，这需要先将矩阵 $H$ 和 $D$ 近似为循环矩阵 $\\tilde{H}$ 和 $\\tilde{D}$ 。\n循环近似涉及修改矩阵的右上角和/或左下角部分，使其具有循环结构。这种近似的核心假设是信号或图像在开始和结束部分是周期性的，即信号的末尾与开头相连接，形成一个环状结构。\n循环卷积矩阵 $\\tilde{H}$ 和 $\\tilde{D}$ 在傅里叶基下可以轻松对角化：\n$$ \\tilde{H} = F^T \\Lambda_h F \\quad \\text{和} \\quad \\tilde{D} = F^T \\Lambda_d F $$\n矩阵 $\\Lambda_h$ 是对角矩阵，其对角线上元素是 $H$ 的特征值。\n特征值可以通过对矩阵 $H$ 第一行进行快速傅里叶变换（FFT）获得，即计算脉冲响应的 $N$ 点 FFT，这些响应代表频率响应的样本。\n同样适用于矩阵 $\\tilde{D}$ 及其特征值，其中将脉冲响应替换为 $[-1, 1]$。\n通过在 (9) 中用 (18) 代替，并使用简单的矩阵操作，可以得到：\n$$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h} + \\mu \\Lambda_{d}^{\\dagger} \\Lambda_{d})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n在此基础上再进一步:\n$$ \\overset{\\circ}{\\hat{x}} = \\left[ \\Lambda_h^{\\dagger} \\Lambda_h + \\mu \\left( \\Lambda_{d_c}^{\\dagger} \\Lambda_{d_c} + \\Lambda_{d_r}^{\\dagger} \\Lambda_{d_r} \\right) \\right] \\Lambda_h^{\\dagger} \\dot{\\mathbf{y}} $$\n1 FT_x = 1 ./ (abs(Lambda_H).^2 + mu * (abs(Lambda_dC).^2 + abs(Lambda_dR).^2)).* (conj(Lambda_H).* FT_Data); ​\t$\\Lambda_h \\Rightarrow$ FT_IR = MyFFT2RI(IR, 256);\n​\t$\\Lambda_{d_c} \\Rightarrow$ FT_Dc = MyFFT2RI(Dc, 256);\n​\t$\\Lambda_{d_r} \\Rightarrow$ FT_Dr = MyFFT2RI(Dr, 256);\n回顾性质:\n$$ \\Lambda_H^{+} = (\\Lambda_H^T)^{} = \\Lambda_H^{} = \\operatorname{conj}(\\Lambda_H) $$\n因此有:\n$$ \\Lambda_H^{+} \\cdot \\Lambda_H = \\Lambda_H^{*} \\cdot \\Lambda_H = |\\Lambda_H|^2 $$\n证明：\n$$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h} + \\mu \\Lambda_{d}^{\\dagger} \\Lambda_{d})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n补充知识: $\\tilde{H}$ 是一个实矩阵，因此其复共轭等于它本身，$\\tilde{H} = \\tilde{H}^T$ 。$\\tilde{D}$ 同理\n在近似为循环矩阵后，公式 (15) 变为:\n$$ \\hat{x} = (\\tilde{H}^{T}\\tilde{H} + \\mu \\tilde{D}^{T}\\tilde{D})^{-1}\\tilde{H}^{T}y $$\n其中: $\\tilde{H} = F^T \\Lambda_h F$ 且 $\\tilde{D} = F^T \\Lambda_d F$ 将其带入上述公式，得:\n$$ \\hat{x} = ((F^{T}\\Lambda_{h}F)^{T}(F^{T}\\Lambda_{h}F) + \\mu (F^{T}\\Lambda_{d}F)^{T}(F^{T}\\Lambda_{d}F))^{-1}(F^{T}\\Lambda_{h}F)^{T}y $$\n因为傅里叶矩阵 $F$ 是一个正交矩阵，具有 $F F^{T} = I$ 的性质，即 $F^{T} = F^{-1}$\n并且我们有 $(F^{T}\\Lambda_{h}F)^{T} = F^{T}\\Lambda_{h}^{T}F$ 以及 $(F^{T}\\Lambda_{d}F)^{T} = F^{T}\\Lambda_{d}^{T}F$\n所以:\n令 $\\quad \\overset{\\circ}{\\hat{x}} = F \\hat{x}, \\quad \\overset{\\circ}{y} = F y$\n那么:\n$$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h} + \\mu \\Lambda_{d}^{\\dagger} \\Lambda_{d})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n证毕。\n特殊情况：\n当 $\\mu = 0$ 时，正则化项消失，公式简化为：\n$$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n这意味着我们仅仅执行了经典的 Wiener 去卷积，没有考虑图像的正则化。\n$$\\hat{x} = (\\tilde{H}^{T}\\tilde{H} )^{-1}\\tilde{H}^{T}y\\ $$\n没有正则化时，虽然理论上可以恢复原始信号，但是实际上收到的噪声影响很大，且没有约束来将其消除\n为了完成我们的讨论，我们首先构建向量 $g_{\\text{PLS}}$ ，其分量定义如下：\n$$ g_{PLS}^{n} = \\frac{\\overset{\\circ}{h}_{n}^{*}}{|\\overset{\\circ}h_n|^2 + \\mu |\\overset{\\circ}d_n|^2}\\quad \\text{for } n = 1, 2, \\dots, N $$\n因此，向量 $\\overset{\\circ}{\\hat{x}}$ 是通过向量 $g_{\\text{PLS}}$ 和 $\\overset{\\circ}{\\hat{y}}$ 之间逐元素相乘得到的：\n$$ \\overset{\\circ}{\\hat{x}} = g_{\\text{PLS}} .* \\overset{\\circ}{\\hat{y}} $$\n反卷积问题可以表述为在傅里叶域中进行的滤波操作，其中 $g_{\\text{PLS}}$ 代表离散传递函数。\n反卷积问题总结如下：\n​\t•\t① 构建 $\\mathring{h}$ 作为脉冲响应的 $N$ 点 FFT\n​\t•\t② 构建 $\\mathring{d}$ 作为 $[1; -1]$ 的 $N$ 点 FFT\n​\t•\t③ 构建包含传递函数 $g_{\\text{PLS}}$ 的向量\n​\t•\t④ 构建观测值的 FFT $\\mathring{y}$\n​\t•\t⑤ 计算 $\\mathring{\\hat{x}}$ ，作为传递函数 $g_{\\text{PLS}}$ 和 $\\mathring{\\hat{y}}$ 的乘积\n​\t•\t⑥ 计算 $\\mathring{\\hat{x}}$ 的 IFFT 以在空间域中获得解 $\\hat{x}$\n2 实现 2.1 二维方法 对于二维情况，其方程类似于一维情况。但是，所涉及的block-Tœplitz矩阵结构更加复杂: 每个块本身也具有 Tœplitz 结构。这使得在两个方向上进行循环近似变得更加困难。因此，二维情况仅作为一维情况的扩展来展示，重点是 Matlab 实现，理论部分暂不讨论。\n注意以下几点：\n​\t•\t图像、脉冲响应、正则化项都是二维的，这意味着必须使用 FFT-2D 而不是 FFT。\n​\t•\t更确切地说，如果要恢复的图像有 $N$ 行和 $N$ 列，那么 FFT-2D 必须在 $N$ 行和 $N$ 列上计算。\n​\t•\t频率传递函数也是二维的，每个空间频率有一个维度。\n特别说明 — 在任何情况下，矩阵 $H$ 和 $D$ 都不应在 Matlab 代码中构建。\n2.2 观测图像 ​\t•\t第一步是加载数据 Data1 和 Data2 。使用 load 函数来完成。每个数据文件内部包含：模糊图像 (Data)、用于比较的真实图像 (TrueIma)，以及卷积滤波器的脉冲响应 (IR)。现在分析每个数据集及其相互关系。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 clear all close all clc %% Load Data Data1 = load('DataOne.mat') Data2 = load('DataTwo.mat') % Create a window to display the image figure() subplot(1,2,1) % Display the image, grayscale imagesc(Data1.Data); colormap('gray'); % Scale the axes and eliminate the grading axis('square','off') title('Observed Image - Data1'); subplot(1,2,2) % Display the image, grayscale imagesc(Data2.Data); colormap('gray'); % Scale the axes and eliminate the grading axis('square','off') title('Observed Image - Data2'); 两观测图像都有明显的模糊，具体是边缘和结构细节处。这种模糊表明图像中的高频信息被卷积或散射了，导致图像细节的丢失，这就是由于卷积效应或低通滤波的影响而造成的。\n​\t•\t为了进一步分析，肯定要到频域看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 %% Analyse the images in the frequency domain (linear and a logarithmic scale) % % Get the sizes of the images % [M1,N1] = size(Data1.Data); % [M2,N2] = size(Data2.Data); % % Generate frequency axes for Data1 % u1 = (-M1/2:M1/2-1)/M1; % Normalized frequencies in y-direction % v1 = (-N1/2:N1/2-1)/N1; % Normalized frequencies in x-direction % % Generate frequency axes for Data2 % u2 = (-M2/2:M2/2-1)/M2; % v2 = (-N2/2:N2/2-1)/N2; % Generate normalized frequency axes using linspace Nu = linspace(-0.5, 0.5, 256); % Compute the 2D FFT of observed images and shift zero frequency to center FFT_Data1 = MyFFT2(Data1.Data); FFT_Data2 = MyFFT2(Data2.Data); % Magnitude spectra Mag_Data1 = abs(FFT_Data1) Mag_Data2 = abs(FFT_Data2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 % Display magnitude spectra in linear scales figure(); subplot(1,2,1) imagesc(Nu,Nu,Mag_Data1); % Use frequency axes v1 and u1 xlabel('X'); ylabel('Y'); colormap('gray'); title('Magnitude (Linear Scale) - Data1'); subplot(1,2,2) imagesc(Nu,Nu,Mag_Data2); % Use frequency axes v2 and u2 xlabel('X'); ylabel('Y'); colormap('gray'); title('Magnitude (Linear Scale) - Data2'); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 % Display magnitude spectra in logarithmic scales figure; subplot(1,2,1) imagesc(Nu,Nu,log(1+Mag_Data1)); % Use log scale xlabel('X'); ylabel('Y'); colormap('gray'); title('Magnitude (logarithmic Scale) - Data1'); subplot(1,2,2) imagesc(Nu,Nu,log(1+Mag_Data2)); xlabel('X'); ylabel('Y'); colormap('gray'); title('Magnitude (logarithmic Scale) - Data2'); 可见只有两组频谱图的中心部分有强烈亮度，即低频分量较强，即图像大范围平滑信息较多，而高频部分的细节没有\n​\t•\t我们继续看两个脉冲响应 $h_{n,m}$ 及其关联的传递函数 $H(\\nu_x, \\nu_y)$ 。首先使用 imagesc 函数，然后使用 plot 函数来进行分析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 %% Calcul impulse responses and associated transfer functions using impulse % Load the impulse responses IR1 = Data1.IR; IR2 = Data2.IR; % Display the impulse responses figure; subplot(1,2,1) imagesc(IR1); colormap('gray'); title('Impulse Response - IR1'); subplot(1,2,2) imagesc(IR2); colormap('gray'); title('Impulse Response - IR2'); % Compute and display the transfer functions Long = 256; H1 = MyFFT2RI(IR1, Long); H2 = MyFFT2RI(IR2, Long); % Compute the magnitude spectra Mag_H1 = abs(H1); Mag_H2 = abs(H2); % Display the transfer functions using imagesc figure; subplot(1,2,1) imagesc(Nu, Nu, Mag_H1); xlabel('X'); ylabel('Y'); title('Transfer Function Magnitude - H1'); colormap('gray'); subplot(1,2,2) imagesc(Nu, Nu, Mag_H2); xlabel('X'); ylabel('Y'); title('Transfer Function Magnitude - H2'); colormap('gray'); 很明显，IR1 和 IR2 都是低通滤波器，只允许低频分量通过，高频分量进行衰减或完全抑制。IR1 的传递函数 H1 的分布更加平滑，说明它对低频分量的保留更为均匀。IR2 的滤波特性更倾向于选择性地保留某些低频分量，而非均匀地平滑整个低频区域。因此，相较于 IR1，IR2 对图像的细节影响更强。不过这么看看不出来具体的道道儿，还是得看下面的切片。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 %% Plot slices through the transfer functions using plot % Midpoint index (since Long = 256) mid_index = Long / 2 + 1; % This will be 129 % Plot slices for H1 figure; subplot(2,1,1) plot(Nu, Mag_H1(mid_index, :)); xlabel('Normalized Frequency X'); ylabel('Magnitude'); title('Transfer Function along Central Row - H1'); grid on; subplot(2,1,2) plot(Nu, Mag_H1(:, mid_index)); xlabel('Normalized Frequency Y'); ylabel('Magnitude'); title('Transfer Function along Central Column - H1'); grid on; 可见前面的结论是正确的，H1 幅值响应曲线变化相对平滑，适合图像整体的模糊处理任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 % Plot slices for H2 figure; subplot(2,1,1) plot(Nu, Mag_H2(mid_index, :)); xlabel('Normalized Frequency X'); ylabel('Magnitude'); title('Transfer Function along Central Row - H2'); grid on; subplot(2,1,2) plot(Nu, Mag_H2(:, mid_index)); xlabel('Normalized Frequency Y'); ylabel('Magnitude'); title('Transfer Function along Central Column - H2'); grid on; 在 H2 的切片图中，幅值响应曲线有更明显的周期性波动，适合特定方向的模糊或增强效果。\n2.3 Implementation 我们将在二维情况下实现反卷积，并使用带有二次惩罚项的最小二乘法，同时使用循环近似进行最小化，在前面已经进行过了总结。\n关于正则化项，它依赖于图像列和行上相邻像素之间的差异。其表达式为：\n$$ | D x |^2 = \\sum_{n,m} (x_{n,m} - x_{n,m+1})^2 + (x_{n,m} - x_{n+1,m})^2 $$\n​\t•\t正则化项 $| D x |^2$ 代表了水平方向和垂直方向相邻像素值的平方差之和。\n因此它将基于两个滤波器(水平和垂直)来实现：\n$$ D_{horiz} = \\begin{bmatrix} 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 -1 \u0026 1 \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} \\quad D_{vert} = \\begin{bmatrix} 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 -1 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \\end{bmatrix} $$\n这两个滤波器分别计算行和列上像素之间的差异。\n当然也可以从以下脉冲响应滤波器中选一个，它们都可以实现图像梯度的近似。\n$$ \\begin{bmatrix} 0 \u0026 -1 \u0026 0 \\\\ -1 \u0026 4 \u0026 -1 \\\\ 0 \u0026 -1 \u0026 0 \\end{bmatrix} \\quad \\text{或} \\quad \\begin{bmatrix} -1 \u0026 -1 \u0026 -1 \\\\ -1 \u0026 8 \u0026 -1 \\\\ -1 \u0026 -1 \u0026 -1 \\end{bmatrix} \\quad \\text{或} \\quad \\begin{bmatrix} 1 \u0026 -2 \u0026 1 \\\\ -2 \u0026 4 \u0026 -2 \\\\ 1 \u0026 -2 \u0026 1 \\end{bmatrix} $$\n回顾前面，我们得到：\n$$ \\hat{x} = (H^{T}H + \\mu D^{T}D)^{-1}H^{T}y $$\n现在进行傅里叶变换下的去卷积\n$$ \\hat{x}(\\nu_{x}, \\nu_{y}) = \\frac{\\hat{H}^{*}(\\nu_{x}, \\nu_{y}) \\hat{y}(\\nu_{x}, \\nu_{y})}{|\\hat{H}(\\nu_{x}, \\nu_{y})|^2 + \\mu |\\hat{D}(\\nu_{x}, \\nu_{y})|^2} $$\n​\t•\t$\\hat{H}(\\nu_{x}, \\nu_{y})$ 是卷积矩阵的傅里叶变换\n​\t•\t$\\hat{D}(\\nu_{x}, \\nu_{y})$ 是差分矩阵的傅里叶变换\n​\t•\t$\\hat{x}(\\nu_{x}, \\nu_{y})$ 是频域中的恢复图像\n我们先写一个反卷积函数，将观测数据 (Data)、脉冲响应 (IR) 和正则化参数 (mu) 作为输入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 function [x] = deconvolve_image(Data,IR,mu) Long = length(Data); Nu = linspace(-0.5, 0.5, Long); TF_Data = MyFFT2(Data); TF_IR = MyFFT2RI(IR,Long); % figure(1) % subplot(2, 1, 1) % imagesc(Nu, Nu, abs(TF_IR)) % title('Frequency response') % xlabel('\\nu_x') % ylabel('\\nu_y') % axis square % subplot(2, 1, 2) % plot(Nu, abs(TF_IR(round(length(TF_IR)/2), :))) % Define the regularization filters (difference operators) % Horizontal difference filter Dh = [0 0 0; 0 -1 1; 0 0 0]; % Vertical difference filter Dv = [0 0 0; 0 -1 0; 0 1 0]; % Compute the FFTs of the regularization filters using MyFFT2RI TF_Dh = MyFFT2RI(Dh, Long); TF_Dv = MyFFT2RI(Dv, Long); % Compute |Dh|^2 and |Dv|^2 abs_Dh_squared = abs(TF_Dh).^2; abs_Dv_squared = abs(TF_Dv).^2; % Total regularization term |D|^2 = |Dh|^2 + |Dv|^2 abs_D_squared = abs_Dh_squared + abs_Dv_squared; % Compute the denominator of the Wiener filter denom = abs(TF_IR).^2 + mu * abs_D_squared; % Compute the numerator numerator = conj(TF_IR) .* TF_Data; % Compute X_hat in the frequency domain TF_X = numerator ./ denom; % Compute the inverse FFT to get the deconvolved image % Since MyFFT2 uses fftshift, we need to use ifftshift before ifft2 x = MyIFFT2(TF_X); end ​\t•\t然后应用这个逆卷积函数，查看反卷积后的图像去噪效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 %% Question 5 mu = 0.004; % Deconvolve Data1 x_1 = deconvolve_image(Data1.Data, Data1.IR, mu); % Display the deconvolved image figure; subplot(1,2,1) % Display the image, grayscale imagesc(Data1.Data); colormap('gray'); % Scale the axes and eliminate the grading axis('square','off') title(['Observed Image - Data1, \\mu = ', num2str(mu)]); subplot(1,2,2) imagesc(x_1); colormap('gray'); title(['Deconvolved Image - Data1, \\mu = ', num2str(mu)]); axis('square','off') % Deconvolve Data2 x_2 = deconvolve_image(Data2.Data, Data2.IR, mu); % Display the deconvolved image figure; subplot(1,2,1) % Display the image, grayscale imagesc(Data2.Data); colormap('gray'); % Scale the axes and eliminate the grading axis('square','off') title(['Observed Image - Data2, \\mu = ', num2str(mu)]); subplot(1,2,2) imagesc(x_2); colormap('gray'); title(['Observed Image - Data2, \\mu = ', num2str(mu)]); axis('square','off') 可见效果挺理想，但是之前这个 $\\mu$ 是随便设的，现在探讨这个 $\\mu$ 值对结果的影响。\n​\t•\t首先考虑简单的逆滤波器情况，即 $\\mu = 0$ 。\n前面我们得到： $\\hat{x} = (H^{T}H + \\mu D^{T}D)^{-1}H^{T}y$\n现在变成： $\\hat{x} = (H^{T}H)^{-1}H^{T}y$\n$$ \\hat{x}(\\nu_{x}, \\nu_{y}) = \\frac{\\hat{H}^{*}(\\nu_{x}, \\nu_{y}) \\hat{y}(\\nu_{x}, \\nu_{y})}{|\\hat{H}(\\nu_{x}, \\nu_{y})|^2 } $$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 %% Question 6 Simple Inverse Filter (μ = 0) mu = 0; % Deconvolve Data1 x_1 = deconvolve_image(Data1.Data, Data1.IR, mu); % Display the deconvolved image figure; subplot(1,2,1) % Display the image, grayscale imagesc(Data1.Data); colormap('gray'); % Scale the axes and eliminate the grading axis('square','off') title(['Observed Image - Data1, \\mu = ', num2str(mu)]); subplot(1,2,2) imagesc(x_1); colormap('gray'); title(['Deconvolved Image - Data1, \\mu = ', num2str(mu)]); axis('square','off') 由于 $\\mu = 0$ 等价于丢失了正则化项，反卷积结果会直接依赖于卷积核 $H$ 的傅里叶系数 $|\\hat{H}(\\nu_{x}, \\nu_{y})|^2$ ，如果 $H$ 的某些频率分量（尤其是高频）接近零，那么在这些频率上，分母 $|\\hat{H}(\\nu_{x}, \\nu_{y})|^2$ 会非常小，导致反卷积结果中放大这些频率分量的噪声。反卷积图像中可以看到明显的颗粒状噪声。这是由于直接逆滤波在某些频率分量上产生了极大值，放大了噪声。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 % Deconvolve Data2 x_2 = deconvolve_image(Data2.Data, Data2.IR, mu); % Display the deconvolved image figure; subplot(1,2,1) % Display the image, grayscale imagesc(Data2.Data); colormap('gray'); % Scale the axes and eliminate the grading axis('square','off') title(['Observed Image - Data2, \\mu = ', num2str(mu)]); subplot(1,2,2) imagesc(x_2); colormap('gray'); title(['Observed Image - Data2, \\mu = ', num2str(mu)]); axis('square','off') ​\t•\t我们因此取不同的 $\\mu$ 值(在 $\\log_{10}$ 刻度上取值)。并且根据结果，确定合适的 $\\mu$ 值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 %% Effect of Varying μ on Deconvolution Results % Define a range of mu values on a log scale mu_values = logspace(-11, 0, 12); % From 1e-10 to 1 % Deconvolution and display for Data1 figure('Name', 'Deconvolution Results for Data1'); for i = 1:length(mu_values) mu = mu_values(i); x_1 = deconvolve_image(Data1.Data, Data1.IR, mu); subplot(3,4,i); imagesc(x_1); colormap('gray'); axis('square','off'); title(['\\mu = ', num2str(mu, '%.1e')]); end sgtitle('Deconvolved Images - Data1 with Different \\mu Values'); 1 2 3 4 5 6 7 8 9 10 11 12 13 % Deconvolution and display for Data2 figure('Name', 'Deconvolution Results for Data2'); for i = 1:length(mu_values) mu = mu_values(i); x_2 = deconvolve_image(Data2.Data, Data2.IR, mu); subplot(3,4,i); imagesc(x_2); colormap('gray'); axis('square','off'); title(['\\mu = ', num2str(mu, '%.1e')]); end sgtitle('Deconvolved Images - Data2 with Different \\mu Values'); 小的 $\\mu$ 值时，可见图像噪声多，甚至都有可能完全被噪声埋没; 中等 $\\mu$ 值 时，图像细节和噪声之间达到了较好的平衡; 当 $\\mu$ 值过大时，图像变得过于平滑，细节逐渐丢失，尤其是当 $\\mu = 1$ 时。我们目前只能通过视觉方法来选出较好的 $\\mu$ 值，两数据最优 $\\mu$ 值都大约等于 0.01，但是这样肯定是不行的，是不严谨的，是无法成为一名科研奇才的，因此我们和真实图像做数学比较。\n2.4 超参数的作用\n上一点使我们能够评估与反卷积问题相关的内在难度。它还表明，考虑重建图像期望正则性的先验信息可以获得更好的结果。这种方法因此使我们能够在两种信息源之间进行折衷：观测数据和可用的先验信息（关于正则性）。这是通过参数 $\\mu$ 的值来实现的。在下面的研究中，选择一个最合适的 $\\mu$ 值，以使反卷积图像既不过于平滑也不过于不规则。\n因此，可以计算反卷积图像 $\\hat{x}$ 和真实图像 $x^\\star$ 之间的数值差异，作为正则化参数 $\\mu$ 的函数。\n为此，考虑以下三种距离函数：\n$$\\Delta_2(\\mu) = \\frac{\\sum_{p,q} (\\hat{x}_{p,q}(\\mu) - x^{\\star}_{p,q})^2}{\\sum_{p,q} (x^{\\star}_{p,q})^2} = \\frac{\\|\\hat{x}(\\mu) - x^{\\star}\\|_2^2}{\\|x^{\\star}\\|_2^2}$$ $$\\Delta_1(\\mu) = \\frac{\\sum_{p,q} |\\hat{x}_{p,q}(\\mu) - x^{\\star}_{p,q}|}{\\sum_{p,q} |x^{\\star}_{p,q}|} = \\frac{\\|\\hat{x}(\\mu) - x^{\\star}\\|_1}{\\|x^{\\star}\\|_1}$$ $$\\Delta_\\infty(\\mu) = \\frac{\\max_{p,q} |\\hat{x}_{p,q}(\\mu) - x^{\\star}_{p,q}|}{\\max_{p,q} |x^{\\star}_{p,q}|} = \\frac{\\|\\hat{x}(\\mu) - x^{\\star}\\|_\\infty}{\\|x^{\\star}\\|_\\infty}$$ 当恢复的图像类似于真实图像时，这些距离接近于 0，当恢复的图像为零时，它们接近 1。\n​\t•\t我们设定 $\\mu$ 值在 $10^{-10}$ 和 $10^{10}$ 之间取对数间隔值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 %% Question 8 % Load TrueImage (focus on Data2) TrueImage = Data2.TrueImage; mu=logspace(-10, 10, 100); for i=1:length(mu) val_mu=mu(i); % Deconvolve image with current mu x_hat_temp = deconvolve_image(Data2.Data, Data2.IR, val_mu); delta_2(i)=norm(x_hat_temp-TrueImage,2)/norm(TrueImage,2); delta_1(i)=norm(x_hat_temp-TrueImage,1)/norm(TrueImage,1); delta_inf(i)=norm(x_hat_temp-TrueImage,Inf)/norm(TrueImage,Inf); end % Find mu that minimizes each distance [min_delta_2,ind_min_delta_2]=min(delta_2); [min_delta_1,ind_min_delta_1]=min(delta_1); [min_delta_inf,ind_min_delta_inf]=min(delta_inf); mu_min_delta_2 = mu(ind_min_delta_2); mu_min_delta_1 = mu(ind_min_delta_1); mu_min_delta_inf = mu(ind_min_delta_inf); % Display the results fprintf('Delta_2 的最小值为: %e，对应的 mu 为: %e\\n', min_delta_2, mu_min_delta_2); fprintf('Delta_1 的最小值为: %e，对应的 mu 为: %e\\n', min_delta_1, mu_min_delta_1); fprintf('Delta_inf 的最小值为: %e，对应的 mu 为: %e\\n', min_delta_inf, mu_min_delta_inf); % Plot the distances as functions of mu figure; subplot(3,1,1) loglog(mu, delta_2, 'b-', 'LineWidth', 2); hold on; loglog(mu(ind_min_delta_2), min_delta_2, 'ro', 'MarkerSize', 8, 'LineWidth', 2); xlabel('\\mu'); ylabel('\\Delta_2(\\mu)'); title('\\Delta_2 vs \\mu'); grid on; legend('\\Delta_2(\\mu)', ['Min at \\mu = ', num2str(mu_min_delta_2, '%.1e')]); subplot(3,1,2) loglog(mu, delta_1, 'g-', 'LineWidth', 2); hold on; loglog(mu(ind_min_delta_1), min_delta_1, 'ro', 'MarkerSize', 8, 'LineWidth', 2); xlabel('\\mu'); ylabel('\\Delta_1(\\mu)'); title('\\Delta_1 vs \\mu'); grid on; legend('\\Delta_1(\\mu)', ['Min at \\mu = ', num2str(mu_min_delta_1, '%.1e')]); subplot(3,1,3) loglog(mu, delta_inf, 'm-', 'LineWidth', 2); hold on; loglog(mu(ind_min_delta_inf), min_delta_inf, 'ro', 'MarkerSize', 8, 'LineWidth', 2); xlabel('\\mu'); ylabel('\\Delta_\\infty(\\mu)'); title('\\Delta_\\infty vs \\mu'); grid on; legend('\\Delta_\\infty(\\mu)', ['Min at \\mu = ', num2str(mu_min_delta_inf, '%.1e')]); 1 2 3 4 5 Delta_2 的最小值为: 4.887066e-02，对应的 mu 为: 2.983647e-03 Delta_1 的最小值为: 1.337040e-01，对应的 mu 为: 1.204504e-02 Delta_inf 的最小值为: 1.855954e-01，对应的 mu 为: 7.564633e-03 和之前肉眼观察得到的 $\\mu$ 值相比，可见差距还是挺大的。\n​\t本文内容均为 ’ Problème inverse ’ 课程下的实验部分。\n​\t具体实验PDF文稿见 Jean-François Giovanelli 老师官方网站: http://giovannelli.free.fr\n",
  "wordCount" : "2746",
  "inLanguage": "zh",
  "image": "https://zehua716.github.io/images/papermod-cover.png","datePublished": "2024-11-05T16:25:17+01:00",
  "dateModified": "2024-11-06T17:12:35+08:00",
  "author":{
    "@type": "Person",
    "name": "Zehua"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zehua716.github.io/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98tp1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "主页",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zehua716.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zehua716.github.io/zh/" accesskey="h" title="主页 (Alt + H)">主页</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://zehua716.github.io/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zehua716.github.io/zh/posts/" title="列表">
                    <span>列表</span>
                </a>
            </li>
            <li>
                <a href="https://zehua716.github.io/zh/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://zehua716.github.io/zh/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://zehua716.github.io/zh/about/" title="版权说明">
                    <span>版权说明</span>
                </a>
            </li>
            <li>
                <a href="https://zehua716.github.io/zh/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://zehua716.github.io/zh/">主页</a>&nbsp;»&nbsp;<a href="https://zehua716.github.io/zh/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://zehua716.github.io/zh/posts/signal_cn/">信号处理</a></div>
    <h1 class="post-title entry-hint-parent">
      		反问题 TP1
    </h1>
    <div class="post-description">
      图像恢复中去卷积问题
    </div>
    <div class="post-meta"><span title='2024-11-05 16:25:17 +0100 CET'>十一月 5, 2024</span>&nbsp;·&nbsp;Zehua

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e5%9b%be%e5%83%8f%e5%8f%8d%e5%8d%b7%e7%a7%afwiener-hunt-%e6%96%b9%e6%b3%95" aria-label="图像反卷积：Wiener-Hunt 方法"><strong>图像反卷积：Wiener-Hunt 方法</strong></a><ul>
                            
                    <li>
                        <a href="#1-%e4%b8%80%e7%bb%b4%e5%8f%8d%e5%8d%b7%e7%a7%af" aria-label="1. 一维反卷积"><strong>1. 一维反卷积</strong></a><ul>
                            
                    <li>
                        <a href="#11-%e4%b8%80%e7%bb%b4%e5%bb%ba%e6%a8%a1" aria-label="1.1 一维建模"><strong>1.1 一维建模</strong></a></li>
                    <li>
                        <a href="#12-%e5%b8%a6%e6%83%a9%e7%bd%9a%e7%9a%84%e6%9c%80%e5%b0%8f%e4%ba%8c%e4%b9%98%e6%b3%95" aria-label="1.2 带惩罚的最小二乘法"><strong>1.2 带惩罚的最小二乘法</strong></a><ul>
                            
                    <li>
                        <a href="#121-%e5%be%aa%e7%8e%af%e8%bf%91%e4%bc%bc" aria-label="1.2.1 循环近似"><strong>1.2.1 循环近似</strong></a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#2-%e5%ae%9e%e7%8e%b0" aria-label="2 实现"><strong>2 实现</strong></a><ul>
                            
                    <li>
                        <a href="#21-%e4%ba%8c%e7%bb%b4%e6%96%b9%e6%b3%95" aria-label="2.1 二维方法"><strong>2.1 二维方法</strong></a></li>
                    <li>
                        <a href="#22-%e8%a7%82%e6%b5%8b%e5%9b%be%e5%83%8f" aria-label="2.2 观测图像"><strong>2.2 观测图像</strong></a></li>
                    <li>
                        <a href="#23-implementation" aria-label="2.3 Implementation"><strong>2.3 Implementation</strong></a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="图像反卷积wiener-hunt-方法"><strong>图像反卷积：Wiener-Hunt 方法</strong><a hidden class="anchor" aria-hidden="true" href="#图像反卷积wiener-hunt-方法">#</a></h1>
<p>主要针对图像去模糊问题，即从模糊(带噪)图像中恢复清晰图像。这属于逆问题的范畴，一半出现在处理真实测量系统时。由于每个测量系统（如温度计、CCD相机、光谱仪等）都受到基础物理学的限制，比如有限精度、有限动态范围、非零响应时间等。这意味着测得的量或多或少都有扭曲。因此这部分是对感兴趣物理量的某种扭曲程度的度量。</p>
<p>大多数情况下，测量系统直接给出的测量数据通常具有足够的精度和鲁棒性。但是，也存在测量结果不准确的情况。为了解决精度问题，或者说至少部分地优化它，已经开发了特殊的信号和图像处理技术。在接下来的内容中，我们将通过一个简单的例子来展示此类方法。</p>
<p>我们有一张未聚焦的图像。这种情况下，点的图像实际上会是一个斑点。捕获的图像将会因为模糊而受损，因为它是由真实图像中每个点生成的斑点的叠加结果。</p>
<p>描述这种转换的最简单模型是线性不变滤波器，即卷积。示意图如下图所示。</p>
<p>在上面的示意图中， $x_{n,m}$ 代表真实或原始图像，$y_{n,m}$ 代表观测到的图像，或者更确切地说，是我们通过相机拍到的未聚焦图像。添加分量 $b_{n,m}$ 是为了考虑测量和建模误差。</p>
<p>描述测量过程的方程(二维)如下：</p>
<p>$$
y_{n,m} = \sum_{p=-P}^{P} \sum_{q=-Q}^{Q} h_{p,q} x_{n-p,m-q} + b_{n,m}
$$</p>
<p>$y_{n,m}$ 是对于每个观测到的像素 $(n, m)$ 。在这个公式中，$P$ 和 $Q$ 是给定的整数。</p>
<p>注意，滤波器通常来说都是低通滤波器，这就意味着它们无法准确地在输出中再现输入信号或图像中的所有分量，因为高频分量要么被强烈衰减，要么完全被拒绝，这也就是为什么 ‘‘恢复真实信号’‘或者说’‘图像的逆问题’’ 是如此困难：必须恢复那些要么完全不存在、要么“错误”观测到的高频分量。</p>
<p>在下面的例子中，我们用线性方法来解决图像反卷积问题。这些线性方法依赖于最小二乘准则，并结合了二次惩罚。我们先介绍其理论部分，包括这些准则及其最小化器。此外，展示背后的技术细节，并提出了一种基于循环近似的方法，以实现快速的数值计算。</p>
<h2 id="1-一维反卷积"><strong>1. 一维反卷积</strong><a hidden class="anchor" aria-hidden="true" href="#1-一维反卷积">#</a></h2>
<p>为了简化理论概念，我们先讨论在一维情况下的信号反卷积。这种简化情况允许对反卷积问题的分析更加深入，同时更容易掌握概念和思路。随后再引入二维情况，并将其视为一维情况的扩展。Matlab 实现部分仅涉及二维情况。</p>
<h3 id="11-一维建模"><strong>1.1 一维建模</strong><a hidden class="anchor" aria-hidden="true" href="#11-一维建模">#</a></h3>
<p>在一维情况下，(1) 中给出的观测模型变为：</p>
<p>$$
y_n = \sum_{p=-P}^{P} h_p x_{n-p} + b_n
$$</p>
<p>如果我们有 $N$ 个样本，可以将相应的 $N$ 个方程写成矩阵形式：</p>
<p>$$
\mathbf{y} = \mathbf{H} \mathbf{x} + \mathbf{b}
$$</p>
<p>​	•	向量 $\mathbf{y}$ 包含了所有的 $N$ 个观测值（在二维情况下，它将包含模糊的图像）</p>
<p>​	•	向量 $\mathbf{x}$ 包含了恢复图像的样本，而 $\mathbf{b}$ 是噪声样本。</p>
<p>​	•	矩阵 $\mathbf{H}$ ，称为模糊矩阵，具有以下经典结构：</p>
<p>$$
H = \begin{bmatrix}
h_P &amp; \cdots &amp; h_0 &amp; \cdots &amp; h_{-P} &amp; 0 &amp; 0 &amp; 0 &amp; \cdots \\
0 &amp; h_P &amp; \cdots &amp; h_0 &amp; \cdots &amp; h_{-P} &amp; 0 &amp; 0 &amp; \cdots \\
0 &amp; 0 &amp; h_P &amp; \cdots &amp; h_0 &amp; \cdots &amp; h_{-P} &amp; 0 &amp; \cdots \\
0 &amp; 0 &amp; 0 &amp; h_P &amp; \cdots &amp; h_0 &amp; \cdots &amp; h_{-P} &amp; \cdots \\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots
\end{bmatrix}
$$</p>
<p>​	•	$\mathbf{H}$ 是一个 $N \times N$ 的方阵，并且具有 Toeplitz 结构。</p>
<p>因此，信号反卷积问题可以重新表述为: 在已知观测信号 $\mathbf{y}$ 并知道卷积矩阵 $H$ 的情况下，估计向量 $\mathbf{x}$</p>
<h3 id="12-带惩罚的最小二乘法"><strong>1.2 带惩罚的最小二乘法</strong><a hidden class="anchor" aria-hidden="true" href="#12-带惩罚的最小二乘法">#</a></h3>
<p>提出的重建策略 (损失函数) 是一种带惩罚的最小二乘法。它包含两个部分：</p>
<p>​	•	一个重构损失项，用于量化恢复信号 $\mathbf{x}$ 与观测信号 $\mathbf{y}$ 进行重新卷积后的相似性，从而确保恢复的信号与观测信号一致。</p>
<p>​	•	一个惩罚项，用于限制恢复信号的连续样本之间的差异，确保其具有一定的规则性结构。</p>
<p>该准则采用以下表达式：</p>
<p>$$
J_{\text{PLS}}(x) = | y - Hx |^2 + \mu | Dx |^2 = (y - Hx)^t (y - Hx) + \mu x^t D^t D x
$$</p>
<p>其中，$D$ 是阶数为 1，大小为 $(N - 1) \times N$ 的差分矩阵，定义如下：</p>
<p>$$
D = \begin{bmatrix}
\cdots &amp; -1 &amp; 1 &amp; 0 &amp; 0 &amp; \cdots \\
\cdots &amp; 0 &amp; -1 &amp; 1 &amp; 0 &amp; \cdots \\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\
\cdots &amp; 0 &amp; 0 &amp; -1 &amp; 1 &amp; \cdots\\
\end{bmatrix}
$$</p>
<p>带惩罚的最小二乘准则的最小化器为：</p>
<p>$$
\hat{x} = (H^t H + \mu D^t D)^{-1} H^t y
$$</p>
<p>证明:</p>
<p>$$
\hat{x} = (H^T H + \mu D^T D)^{-1} H^T y
$$</p>
<p>我们已知损失准则为:</p>
<p>$$
J_{\text{PLS}}(x) = y^T y - 2x^T H^T y + x^T H^T H x + \mu x^T D^T D x
$$</p>
<p>求偏导为0:</p>
<p>$$
\hat{x} = (H^T H + \mu D^T D)^{-1} H^T y
$$</p>
<p>特殊情况：</p>
<p>在特定情况下 $\mu = 0$ 时准则和最小化器的结果表达式变为 $J_{\text{PLS}}(x) = |y - Hx|^2$</p>
<p>最小化器方程为：</p>
<p>$$
\hat{x} = (H^T H)^{-1} H^T y
$$</p>
<p>此时准则变为经典的最小二乘问题，没有正则化项，也就是说，模型仅考虑最小化观测值与预测值之间的误差，而不会惩罚解的复杂度或平滑性。其解是经典的 <strong>最小二乘解</strong>。</p>
<h4 id="121-循环近似"><strong>1.2.1 循环近似</strong><a hidden class="anchor" aria-hidden="true" href="#121-循环近似">#</a></h4>
<p>回到公式 (9) ，我们已知矩阵 $H^T H + \mu D^T D$ 的大小为 $N \times N$ ，当 $N$ 很大时，这种反演在计算上非常昂贵甚至不可行。</p>
<p>比如说在处理图像时，比如对于 $1000 \times 1000$ 的图像，矩阵的大小为 $10^6 \times 10^6$ ，计算不了。在三维情况下，更复杂。</p>
<p>因此为了计算 $\hat{x}$ ，有几种方法可以克服这种大计算量的困难。</p>
<p>下面我们考虑使用循环矩阵的特性，因为我们可以用对角矩阵来 “替换” 公式 (9) 中的矩阵 (通过快速傅里叶变换 FFT 可以将循环矩阵 “转化”为对角矩阵)。因此，使用对角矩阵进行计算时，乘法或反演等矩阵运算的复杂度将大大降低。</p>
<p>但是，这需要先将矩阵 $H$ 和 $D$ 近似为循环矩阵 $\tilde{H}$ 和 $\tilde{D}$ 。</p>
<p>循环近似涉及修改矩阵的右上角和/或左下角部分，使其具有循环结构。这种近似的核心假设是信号或图像在开始和结束部分是周期性的，即信号的末尾与开头相连接，形成一个环状结构。</p>
<p>循环卷积矩阵 $\tilde{H}$ 和 $\tilde{D}$ 在傅里叶基下可以轻松对角化：</p>
<p>$$
\tilde{H} = F^T \Lambda_h F \quad \text{和} \quad \tilde{D} = F^T \Lambda_d F
$$</p>
<p>矩阵 $\Lambda_h$ 是对角矩阵，其对角线上元素是 $H$ 的特征值。</p>
<p>特征值可以通过对矩阵 $H$ 第一行进行快速傅里叶变换（FFT）获得，即计算脉冲响应的 $N$ 点 FFT，这些响应代表频率响应的样本。</p>
<p>同样适用于矩阵 $\tilde{D}$ 及其特征值，其中将脉冲响应替换为 $[-1, 1]$。</p>
<p>通过在 (9) 中用 (18) 代替，并使用简单的矩阵操作，可以得到：</p>
<p>$$
\overset{\circ}{\hat{x}} = (\Lambda_{h}^{\dagger} \Lambda_{h} + \mu \Lambda_{d}^{\dagger} \Lambda_{d})^{-1} \Lambda_{h}^{\dagger} \overset{\circ}{y}
$$</p>
<p>在此基础上再进一步:</p>
<p>$$
\overset{\circ}{\hat{x}} = \left[ \Lambda_h^{\dagger} \Lambda_h + \mu \left( \Lambda_{d_c}^{\dagger} \Lambda_{d_c} + \Lambda_{d_r}^{\dagger} \Lambda_{d_r} \right) \right] \Lambda_h^{\dagger} \dot{\mathbf{y}}
$$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">FT_x</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">./</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Lambda_H</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">mu</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Lambda_dC</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Lambda_dR</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">))</span><span class="o">.*</span> <span class="p">(</span><span class="nb">conj</span><span class="p">(</span><span class="n">Lambda_H</span><span class="p">)</span><span class="o">.*</span> <span class="n">FT_Data</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>​		$\Lambda_h \Rightarrow$ FT_IR = MyFFT2RI(IR, 256);</p>
<p>​		$\Lambda_{d_c} \Rightarrow$ FT_Dc = MyFFT2RI(Dc, 256);</p>
<p>​		$\Lambda_{d_r} \Rightarrow$ FT_Dr = MyFFT2RI(Dr, 256);</p>
<p>回顾性质:</p>
<p>$$
\Lambda_H^{+} = (\Lambda_H^T)^{} = \Lambda_H^{} = \operatorname{conj}(\Lambda_H)
$$</p>
<p>因此有:</p>
<p>$$
\Lambda_H^{+} \cdot \Lambda_H = \Lambda_H^{*} \cdot \Lambda_H = |\Lambda_H|^2
$$</p>
<p>证明：</p>
<p>$$
\overset{\circ}{\hat{x}} = (\Lambda_{h}^{\dagger} \Lambda_{h} + \mu \Lambda_{d}^{\dagger} \Lambda_{d})^{-1} \Lambda_{h}^{\dagger} \overset{\circ}{y}
$$</p>
<p>补充知识: $\tilde{H}$ 是一个实矩阵，因此其复共轭等于它本身，$\tilde{H} = \tilde{H}^T$ 。$\tilde{D}$ 同理</p>
<p>在近似为循环矩阵后，公式 (15) 变为:</p>
<p>$$
\hat{x} = (\tilde{H}^{T}\tilde{H} + \mu \tilde{D}^{T}\tilde{D})^{-1}\tilde{H}^{T}y
$$</p>
<p>其中: $\tilde{H} = F^T \Lambda_h F$ 且 $\tilde{D} = F^T \Lambda_d F$ 将其带入上述公式，得:</p>
<p>$$
\hat{x} = ((F^{T}\Lambda_{h}F)^{T}(F^{T}\Lambda_{h}F) + \mu (F^{T}\Lambda_{d}F)^{T}(F^{T}\Lambda_{d}F))^{-1}(F^{T}\Lambda_{h}F)^{T}y
$$</p>
<p>因为傅里叶矩阵 $F$ 是一个正交矩阵，具有 $F F^{T} = I$ 的性质，即 $F^{T} = F^{-1}$</p>
<p>并且我们有 $(F^{T}\Lambda_{h}F)^{T} = F^{T}\Lambda_{h}^{T}F$ 以及 $(F^{T}\Lambda_{d}F)^{T} = F^{T}\Lambda_{d}^{T}F$</p>
<p>所以:</p>
<p>令 $\quad \overset{\circ}{\hat{x}} = F \hat{x}, \quad \overset{\circ}{y} = F y$</p>
<p>那么:</p>
<p>$$
\overset{\circ}{\hat{x}} = (\Lambda_{h}^{\dagger} \Lambda_{h} + \mu \Lambda_{d}^{\dagger} \Lambda_{d})^{-1} \Lambda_{h}^{\dagger} \overset{\circ}{y}
$$</p>
<p>证毕。</p>
<p>特殊情况：</p>
<p>当 $\mu = 0$ 时，正则化项消失，公式简化为：</p>
<p>$$
\overset{\circ}{\hat{x}} = (\Lambda_{h}^{\dagger} \Lambda_{h})^{-1} \Lambda_{h}^{\dagger} \overset{\circ}{y}
$$</p>
<p>这意味着我们仅仅执行了经典的 Wiener 去卷积，没有考虑图像的正则化。</p>
<p>$$\hat{x} = (\tilde{H}^{T}\tilde{H} )^{-1}\tilde{H}^{T}y\ $$</p>
<p>没有正则化时，虽然理论上可以恢复原始信号，但是实际上收到的噪声影响很大，且没有约束来将其消除</p>
<p>为了完成我们的讨论，我们首先构建向量 $g_{\text{PLS}}$ ，其分量定义如下：</p>
<p>$$
g_{PLS}^{n} = \frac{\overset{\circ}{h}_{n}^{*}}{|\overset{\circ}h_n|^2 + \mu |\overset{\circ}d_n|^2}\quad \text{for } n = 1, 2, \dots, N
$$</p>
<p>因此，向量 $\overset{\circ}{\hat{x}}$ 是通过向量 $g_{\text{PLS}}$ 和 $\overset{\circ}{\hat{y}}$ 之间逐元素相乘得到的：</p>
<p>$$
\overset{\circ}{\hat{x}} = g_{\text{PLS}} .* \overset{\circ}{\hat{y}}
$$</p>
<p>反卷积问题可以表述为在傅里叶域中进行的滤波操作，其中 $g_{\text{PLS}}$ 代表离散传递函数。</p>
<p>反卷积问题总结如下：</p>
<p>​	•	① 构建 $\mathring{h}$ 作为脉冲响应的 $N$ 点 FFT</p>
<p>​	•	② 构建 $\mathring{d}$ 作为 $[1; -1]$ 的 $N$ 点 FFT</p>
<p>​	•	③ 构建包含传递函数 $g_{\text{PLS}}$ 的向量</p>
<p>​	•	④ 构建观测值的 FFT $\mathring{y}$</p>
<p>​	•	⑤ 计算 $\mathring{\hat{x}}$ ，作为传递函数 $g_{\text{PLS}}$ 和 $\mathring{\hat{y}}$ 的乘积</p>
<p>​	•	⑥ 计算 $\mathring{\hat{x}}$ 的 IFFT 以在空间域中获得解 $\hat{x}$</p>
<h2 id="2-实现"><strong>2 实现</strong><a hidden class="anchor" aria-hidden="true" href="#2-实现">#</a></h2>
<h3 id="21-二维方法"><strong>2.1 二维方法</strong><a hidden class="anchor" aria-hidden="true" href="#21-二维方法">#</a></h3>
<p>对于二维情况，其方程类似于一维情况。但是，所涉及的block-Tœplitz矩阵结构更加复杂: 每个块本身也具有 Tœplitz 结构。这使得在两个方向上进行循环近似变得更加困难。因此，二维情况仅作为一维情况的扩展来展示，重点是 Matlab 实现，理论部分暂不讨论。</p>
<p>注意以下几点：</p>
<p>​	•	图像、脉冲响应、正则化项都是二维的，这意味着必须使用 FFT-2D 而不是 FFT。</p>
<p>​	•	更确切地说，如果要恢复的图像有 $N$ 行和 $N$ 列，那么 FFT-2D 必须在 $N$ 行和 $N$ 列上计算。</p>
<p>​	•	频率传递函数也是二维的，每个空间频率有一个维度。</p>
<p>特别说明 — 在任何情况下，矩阵 $H$ 和 $D$ 都不应在 Matlab 代码中构建。</p>
<h3 id="22-观测图像"><strong>2.2 观测图像</strong><a hidden class="anchor" aria-hidden="true" href="#22-观测图像">#</a></h3>
<p>​	•	第一步是加载数据 <strong>Data1</strong> 和 <strong>Data2</strong> 。使用 <strong>load</strong> 函数来完成。每个数据文件内部包含：模糊图像 (<strong>Data</strong>)、用于比较的真实图像 (<strong>TrueIma</strong>)，以及卷积滤波器的脉冲响应 (<strong>IR</strong>)。现在分析每个数据集及其相互关系。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">clear</span> <span class="n">all</span> 
</span></span><span class="line"><span class="cl"><span class="n">close</span> <span class="n">all</span>
</span></span><span class="line"><span class="cl"><span class="n">clc</span>
</span></span><span class="line"><span class="cl"><span class="c">%% Load Data</span>
</span></span><span class="line"><span class="cl"><span class="n">Data1</span> <span class="p">=</span> <span class="n">load</span><span class="p">(</span><span class="s">&#39;DataOne.mat&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Data2</span> <span class="p">=</span> <span class="n">load</span><span class="p">(</span><span class="s">&#39;DataTwo.mat&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c">% Create a window to display the image</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c">% Display the image, grayscale</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Data1</span><span class="p">.</span><span class="n">Data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% Scale the axes and eliminate the grading</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Observed Image - Data1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c">% Display the image, grayscale</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Data2</span><span class="p">.</span><span class="n">Data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% Scale the axes and eliminate the grading</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Observed Image - Data2&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_1.png" alt="TP1_1"  />
</p>
<p>两观测图像都有明显的模糊，具体是边缘和结构细节处。这种模糊表明图像中的高频信息被卷积或散射了，导致图像细节的丢失，这就是由于卷积效应或低通滤波的影响而造成的。</p>
<p>​	•	为了进一步分析，肯定要到频域看</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% Analyse the images in the frequency domain (linear and a logarithmic scale)</span>
</span></span><span class="line"><span class="cl"><span class="c">% % Get the sizes of the images</span>
</span></span><span class="line"><span class="cl"><span class="c">% [M1,N1] = size(Data1.Data);</span>
</span></span><span class="line"><span class="cl"><span class="c">% [M2,N2] = size(Data2.Data);</span>
</span></span><span class="line"><span class="cl"><span class="c">% % Generate frequency axes for Data1</span>
</span></span><span class="line"><span class="cl"><span class="c">% u1 = (-M1/2:M1/2-1)/M1; % Normalized frequencies in y-direction</span>
</span></span><span class="line"><span class="cl"><span class="c">% v1 = (-N1/2:N1/2-1)/N1; % Normalized frequencies in x-direction</span>
</span></span><span class="line"><span class="cl"><span class="c">% % Generate frequency axes for Data2</span>
</span></span><span class="line"><span class="cl"><span class="c">% u2 = (-M2/2:M2/2-1)/M2;</span>
</span></span><span class="line"><span class="cl"><span class="c">% v2 = (-N2/2:N2/2-1)/N2;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Generate normalized frequency axes using linspace</span>
</span></span><span class="line"><span class="cl"><span class="n">Nu</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Compute the 2D FFT of observed images and shift zero frequency to center</span>
</span></span><span class="line"><span class="cl"><span class="n">FFT_Data1</span> <span class="p">=</span> <span class="n">MyFFT2</span><span class="p">(</span><span class="n">Data1</span><span class="p">.</span><span class="n">Data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">FFT_Data2</span> <span class="p">=</span> <span class="n">MyFFT2</span><span class="p">(</span><span class="n">Data2</span><span class="p">.</span><span class="n">Data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% Magnitude spectra</span>
</span></span><span class="line"><span class="cl"><span class="n">Mag_Data1</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">FFT_Data1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Mag_Data2</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">FFT_Data2</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% Display magnitude spectra in linear scales</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Nu</span><span class="p">,</span><span class="n">Nu</span><span class="p">,</span><span class="n">Mag_Data1</span><span class="p">);</span> <span class="c">% Use frequency axes v1 and u1</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Y&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Magnitude (Linear Scale) - Data1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Nu</span><span class="p">,</span><span class="n">Nu</span><span class="p">,</span><span class="n">Mag_Data2</span><span class="p">);</span> <span class="c">% Use frequency axes v2 and u2</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Y&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Magnitude (Linear Scale) - Data2&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_2.png" alt="TP1_1"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% Display magnitude spectra in logarithmic scales</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Nu</span><span class="p">,</span><span class="n">Nu</span><span class="p">,</span><span class="nb">log</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">Mag_Data1</span><span class="p">));</span> <span class="c">% Use log scale</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Y&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Magnitude (logarithmic Scale) - Data1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Nu</span><span class="p">,</span><span class="n">Nu</span><span class="p">,</span><span class="nb">log</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">Mag_Data2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Y&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Magnitude (logarithmic Scale) - Data2&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_3.png" alt="TP1_1"  />
</p>
<p>可见只有两组频谱图的中心部分有强烈亮度，即低频分量较强，即图像大范围平滑信息较多，而高频部分的细节没有</p>
<p>​	•	我们继续看两个脉冲响应 $h_{n,m}$ 及其关联的传递函数 $H(\nu_x, \nu_y)$ 。首先使用 imagesc 函数，然后使用 plot 函数来进行分析。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% Calcul impulse responses and associated transfer functions using impulse</span>
</span></span><span class="line"><span class="cl"><span class="c">% Load the impulse responses</span>
</span></span><span class="line"><span class="cl"><span class="n">IR1</span> <span class="p">=</span> <span class="n">Data1</span><span class="p">.</span><span class="n">IR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">IR2</span> <span class="p">=</span> <span class="n">Data2</span><span class="p">.</span><span class="n">IR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Display the impulse responses</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">IR1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Impulse Response - IR1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">IR2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Impulse Response - IR2&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Compute and display the transfer functions</span>
</span></span><span class="line"><span class="cl"><span class="n">Long</span> <span class="p">=</span> <span class="mi">256</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">H1</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">IR1</span><span class="p">,</span> <span class="n">Long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">H2</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">IR2</span><span class="p">,</span> <span class="n">Long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Compute the magnitude spectra</span>
</span></span><span class="line"><span class="cl"><span class="n">Mag_H1</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">H1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Mag_H2</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">H2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Display the transfer functions using imagesc</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Nu</span><span class="p">,</span> <span class="n">Nu</span><span class="p">,</span> <span class="n">Mag_H1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Y&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Transfer Function Magnitude - H1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Nu</span><span class="p">,</span> <span class="n">Nu</span><span class="p">,</span> <span class="n">Mag_H2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Y&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Transfer Function Magnitude - H2&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_4.png" alt="TP1_1"  />
</p>
<p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_5.png" alt="TP1_1"  />
</p>
<p>很明显，IR1 和 IR2 都是低通滤波器，只允许低频分量通过，高频分量进行衰减或完全抑制。IR1 的传递函数 H1 的分布更加平滑，说明它对低频分量的保留更为均匀。IR2 的滤波特性更倾向于选择性地保留某些低频分量，而非均匀地平滑整个低频区域。因此，相较于 IR1，IR2 对图像的细节影响更强。不过这么看看不出来具体的道道儿，还是得看下面的切片。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% Plot slices through the transfer functions using plot</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Midpoint index (since Long = 256)</span>
</span></span><span class="line"><span class="cl"><span class="n">mid_index</span> <span class="p">=</span> <span class="n">Long</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c">% This will be 129</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Plot slices for H1</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">Nu</span><span class="p">,</span> <span class="n">Mag_H1</span><span class="p">(</span><span class="n">mid_index</span><span class="p">,</span> <span class="p">:));</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Normalized Frequency X&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Magnitude&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Transfer Function along Central Row - H1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">Nu</span><span class="p">,</span> <span class="n">Mag_H1</span><span class="p">(:,</span> <span class="n">mid_index</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Normalized Frequency Y&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Magnitude&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Transfer Function along Central Column - H1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_6.png" alt="TP1_1"  />
</p>
<p>可见前面的结论是正确的，H1 幅值响应曲线变化相对平滑，适合图像整体的模糊处理任务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% Plot slices for H2</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">Nu</span><span class="p">,</span> <span class="n">Mag_H2</span><span class="p">(</span><span class="n">mid_index</span><span class="p">,</span> <span class="p">:));</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Normalized Frequency X&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Magnitude&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Transfer Function along Central Row - H2&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">Nu</span><span class="p">,</span> <span class="n">Mag_H2</span><span class="p">(:,</span> <span class="n">mid_index</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Normalized Frequency Y&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Magnitude&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;Transfer Function along Central Column - H2&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_7.png" alt="TP1_1"  />
</p>
<p>在 H2 的切片图中，幅值响应曲线有更明显的周期性波动，适合特定方向的模糊或增强效果。</p>
<h3 id="23-implementation"><strong>2.3 Implementation</strong><a hidden class="anchor" aria-hidden="true" href="#23-implementation">#</a></h3>
<p>我们将在二维情况下实现反卷积，并使用带有二次惩罚项的最小二乘法，同时使用循环近似进行最小化，在前面已经进行过了总结。</p>
<p>关于正则化项，它依赖于图像列和行上相邻像素之间的差异。其表达式为：</p>
<p>$$
| D x |^2 = \sum_{n,m} (x_{n,m} - x_{n,m+1})^2 + (x_{n,m} - x_{n+1,m})^2
$$</p>
<p>​	•	正则化项 $| D x |^2$ 代表了水平方向和垂直方向相邻像素值的平方差之和。</p>
<p>因此它将基于两个滤波器(水平和垂直)来实现：</p>
<p>$$
D_{horiz} = \begin{bmatrix} 0 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 1 \\ 0 &amp; 0 &amp; 0 \end{bmatrix} \quad D_{vert} = \begin{bmatrix} 0 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ 0 &amp; 1 &amp; 0 \end{bmatrix}
$$</p>
<p>这两个滤波器分别计算行和列上像素之间的差异。</p>
<p>当然也可以从以下脉冲响应滤波器中选一个，它们都可以实现图像梯度的近似。</p>
<p>$$
\begin{bmatrix}
0 &amp; -1 &amp; 0 \\
-1 &amp; 4 &amp; -1 \\
0 &amp; -1 &amp; 0
\end{bmatrix}
\quad \text{或} \quad
\begin{bmatrix}
-1 &amp; -1 &amp; -1 \\
-1 &amp; 8 &amp; -1 \\
-1 &amp; -1 &amp; -1
\end{bmatrix}
\quad \text{或} \quad
\begin{bmatrix}
1 &amp; -2 &amp; 1 \\
-2 &amp; 4 &amp; -2 \\
1 &amp; -2 &amp; 1
\end{bmatrix}
$$</p>
<p>回顾前面，我们得到：</p>
<p>$$
\hat{x} = (H^{T}H + \mu D^{T}D)^{-1}H^{T}y
$$</p>
<p>现在进行傅里叶变换下的去卷积</p>
<p>$$
\hat{x}(\nu_{x}, \nu_{y}) = \frac{\hat{H}^{*}(\nu_{x}, \nu_{y}) \hat{y}(\nu_{x}, \nu_{y})}{|\hat{H}(\nu_{x}, \nu_{y})|^2 + \mu |\hat{D}(\nu_{x}, \nu_{y})|^2}
$$</p>
<p>​	•	$\hat{H}(\nu_{x}, \nu_{y})$ 是卷积矩阵的傅里叶变换</p>
<p>​	•	$\hat{D}(\nu_{x}, \nu_{y})$ 是差分矩阵的傅里叶变换</p>
<p>​	•	$\hat{x}(\nu_{x}, \nu_{y})$ 是频域中的恢复图像</p>
<p>我们先写一个反卷积函数，将观测数据 (Data)、脉冲响应 (IR) 和正则化参数 (mu) 作为输入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">function</span><span class="w"> </span>[x] <span class="p">=</span><span class="w"> </span><span class="nf">deconvolve_image</span><span class="p">(</span>Data,IR,mu<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Long</span> <span class="p">=</span> <span class="nb">length</span><span class="p">(</span><span class="n">Data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Nu</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">Long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">TF_Data</span> <span class="p">=</span> <span class="n">MyFFT2</span><span class="p">(</span><span class="n">Data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">TF_IR</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">IR</span><span class="p">,</span><span class="n">Long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">% figure(1)</span>
</span></span><span class="line"><span class="cl">    <span class="c">% subplot(2, 1, 1)</span>
</span></span><span class="line"><span class="cl">    <span class="c">% imagesc(Nu, Nu, abs(TF_IR))</span>
</span></span><span class="line"><span class="cl">    <span class="c">% title(&#39;Frequency response&#39;)</span>
</span></span><span class="line"><span class="cl">    <span class="c">% xlabel(&#39;\nu_x&#39;)</span>
</span></span><span class="line"><span class="cl">    <span class="c">% ylabel(&#39;\nu_y&#39;)</span>
</span></span><span class="line"><span class="cl">    <span class="c">% axis square</span>
</span></span><span class="line"><span class="cl">    <span class="c">% subplot(2, 1, 2)</span>
</span></span><span class="line"><span class="cl">    <span class="c">% plot(Nu, abs(TF_IR(round(length(TF_IR)/2), :)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Define the regularization filters (difference operators)</span>
</span></span><span class="line"><span class="cl">    <span class="c">% Horizontal difference filter</span>
</span></span><span class="line"><span class="cl">    <span class="n">Dh</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Vertical difference filter</span>
</span></span><span class="line"><span class="cl">    <span class="n">Dv</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Compute the FFTs of the regularization filters using MyFFT2RI</span>
</span></span><span class="line"><span class="cl">    <span class="n">TF_Dh</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">Dh</span><span class="p">,</span> <span class="n">Long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">TF_Dv</span> <span class="p">=</span> <span class="n">MyFFT2RI</span><span class="p">(</span><span class="n">Dv</span><span class="p">,</span> <span class="n">Long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Compute |Dh|^2 and |Dv|^2</span>
</span></span><span class="line"><span class="cl">    <span class="n">abs_Dh_squared</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">TF_Dh</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">abs_Dv_squared</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">TF_Dv</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Total regularization term |D|^2 = |Dh|^2 + |Dv|^2</span>
</span></span><span class="line"><span class="cl">    <span class="n">abs_D_squared</span> <span class="p">=</span> <span class="n">abs_Dh_squared</span> <span class="o">+</span> <span class="n">abs_Dv_squared</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Compute the denominator of the Wiener filter</span>
</span></span><span class="line"><span class="cl">    <span class="n">denom</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">TF_IR</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">abs_D_squared</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Compute the numerator</span>
</span></span><span class="line"><span class="cl">    <span class="n">numerator</span> <span class="p">=</span> <span class="nb">conj</span><span class="p">(</span><span class="n">TF_IR</span><span class="p">)</span> <span class="o">.*</span> <span class="n">TF_Data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Compute X_hat in the frequency domain</span>
</span></span><span class="line"><span class="cl">    <span class="n">TF_X</span> <span class="p">=</span> <span class="n">numerator</span> <span class="o">./</span> <span class="n">denom</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Compute the inverse FFT to get the deconvolved image</span>
</span></span><span class="line"><span class="cl">    <span class="c">% Since MyFFT2 uses fftshift, we need to use ifftshift before ifft2</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="p">=</span> <span class="n">MyIFFT2</span><span class="p">(</span><span class="n">TF_X</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>​	•	然后应用这个逆卷积函数，查看反卷积后的图像去噪效果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% Question 5</span>
</span></span><span class="line"><span class="cl"><span class="n">mu</span> <span class="p">=</span> <span class="mf">0.004</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c">% Deconvolve Data1</span>
</span></span><span class="line"><span class="cl"><span class="n">x_1</span> <span class="p">=</span> <span class="n">deconvolve_image</span><span class="p">(</span><span class="n">Data1</span><span class="p">.</span><span class="n">Data</span><span class="p">,</span> <span class="n">Data1</span><span class="p">.</span><span class="n">IR</span><span class="p">,</span> <span class="n">mu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% Display the deconvolved image</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c">% Display the image, grayscale</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Data1</span><span class="p">.</span><span class="n">Data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% Scale the axes and eliminate the grading</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">([</span><span class="s">&#39;Observed Image - Data1, \mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">x_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">([</span><span class="s">&#39;Deconvolved Image - Data1, \mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Deconvolve Data2</span>
</span></span><span class="line"><span class="cl"><span class="n">x_2</span> <span class="p">=</span> <span class="n">deconvolve_image</span><span class="p">(</span><span class="n">Data2</span><span class="p">.</span><span class="n">Data</span><span class="p">,</span> <span class="n">Data2</span><span class="p">.</span><span class="n">IR</span><span class="p">,</span> <span class="n">mu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% Display the deconvolved image</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c">% Display the image, grayscale</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Data2</span><span class="p">.</span><span class="n">Data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% Scale the axes and eliminate the grading</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">([</span><span class="s">&#39;Observed Image - Data2, \mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">x_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">([</span><span class="s">&#39;Observed Image - Data2, \mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_8.png" alt="TP1_1"  />
</p>
<p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_9.png" alt="TP1_1"  />
</p>
<p>可见效果挺理想，但是之前这个 $\mu$ 是随便设的，现在探讨这个 $\mu$ 值对结果的影响。</p>
<p>​	•	首先考虑简单的逆滤波器情况，即 $\mu = 0$ 。</p>
<p>前面我们得到： $\hat{x} = (H^{T}H + \mu D^{T}D)^{-1}H^{T}y$</p>
<p>现在变成： $\hat{x} = (H^{T}H)^{-1}H^{T}y$</p>
<p>$$
\hat{x}(\nu_{x}, \nu_{y}) = \frac{\hat{H}^{*}(\nu_{x}, \nu_{y}) \hat{y}(\nu_{x}, \nu_{y})}{|\hat{H}(\nu_{x}, \nu_{y})|^2 }
$$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%%  Question 6   Simple Inverse Filter (μ = 0)</span>
</span></span><span class="line"><span class="cl"><span class="n">mu</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c">% Deconvolve Data1</span>
</span></span><span class="line"><span class="cl"><span class="n">x_1</span> <span class="p">=</span> <span class="n">deconvolve_image</span><span class="p">(</span><span class="n">Data1</span><span class="p">.</span><span class="n">Data</span><span class="p">,</span> <span class="n">Data1</span><span class="p">.</span><span class="n">IR</span><span class="p">,</span> <span class="n">mu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% Display the deconvolved image</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c">% Display the image, grayscale</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Data1</span><span class="p">.</span><span class="n">Data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% Scale the axes and eliminate the grading</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">([</span><span class="s">&#39;Observed Image - Data1, \mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">x_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">([</span><span class="s">&#39;Deconvolved Image - Data1, \mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_17.png" alt="TP1_1"  />
</p>
<p>由于 $\mu = 0$ 等价于丢失了正则化项，反卷积结果会直接依赖于卷积核 $H$ 的傅里叶系数 $|\hat{H}(\nu_{x}, \nu_{y})|^2$ ，如果 $H$ 的某些频率分量（尤其是高频）接近零，那么在这些频率上，分母 $|\hat{H}(\nu_{x}, \nu_{y})|^2$ 会非常小，导致反卷积结果中放大这些频率分量的噪声。反卷积图像中可以看到明显的颗粒状噪声。这是由于直接逆滤波在某些频率分量上产生了极大值，放大了噪声。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% Deconvolve Data2</span>
</span></span><span class="line"><span class="cl"><span class="n">x_2</span> <span class="p">=</span> <span class="n">deconvolve_image</span><span class="p">(</span><span class="n">Data2</span><span class="p">.</span><span class="n">Data</span><span class="p">,</span> <span class="n">Data2</span><span class="p">.</span><span class="n">IR</span><span class="p">,</span> <span class="n">mu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% Display the deconvolved image</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c">% Display the image, grayscale</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">Data2</span><span class="p">.</span><span class="n">Data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c">% Scale the axes and eliminate the grading</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">([</span><span class="s">&#39;Observed Image - Data2, \mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">imagesc</span><span class="p">(</span><span class="n">x_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">([</span><span class="s">&#39;Observed Image - Data2, \mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl"><span class="n">axis</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_18.png" alt="TP1_1"  />
</p>
<p>​	•	我们因此取不同的 $\mu$ 值(在 $\log_{10}$ 刻度上取值)。并且根据结果，确定合适的 $\mu$ 值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% Effect of Varying μ on Deconvolution Results</span>
</span></span><span class="line"><span class="cl"><span class="c">% Define a range of mu values on a log scale</span>
</span></span><span class="line"><span class="cl"><span class="n">mu_values</span> <span class="p">=</span> <span class="nb">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span> <span class="c">% From 1e-10 to 1</span>
</span></span><span class="line"><span class="cl"><span class="c">% Deconvolution and display for Data1</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">(</span><span class="s">&#39;Name&#39;</span><span class="p">,</span> <span class="s">&#39;Deconvolution Results for Data1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nb">i</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">mu_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">mu</span> <span class="p">=</span> <span class="n">mu_values</span><span class="p">(</span><span class="nb">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">x_1</span> <span class="p">=</span> <span class="n">deconvolve_image</span><span class="p">(</span><span class="n">Data1</span><span class="p">.</span><span class="n">Data</span><span class="p">,</span> <span class="n">Data1</span><span class="p">.</span><span class="n">IR</span><span class="p">,</span> <span class="n">mu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="nb">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">imagesc</span><span class="p">(</span><span class="n">x_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">axis</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">title</span><span class="p">([</span><span class="s">&#39;\mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="s">&#39;%.1e&#39;</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl"><span class="n">sgtitle</span><span class="p">(</span><span class="s">&#39;Deconvolved Images - Data1 with Different \mu Values&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_14.png" alt="TP1_1"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">% Deconvolution and display for Data2</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">(</span><span class="s">&#39;Name&#39;</span><span class="p">,</span> <span class="s">&#39;Deconvolution Results for Data2&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nb">i</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">mu_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">mu</span> <span class="p">=</span> <span class="n">mu_values</span><span class="p">(</span><span class="nb">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">x_2</span> <span class="p">=</span> <span class="n">deconvolve_image</span><span class="p">(</span><span class="n">Data2</span><span class="p">.</span><span class="n">Data</span><span class="p">,</span> <span class="n">Data2</span><span class="p">.</span><span class="n">IR</span><span class="p">,</span> <span class="n">mu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="nb">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">imagesc</span><span class="p">(</span><span class="n">x_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">colormap</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">axis</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="s">&#39;off&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">title</span><span class="p">([</span><span class="s">&#39;\mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="s">&#39;%.1e&#39;</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl"><span class="n">sgtitle</span><span class="p">(</span><span class="s">&#39;Deconvolved Images - Data2 with Different \mu Values&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_15.png" alt="TP1_1"  />
</p>
<p>小的 $\mu$ 值时，可见图像噪声多，甚至都有可能完全被噪声埋没; 中等 $\mu$ 值 时，图像细节和噪声之间达到了较好的平衡; 当 $\mu$ 值过大时，图像变得过于平滑，细节逐渐丢失，尤其是当 $\mu = 1$ 时。我们目前只能通过视觉方法来选出较好的 $\mu$ 值，两数据最优 $\mu$ 值都大约等于 0.01，但是这样肯定是不行的，是不严谨的，是无法成为一名科研奇才的，因此我们和真实图像做数学比较。</p>
<p>2.4 超参数的作用</p>
<p>上一点使我们能够评估与反卷积问题相关的内在难度。它还表明，考虑重建图像期望正则性的先验信息可以获得更好的结果。这种方法因此使我们能够在两种信息源之间进行折衷：观测数据和可用的先验信息（关于正则性）。这是通过参数 $\mu$ 的值来实现的。在下面的研究中，选择一个最合适的 $\mu$ 值，以使反卷积图像既不过于平滑也不过于不规则。</p>
<p>因此，可以计算反卷积图像 $\hat{x}$ 和真实图像 $x^\star$ 之间的数值差异，作为正则化参数 $\mu$ 的函数。</p>
<p>为此，考虑以下三种距离函数：</p>
<div>
  $$\Delta_2(\mu) = \frac{\sum_{p,q} (\hat{x}_{p,q}(\mu) - x^{\star}_{p,q})^2}{\sum_{p,q} (x^{\star}_{p,q})^2} 
  = \frac{\|\hat{x}(\mu) - x^{\star}\|_2^2}{\|x^{\star}\|_2^2}$$
</div>
<div>
  $$\Delta_1(\mu) = \frac{\sum_{p,q} |\hat{x}_{p,q}(\mu) - x^{\star}_{p,q}|}{\sum_{p,q} |x^{\star}_{p,q}|} 
  = \frac{\|\hat{x}(\mu) - x^{\star}\|_1}{\|x^{\star}\|_1}$$
</div>
<div>
  $$\Delta_\infty(\mu) = \frac{\max_{p,q} |\hat{x}_{p,q}(\mu) - x^{\star}_{p,q}|}{\max_{p,q} |x^{\star}_{p,q}|} 
  = \frac{\|\hat{x}(\mu) - x^{\star}\|_\infty}{\|x^{\star}\|_\infty}$$
</div>
<p>当恢复的图像类似于真实图像时，这些距离接近于 0，当恢复的图像为零时，它们接近 1。</p>
<p>​	•	我们设定 $\mu$ 值在 $10^{-10}$ 和 $10^{10}$ 之间取对数间隔值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="c">%% Question 8</span>
</span></span><span class="line"><span class="cl"><span class="c">% Load TrueImage  (focus on Data2)</span>
</span></span><span class="line"><span class="cl"><span class="n">TrueImage</span> <span class="p">=</span> <span class="n">Data2</span><span class="p">.</span><span class="n">TrueImage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">mu</span><span class="p">=</span><span class="nb">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nb">i</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">val_mu</span><span class="p">=</span><span class="n">mu</span><span class="p">(</span><span class="nb">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c">% Deconvolve image with current mu</span>
</span></span><span class="line"><span class="cl">    <span class="n">x_hat_temp</span> <span class="p">=</span> <span class="n">deconvolve_image</span><span class="p">(</span><span class="n">Data2</span><span class="p">.</span><span class="n">Data</span><span class="p">,</span> <span class="n">Data2</span><span class="p">.</span><span class="n">IR</span><span class="p">,</span> <span class="n">val_mu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">delta_2</span><span class="p">(</span><span class="nb">i</span><span class="p">)=</span><span class="n">norm</span><span class="p">(</span><span class="n">x_hat_temp</span><span class="o">-</span><span class="n">TrueImage</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">TrueImage</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">delta_1</span><span class="p">(</span><span class="nb">i</span><span class="p">)=</span><span class="n">norm</span><span class="p">(</span><span class="n">x_hat_temp</span><span class="o">-</span><span class="n">TrueImage</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">TrueImage</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">delta_inf</span><span class="p">(</span><span class="nb">i</span><span class="p">)=</span><span class="n">norm</span><span class="p">(</span><span class="n">x_hat_temp</span><span class="o">-</span><span class="n">TrueImage</span><span class="p">,</span><span class="n">Inf</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">TrueImage</span><span class="p">,</span><span class="n">Inf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Find mu that minimizes each distance</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">min_delta_2</span><span class="p">,</span><span class="n">ind_min_delta_2</span><span class="p">]=</span><span class="n">min</span><span class="p">(</span><span class="n">delta_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">min_delta_1</span><span class="p">,</span><span class="n">ind_min_delta_1</span><span class="p">]=</span><span class="n">min</span><span class="p">(</span><span class="n">delta_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">min_delta_inf</span><span class="p">,</span><span class="n">ind_min_delta_inf</span><span class="p">]=</span><span class="n">min</span><span class="p">(</span><span class="n">delta_inf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">mu_min_delta_2</span> <span class="p">=</span> <span class="n">mu</span><span class="p">(</span><span class="n">ind_min_delta_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">mu_min_delta_1</span> <span class="p">=</span> <span class="n">mu</span><span class="p">(</span><span class="n">ind_min_delta_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">mu_min_delta_inf</span> <span class="p">=</span> <span class="n">mu</span><span class="p">(</span><span class="n">ind_min_delta_inf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Display the results</span>
</span></span><span class="line"><span class="cl"><span class="n">fprintf</span><span class="p">(</span><span class="s">&#39;Delta_2 的最小值为: %e，对应的 mu 为: %e\n&#39;</span><span class="p">,</span> <span class="n">min_delta_2</span><span class="p">,</span> <span class="n">mu_min_delta_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">fprintf</span><span class="p">(</span><span class="s">&#39;Delta_1 的最小值为: %e，对应的 mu 为: %e\n&#39;</span><span class="p">,</span> <span class="n">min_delta_1</span><span class="p">,</span> <span class="n">mu_min_delta_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">fprintf</span><span class="p">(</span><span class="s">&#39;Delta_inf 的最小值为: %e，对应的 mu 为: %e\n&#39;</span><span class="p">,</span> <span class="n">min_delta_inf</span><span class="p">,</span> <span class="n">mu_min_delta_inf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">% Plot the distances as functions of mu</span>
</span></span><span class="line"><span class="cl"><span class="n">figure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">loglog</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">delta_2</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span> <span class="s">&#39;LineWidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">hold</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">loglog</span><span class="p">(</span><span class="n">mu</span><span class="p">(</span><span class="n">ind_min_delta_2</span><span class="p">),</span> <span class="n">min_delta_2</span><span class="p">,</span> <span class="s">&#39;ro&#39;</span><span class="p">,</span> <span class="s">&#39;MarkerSize&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&#39;LineWidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;\mu&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;\Delta_2(\mu)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;\Delta_2 vs \mu&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">legend</span><span class="p">(</span><span class="s">&#39;\Delta_2(\mu)&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;Min at \mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu_min_delta_2</span><span class="p">,</span> <span class="s">&#39;%.1e&#39;</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">loglog</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">delta_1</span><span class="p">,</span> <span class="s">&#39;g-&#39;</span><span class="p">,</span> <span class="s">&#39;LineWidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">hold</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">loglog</span><span class="p">(</span><span class="n">mu</span><span class="p">(</span><span class="n">ind_min_delta_1</span><span class="p">),</span> <span class="n">min_delta_1</span><span class="p">,</span> <span class="s">&#39;ro&#39;</span><span class="p">,</span> <span class="s">&#39;MarkerSize&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&#39;LineWidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;\mu&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;\Delta_1(\mu)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;\Delta_1 vs \mu&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">legend</span><span class="p">(</span><span class="s">&#39;\Delta_1(\mu)&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;Min at \mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu_min_delta_1</span><span class="p">,</span> <span class="s">&#39;%.1e&#39;</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">loglog</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">delta_inf</span><span class="p">,</span> <span class="s">&#39;m-&#39;</span><span class="p">,</span> <span class="s">&#39;LineWidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">hold</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">loglog</span><span class="p">(</span><span class="n">mu</span><span class="p">(</span><span class="n">ind_min_delta_inf</span><span class="p">),</span> <span class="n">min_delta_inf</span><span class="p">,</span> <span class="s">&#39;ro&#39;</span><span class="p">,</span> <span class="s">&#39;MarkerSize&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&#39;LineWidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;\mu&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;\Delta_\infty(\mu)&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">title</span><span class="p">(</span><span class="s">&#39;\Delta_\infty vs \mu&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">grid</span> <span class="n">on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">legend</span><span class="p">(</span><span class="s">&#39;\Delta_\infty(\mu)&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;Min at \mu = &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">mu_min_delta_inf</span><span class="p">,</span> <span class="s">&#39;%.1e&#39;</span><span class="p">)]);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/img/Problem_inverse/TP1/TP1_16.png" alt="TP1_1"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl">		<span class="n">Delta_2</span> 的最小值为<span class="p">:</span> <span class="mf">4.887066e-02</span>，对应的 <span class="n">mu</span> 为<span class="p">:</span> <span class="mf">2.983647e-03</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">Delta_1</span> 的最小值为<span class="p">:</span> <span class="mf">1.337040e-01</span>，对应的 <span class="n">mu</span> 为<span class="p">:</span> <span class="mf">1.204504e-02</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">Delta_inf</span> 的最小值为<span class="p">:</span> <span class="mf">1.855954e-01</span>，对应的 <span class="n">mu</span> 为<span class="p">:</span> <span class="mf">7.564633e-03</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>和之前肉眼观察得到的 $\mu$ 值相比，可见差距还是挺大的。</p>
<p>​	本文内容均为 ’ <a href="https://formations.u-bordeaux.fr/#/details-formation?type=enseignement&id=53344">Problème inverse</a> ’ 课程下的实验部分。</p>
<p>​	具体实验PDF文稿见 <strong>Jean-François Giovanelli</strong> 老师官方网站: <a href="http://giovannelli.free.fr/">http://giovannelli.free.fr</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://zehua716.github.io/zh/posts/probability_cn/test/">
    <span class="title">下一页 »</span>
    <br>
    <span>tst title</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod</a></span> · 


    <span>
        
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a>  
        
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
