<!DOCTYPE html>
<html lang="zh" dir="ltr">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>3D重建理论 | 主页</title>
<meta name="keywords" content="图像处理, 计算机视觉">
<meta name="description" content="课程笔记，仅个人学习复习使用">
<meta name="author" content="Zehua">
<link rel="canonical" href="http://zehua.eu/zh/posts/signal_cn/3d%E9%87%8D%E5%BB%BA%E7%90%86%E8%AE%BA/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.555e8889a324a4e96ce6751e5a6db535bb380495bd716aff56431212ff61ae56.css" integrity="sha256-VV6IiaMkpOls5nUeWm21Nbs4BJW9cWr/VkMSEv9hrlY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://zehua.eu/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://zehua.eu/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://zehua.eu/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://zehua.eu/apple-touch-icon.png">
<link rel="mask-icon" href="http://zehua.eu/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://zehua.eu/zh/posts/signal_cn/3d%E9%87%8D%E5%BB%BA%E7%90%86%E8%AE%BA/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
    integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
    integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
    integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    }); 
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

<meta property="og:title" content="3D重建理论" />
<meta property="og:description" content="课程笔记，仅个人学习复习使用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://zehua.eu/zh/posts/signal_cn/3d%E9%87%8D%E5%BB%BA%E7%90%86%E8%AE%BA/" />
<meta property="og:image" content="http://zehua.eu/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-10-21T16:25:17+01:00" />
<meta property="article:modified_time" content="2024-11-12T17:12:35+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://zehua.eu/images/papermod-cover.png" />
<meta name="twitter:title" content="3D重建理论"/>
<meta name="twitter:description" content="课程笔记，仅个人学习复习使用"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://zehua.eu/zh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "信号处理",
      "item": "http://zehua.eu/zh/posts/signal_cn/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "3D重建理论",
      "item": "http://zehua.eu/zh/posts/signal_cn/3d%E9%87%8D%E5%BB%BA%E7%90%86%E8%AE%BA/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "3D重建理论",
  "name": "3D重建理论",
  "description": "课程笔记，仅个人学习复习使用",
  "keywords": [
    "图像处理", "计算机视觉"
  ],
  "articleBody": "1. 图像投影模型与3D重建理论 1.1. SLAM的概念 SLAM（Simultaneous Localization and Mapping，即同步定位与地图构建）。 通过估计每个相机的位置和场景的三维点，实现对场景的重建。 1.2. 逆向二维图像 从二维图像中提取三维场景的信息，即进行$3D$重建\n逆向投影\n图像是三维场景经过投影后的二维表示，要恢复三维信息，需要逆转这个投影过程。 建立一个数学模型，描述三维场景如何投影到二维图像中，然后尝试逆向求解。 1.3 针孔相机模型 1.3.1 模型概述 定义：针孔相机模型假设所有的光线都通过一个公共点，即光心（光学中心）。 优点：模型简单，易于逆向计算，在三维重建中广泛使用。 1.3.2 坐标系和符号约定 摄像机坐标系： 原点 $O _C$：光学中心，坐标为 $(0, 0, 0)$。 轴方向：建立右手坐标系，$X _C$ 向右，$Y _C$ 向下，$Z _C$ 指向后方（场景深度方向）。 优势：$Z$ 轴指向后方，物体深度为正，符合直觉。 1.3.3 三维点的投影到归一化焦平面 三维点表示： 点 $U$：坐标为 $(U _X, U _Y, U _Z)$，表示空间中的一个三维点。 归一化焦平面： 一个与光心 $O _C$ 距离为 $1$ 的平面（$Z _C = 1$），称为归一化聚焦平面。 将远处的三维点投影到此平面上。 1.3.4 齐次坐标与非齐次坐标 齐次坐标（Homogeneous Coordinates）：\n定义：在原有坐标后增加一个维度（通常为 $1$），方便表示投影和变换。 表示：对于二维点 $m = (m _X, m _Y)^\\top$，其齐次坐标为 $\\bar{m} = (m _X, m _Y, 1)^\\top$ 作用：齐次坐标方便矩阵运算，尤其是在投影和变换过程中。\n非齐次坐标（Inhomogeneous Coordinates）： 标准的笛卡尔坐标表示法，不包含额外的维度。 1.4 摄像机的线性校准 1.4.1 从归一化焦平面到图像平面 图像平面：\n坐标系：像素坐标系，通常以图像左上角为原点，向右为 $X$ 轴（列索引），向下为 $Y$ 轴。 目的：将归一化焦平面上的点映射到实际的图像像素坐标上。 线性变换：\n变换公式：\n$$\\begin{cases} P _U = f \\cdot m _X + U _0 \\\\ P _V = f \\cdot m _Y + V _0 \\end{cases}$$ 焦距 $f$ $m _X$, $m _Y$ 是归一化焦平面上的点 光学中心在图像平面中的坐标 $(U _0, V _0)$\n1.4.2 摄像机内参矩阵 将上述线性变换表示为矩阵形式 $$K = \\begin{pmatrix} f \u0026 0 \u0026 U _0 \\\\ 0 \u0026 f \u0026 V _0 \\\\ 0 \u0026 0 \u0026 1 \\end{pmatrix}$$ 矩阵映射关系： $$\\underline{P} = K \\cdot \\underline{m}$$ 其中，$\\underline{P}$ 是图像平面中的点的齐次坐标\n1.4.3 逆向过程 从图像平面到归一化焦平面： $$\\underline{M} = K^{-1} \\cdot \\underline{P}$$ 1.4.4 可视锥 表示相机能够看到的空间范围。通过将图像的四个角点转换到归一化焦平面，然后连接光学中心，形成视锥。 1.5 畸变建模与校正 1.5.1 相机畸变的来源 实际相机镜头的光学缺陷，尤其在广角镜头中，导致图像出现畸变，直线变曲，图像边缘出现拉伸或压缩。 1.5.2 畸变模型 畸变函数：\n将归一化焦平面上的理想点经过畸变函数（从理想图像到畸变图像），得到畸变后的点，此点为 $2D$ 实际畸变聚焦平面\n$$\\underline{m} _d = d(\\underline{m}, k)$$ 其中，$k$ 是畸变参数\n举个例子: 多项式径向畸变模型\n$$M _d = \\left(1 + k _1 \\|m\\| _2^2 + k _2 \\|m\\| _2^4 + \\dots \\right) m$$ 其中: $|m| _2^2 = m _x^2 + m _y^2$\n1.6 畸变校正的实现 1.6.1 任务描述 目标：将畸变的实际图像校正为理想的无畸变图像 1.6.2 实现步骤 定义参数: 理想的摄像机内参矩阵 $K _{\\text{ideal}}$ ; 畸变的摄像机内参矩阵 $K _{\\text{real}}$; 失真参数 $k$ 。\n对于每个理想图像的像素坐标，执行以下步骤\n将像素坐标转换到归一化焦平面：\n$$\\underline{m} _{\\text{ideal}} = K _{\\text{ideal}}^{-1} \\cdot \\underline{P} _{\\text{ideal}}$$ 应用畸变函数：\n$$\\underline{m} _d = d(\\underline{m} _{\\text{ideal}}, k)$$ 映射回实际图像坐标系：\n$$\\underline{P} _{\\text{real}} = K _{\\text{real}} \\cdot \\underline{m} _d$$ 插值：\n对 $\\underline{P} _{\\text{real}}$ 进行插值（由于坐标可能为非整数，可能要用双线性插值）\n生成校正后的图像\n2. 二维刚性变换和单应性 2.1 二维刚性变换 二维刚性变换包括平移和旋转\n2.1.1 旋转 $$\\mathbf{U}^c = \\overrightarrow{O _c U}^c \\quad \\mathbf{U}^w = \\overrightarrow{O _w U}^w$$ $$\\mathbf{R} _{wc} \\underline{\\mathbf{U}}^c = \\mathbf{R} _{wc} \\cdot \\overrightarrow{O _c U}^c = \\overrightarrow{O _w U}^w$$ 从一个参考系中选取一个向量然后转换到另一个坐标系中\n$\\mathbf{R} _{wc}$ 是一个正交矩阵\n2.1.2 平移 $$\\mathbf{T} _{wc} = \\overrightarrow{O _w O _c}^{w}$$ 2.1.3 刚性变换公式 $$\\mathbf{U}^w = \\mathbf{R} _{wc} \\cdot \\mathbf{U}^c + \\mathbf{T} _{wc}$$ 证明：\n$$\\mathbf{R} _{wc} \\cdot \\mathbf{U}^c + \\mathbf{T} _{wc} = \\mathbf{R} _{wc} \\cdot \\overrightarrow{O _c U}^c + \\overrightarrow{O _w O _c}^w = \\overrightarrow{O _c U}^w + \\overrightarrow{O _w O _c}^w = \\overrightarrow{O _w U}^w = \\mathbf{U}^w$$ 2.1.4 齐次坐标： $$\\underline{\\mathbf{U}}^w = \\begin{bmatrix} \\mathbf{U}^w \\\\ 1 \\end{bmatrix}$$ $$\\mathbf{M} _{wc} = \\begin{bmatrix} \\mathbf{R} _{wc} \u0026 \\mathbf{T} _{wc} \\\\ 0 \u0026 1 \\end{bmatrix} = \\begin{bmatrix} r _{11} \u0026 r _{12} \u0026 r _{13} \u0026 t _{x} \\\\ r _{21} \u0026 r _{22} \u0026 r _{23} \u0026 t _{y} \\\\ r _{31} \u0026 r _{32} \u0026 r _{33} \u0026 t _{z} \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix}$$ 2.1.5 反变换： $$\\mathbf{M} _{cw} = \\mathbf{M} _{wc}^{-1}$$ 2.1.6 变换的组合性： $$\\mathbf{M} _{ab} \\cdot \\mathbf{M} _{bc} = \\mathbf{M} _{ac}$$ 2.2 单应性 2.2.1 平面场景假设 $$\\mathbf{U} _i^A = z _i^A \\cdot \\underline{\\mathbf{m}} _{Ai}$$ 这个方程的意思就是，$ \\mathbf{U} _i ^ A $ 这个点可以由 $ \\underline{\\mathbf{m}} _{Ai}$ 来表示，怎么表示呢？$\\Rightarrow$ 乘它的深度即可（因为 $\\underline{\\mathbf{m}} _{Ai}$ 是单位深度）。\n2.2.2 寻找 $\\underline{\\mathbf{m}} _{Ai}$ 和 $\\underline{\\mathbf{m}} _{Bi}$ 之间的对应关系 光有这个方程，我们怎么找到 $\\underline{\\mathbf{m}} _{Ai}$ 和 $\\underline{\\mathbf{m}} _{Bi}$ 之间的对应关系呢，通俗来讲，怎么进行坐标对应变换呢？\n法线关键公式\n我们需要先回顾一个性质，来得到一个法线和平面间的关键公式\n在参考系 $A$ 中，平面 $P$ 的方程为：$ax + by + cz + d = 0$ 其中 $a, b, c$ 是平面法向量分量，$d$ 是常数项，代表平面 $P$ 和原点 $O _A$ 相对距离\n在向量形式中，平面方程可以化简为：\n$$\\mathbf{n} _A^\\top \\mathbf{U} _i^A + d = 0$$ $\\mathbf{n} _A^\\top$ 代表：向量 $P$ 在参考系 $A$ 中的法向量\n通过这个平面方程的向量形式，我们得到了一个带有法向量的一个很重要的公式。\n利用变量代换得到深度表达式\n将 $\\mathbf{U} _i^A = z _i^A \\cdot \\underline{\\mathbf{m}} _{A,i}$ 带入上式中\n$$\\mathbf{n} _A^\\top \\cdot z _i^A \\cdot \\underline{\\mathbf{m}} _{A,i} + d = 0 \\quad \\Rightarrow \\quad z _i^A = -\\dfrac{d}{\\mathbf{n} _A^\\top \\cdot \\underline{\\mathbf{m}} _{A,i}}$$ 这样，我们就把 $\\underline{\\mathbf{m}} _{Ai}$ 给引进来了，其中 $z _i^A = -\\dfrac{d}{\\mathbf{n} _A^\\top \\cdot \\underline{\\mathbf{m}} _{A,i}}$ 代表了深度。换句话说，我们利用 $\\mathbf{U} _i^A$ 的两个方程，将 $\\mathbf{U} _i^A$ 替换掉了，这样就得到 $z _i^A$ 深度，可是仍然解决不了问题 $\\Rightarrow$ 也就是说光有关于 $\\underline{\\mathbf{m}} _{Ai}$ 的方程是不够的，还需要从 $\\underline{\\mathbf{m}} _{Bi}$ 入手\n接下来我们找 $B$ 坐标系下的点 $\\underline{\\mathbf{m}} _{Bi}$\n我们从刚性变换公式入手 $\\mathbf{U}^w = \\mathbf{R} _{wc} \\cdot \\mathbf{U}^c + \\mathbf{T} _{wc}$ 可见从 $c$ 投影到 $w$ 只需要对 $\\mathbf{U}^c$ 进行变换即可，也就是说，为了得到 $\\underline{\\mathbf{m}} _{Bi}$ 只需要对 $\\underline{\\mathbf{m}} _{Ai}$ 进行刚性变换即可\n$$\\underline{\\mathbf{m}} _{B,i} = \\Pi \\left( \\mathbf{R} _{BA} \\mathbf{U} _i^A + \\mathbf{t} _{BA} \\right)$$ 其中 $\\Pi(\\cdot)$ 是投影函数\n$$\\underline{\\mathbf{m}} _{B,i}= \\Pi \\left( \\mathbf{R} _{BA} \\left( -\\dfrac{d}{\\mathbf{n} _A^\\top \\cdot \\underline{\\mathbf{m}} _{A,i}} \\right) \\cdot \\underline{\\mathbf{m}} _{A,i} + \\mathbf{t} _{BA} \\right)$$ 将上公式左右两边都乘 $-\\dfrac{\\mathbf{n} _A^\\top \\cdot \\underline{\\mathbf{m}} _{A,i}}{d}$\n$$\\underline{\\mathbf{m}} _{B,i}= \\Pi \\left( \\mathbf{R} _{BA} \\cdot \\underline{\\mathbf{m}} _{A,i} - \\dfrac{\\mathbf{n} _A^\\top \\cdot \\underline{\\mathbf{m}} _{A,i}}{d} \\cdot \\mathbf{t} _{BA} \\right)$$ $$\\underline{\\mathbf{m}} _{B,i} = \\Pi \\left( \\left( \\mathbf{R} _{BA} - \\dfrac{\\mathbf{t} _{BA} \\cdot \\mathbf{n} _A^\\top}{d} \\right) \\cdot \\underline{\\mathbf{m}} _{A,i} \\right)$$ 也就得到了各自归一化平面上 $A$ 点到 $B$ 点的对应关系\n问题：上述公式中左右两边都乘了 $-\\dfrac{\\mathbf{n} _A^\\top \\cdot \\underline{\\mathbf{m}} _{A,i}}{d}$，为什么保持不变？\n投影函数 $\\Pi(\\cdot)$ 的特点是它是一个比例不变的操作（即只看方向和相对位置，不看绝对尺度）。因此，即使我们在右边乘上 $-\\dfrac{\\mathbf{n} _A^\\top \\cdot \\underline{\\mathbf{m}} _{A,i}}{d}$，也不会影响等式成立的条件，因为投影结果相同\n2.2.3 寻找 $\\underline{\\mathbf{P}} _{A,i}$ 和 $\\underline{\\mathbf{P}} _{B,i}$ 之间的对应关系 我们已知：\n$$\\left\\{ \\begin{aligned} \\underline{\\mathbf{m}} _{A,i} = K _A^{-1} \\cdot \\underline{\\mathbf{P}} _{A,i}\\\\ \\underline{\\mathbf{m}} _{B,i} = K _B^{-1} \\cdot \\underline{\\mathbf{P}} _{B,i} \\end{aligned} \\right.$$ $\\underline{\\mathbf{P}} _{B,i} = K _B \\cdot \\underline{\\mathbf{m}} _{B,i} \\Rightarrow$ 将上面得到的 $\\underline{\\mathbf{m}} _{B,i}$ 带入\n$$\\underline{\\mathbf{P}} _{B,i} = K _B \\cdot \\Pi \\left( \\left( \\mathbf{R} _{BA} - \\dfrac{\\mathbf{t} _{BA} \\cdot \\mathbf{n} _A^\\top}{d} \\right) \\cdot \\underline{\\mathbf{m}} _{A,i} \\right)$$ $$\\underline{\\mathbf{P}} _{B,i} = K _B \\cdot \\Pi \\left( \\left( \\mathbf{R} _{BA} - \\dfrac{\\mathbf{t} _{BA} \\cdot \\mathbf{n} _A^\\top}{d} \\right) \\cdot K _A^{-1} \\cdot \\underline{\\mathbf{P}} _{A,i} \\right)$$ 回顾性质：\n$$K \\cdot \\Pi \\left( \\begin{bmatrix} a \\\\ b \\\\ c \\end{bmatrix} \\right) = \\Pi \\left( K \\cdot \\begin{bmatrix} a \\\\ b \\\\ c \\end{bmatrix} \\right)$$ 利用此性质，可得：\n$$\\underline{\\mathbf{P}} _{B,i} = \\Pi \\left( K _B \\cdot \\left( \\mathbf{R} _{BA} - \\dfrac{\\mathbf{t} _{BA} \\cdot \\mathbf{n} _A^\\top}{d} \\right) \\cdot K _A^{-1} \\cdot \\underline{\\mathbf{P}} _{A,i}\\right)$$ 2.2.4 得到单应性矩阵 $\\mathbf{H} _{AB}$ 假设\n$$\\mathbf{H} _{AB} = K _B \\cdot \\left( \\mathbf{R} _{BA} - \\dfrac{\\mathbf{t} _{BA} \\cdot \\mathbf{n} _A^\\top}{d} \\right) \\cdot K _A^{-1}$$\n因此：\n$$\\left\\{ \\begin{aligned} \u0026\\underline{\\mathbf{P}} _{B,i} = \\Pi \\left( \\mathbf{H} _{BA} \\cdot \\underline{\\mathbf{P}} _{A,i} \\right) \\quad \\quad A \\Rightarrow B\\\\ \u0026\\underline{\\mathbf{P}} _{A,i} = \\Pi \\left( \\mathbf{H} _{BA}^{-1} \\cdot \\underline{\\mathbf{P}} _{B,i} \\right) = \\Pi \\left( \\mathbf{H} _{AB} \\cdot \\underline{\\mathbf{P}} _{B,i} \\right) \\quad \\quad B \\Rightarrow A \\\\ \\end{aligned} \\right.$$ 通过单应性矩阵我们可以将某点从一个相机图片坐标系变换到另一个相机图片坐标系，也就是点映射关系\n2.2.5 单应性矩阵估计求解 $$\\mathbf{H} _{AB} = \\begin{bmatrix} h _1 \u0026 h _4 \u0026 h _7 \\\\ h _2 \u0026 h _5 \u0026 h _8 \\\\ h _3 \u0026 h _6 \u0026 h _9 \\end{bmatrix}$$ 这是一个齐次矩阵，它有 $9$ 个参数 $h _1$ 到 $h _9$，齐次矩阵在尺度上具有冗余性，所以会导致自由度的丢失\n简单的解法–参数化（要估计的参数 = 自由参数） $$\\mathbf{H} _{AB} = \\begin{bmatrix} h _1 \u0026 h _4 \u0026 h _7 \\\\ h _2 \u0026 h _5 \u0026 h _8 \\\\ h _3 \u0026 h _6 \u0026 1 \\end{bmatrix}$$ $$\\mathbf{h} = \\begin{bmatrix} h _1 \\\\ \\vdots \\\\ h _8 \\end{bmatrix}$$ 如何估计 $\\mathbf{h}$？\n在这种情况下只要我们了解一个对应点就可以求得 $h _1$ 到 $h _8$ $$\\underline{\\mathbf{P}} _{A,i} = \\Pi \\left( \\begin{bmatrix} h _1 \u0026 h _4 \u0026 h _7 \\\\ h _2 \u0026 h _5 \u0026 h _8 \\\\ h _3 \u0026 h _6 \u0026 1 \\end{bmatrix} \\cdot \\underline{\\mathbf{P}} _{B,i} \\right)$$ 由于 $\\underline{\\mathbf{P}} _{A,i}$，$\\underline{\\mathbf{P}} _{B,i}$ 是齐次坐标，我们将其展开：\n$$\\begin{bmatrix} P _{A,i,x} \\\\ P _{A,i,y} \\\\ 1 \\end{bmatrix} = \\Pi \\left( \\begin{bmatrix} h _1 \u0026 h _4 \u0026 h _7 \\\\ h _2 \u0026 h _5 \u0026 h _8 \\\\ h _3 \u0026 h _6 \u0026 1 \\end{bmatrix} \\cdot \\begin{bmatrix} P _{B,i,x} \\\\ P _{B,i,y} \\\\ 1 \\end{bmatrix} \\right)$$ $$\\left\\{ \\begin{aligned} P _{A,i,x} = \\dfrac{h _1 \\cdot P _{B,i,x} + h _4 \\cdot P _{B,i,y} + h _7}{h _3 \\cdot P _{B,i,x} + h _6 \\cdot P _{B,i,y} + 1} \\\\ P _{A,i,y} = \\dfrac{h _2 \\cdot P _{B,i,x} + h _5 \\cdot P _{B,i,y} + h _8}{h _3 \\cdot P _{B,i,x} + h _6 \\cdot P _{B,i,y} + 1} \\end{aligned} \\right.$$ $$\\left\\{ \\begin{aligned} P _{A,i,x} \\cdot \\left( h _3 \\cdot P _{B,i,x} + h _6 \\cdot P _{B,i,y} + 1 \\right) = h _1 \\cdot P _{B,i,x} + h _4 \\cdot P _{B,i,y} + h _7 \\\\ P _{A,i,y} \\cdot \\left( h _3 \\cdot P _{B,i,x} + h _6 \\cdot P _{B,i,y} + 1 \\right) = h _2 \\cdot P _{B,i,x} + h _5 \\cdot P _{B,i,y} + h _8 \\end{aligned} \\right.$$ $$\\begin{bmatrix} P _{B,i,x} \u0026 0 \u0026 -P _{A,i,x} \\cdot P _{B,i,x} \u0026 P _{B,i,y} \u0026 0 \u0026 -P _{A,i,x} \\cdot P _{B,i,y} \u0026 1 \u0026 0 \\\\ 0 \u0026 P _{B,i,x} \u0026 -P _{A,i,y} \\cdot P _{B,i,x} \u0026 0 \u0026 P _{B,i,y} \u0026 -P _{A,i,y} \\cdot P _{B,i,y} \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} h _1 \\\\ h _2 \\\\ h _3 \\\\ h _4 \\\\ h _5 \\\\ h _6 \\\\ h _7 \\\\ h _8 \\end{bmatrix} = \\begin{bmatrix} P _{A,i,x} \\\\ P _{A,i _y} \\end{bmatrix}$$ 因为有 $8$ 个未知数，需要八个独立的线性方程，而每对对应点可以提供两个对应方程（即方程 59），因此需要至少四对对应点。即需要四个匹配 $\\left( P _{A,i}, P _{B,i} \\right) \\quad i = 1, 2, 3, 4$。\n$\\Rightarrow \\mathbf{h}^* = \\arg\\min _{\\mathbf{h}} \\sum _{i=1}^{4} \\left\\lVert M _i \\mathbf{h} - P _{A,i} \\right\\rVert _2^2 \\Rightarrow$ 线性最小二乘法\n3. 使用 RANSAC 算法进行稳健的单应性估计 3.1 目标 图像对齐与拼接：通过估计两幅图像之间的单应性（Homography），实现图像的自动拼接。 3.2 自动建立对应关系—SIFT 算法 兴趣点检测 使用 SIFT 等算法在两幅图像中检测特征点（这段代码由老师提供），无需手动标记对应点，利用算法自动建立图像间的对应关系。 因此我们可以找到两幅图像中最相似的点对，但注意，点对并不一定正确对应。 也就是可能会出现错误匹配（离群点），这种情况下不可以直接用对应关系，我们将使用另一种算法叫做 RANSAC 来自动评估对应点之间的正确性，并得到最理想的 $H$ 矩阵并输出。 3.3 RANSAC 算法进行稳健估计 算法思想：\n随机抽样一致性（Random Sample Consensus） 是一种在存在离群点（错误点）的情况下估计模型参数（$H$）的稳健算法。 通过反复随机抽样，寻找最符合的模型。 $RANSAC$ 流程：\n重复 $N$ 次\n（迭代次数根据经验或计算确定）：\n随机选取 4 对匹配点：\n4 是估计单应性矩阵所需的最小匹配点数。 从所有的匹配点中随机选四个，不确定哪个对应关系正确，所以后续中有一个估计评判标准（欧几里得距离）。 估计单应性矩阵 $H^k$：\n使用选取的 4 对匹配点，通过 $DLT$ 算法（上个实验做过，其目的与作用是，在已知对应点的情况下，将一个相机视角转换到另一个相机视角）估计单应性矩阵。 计算误差并评估模型：\n对于所有匹配点（包括未选取的），将第二幅图像的点 $P _{B _i}$ 通过估计的 $H^k$ 转换，即 $H^k P _{B _i}$。\n计算变换后的点（估计点）与第一幅图像实际点 $P _{A _i}$ 之间的欧氏距离。\n定义代价函数\n：使用二值核（要么为 0 要么为 1）函数 $\\phi _c(d)$：\n当距离 $d \u003c \\tau$ 时，认为匹配正确，代价为 0。 当距离 $d \\geq \\tau$ 时，认为匹配错误，代价为 1。 总代价 $L^k = \\sum _{i} \\phi _c(|P _{A _i} - H^k P _{B _i}|)$\n更新最佳模型：\n如果当前代价 $L^k$ 小于之前的最小代价 $L$，则更新 $L$ 和对应的 $H$。 最终输出：\n具有最小代价的单应性矩阵 $H$。 阈值 $\\tau$ 的选择：\n$\\tau$ 是判断匹配是否为内点的距离阈值，通常根据图像分辨率和匹配精度选择，一般在 $0.5$ 到 $3$ 个像素之间。 选择过大会增加错误匹配，过小会忽略正确匹配。 3.4 为什么不用传统的二次代价函数 敏感性问题： 二次代价函数（如最小二乘法）对离群点非常敏感，如果某个点的误差很大，会导致代价函数值过大，这时即使其他点的误差很小也没有用。 稳健性： 二值核函数对那些特别大、离谱的点不敏感（都等于 1），能够有效抑制离群点的影响，使得估计结果更稳健。 其他核函数： 除了二值核函数，还存在其他稳健核函数，如 $Huber$ 核、$Lorentzian$ 核等，可以在一定程度上兼顾误差大小和稳健性。 3.5 RANSAC 算法的局限性 参数数量影响： 当模型参数数量增加时，所需的随机采样次数会指数增长，计算成本显著提高。 适用范围： RANSAC 适用于参数数量较少的情况，如直线拟合、基础矩阵和单应性估计等。 4. 立体视觉中的对极几何 到目前为止，我们已经研究了平面场景的情况，使用了单应性（Homography）来描述两个视图之间的关系。然而，对于一般的三维场景，平面假设不再成立。为此，我们引入了对极几何（Epipolar Geometry）。\n4.1 对极几何 对极几何可以通过一个示意图很好地解释：\n考虑两个相机，分别位于参考系 1 和参考系 2\n相机 1 的光心为 $O _1$，相机 2 的光心为 $O _2$，空间中的一点 $U$ 投影到两个相机的图像平面上，得到点 $\\underline{m} _1$ 和 $\\underline{m} _2$。\n问题描述：\n在一般情况下，我们无法对点 $U$ 做出任何假设（与之前的平面场景不同）。 我们需要找到一种方法，在不知道 $U$ 的情况下，建立 $\\underline{m} _1$ 和 $\\underline{m} _2$ 之间的关系。 4.2 对极平面和对极线 对极平面\n$U$ 和光心 $O _1$、$O _2$ 定义了一个平面 $\\Rightarrow$ 点 $m _1$、$m _2$、$O _1$、$O _2$ 共面 $\\Rightarrow$ 称为对极平面。\n$\\text{Contrainte épipolaire} = \\text{coplanarité}$，即 $\\underline{m} _1$、$\\underline{m} _2$、$O _1$、$O _2$ 共面。\n在立体视觉中，基础矩阵 $F$ 和本质矩阵 $E$ 都依赖于共面性条件来计算。\n对极线\n对极平面与两个相机的图像平面相交，分别得到对极线 $l _1$ 和 $l _2$。\n$m _2$ 是三维点 $U$ 在第二个图像平面的投影，但根据对极几何的约束，$m _2$ 必须位于对极线 $l _2$ 上。\n$\\Rightarrow$ 给定点 $m _1$ 的位置，可以通过基础矩阵 $F$ 确定对应的对极线 $l _2$：$l _2 = F \\cdot m _1$\n基础矩阵 $F$ 捕捉了两个相机之间的相对姿态和内在参数信息。这个公式表明，给定点 $m _1$，可以计算出 $m _2$ 必须位于的对极线 $l _2$。\n4.3 对极约束 目标：利用上述几何关系，形式化对极约束，建立 $m_1$ 和 $m_2$ 之间的数学关系。\n定义向量：\n$$\\left\\{ \\begin{aligned} \u0026\\mathbf{\\underline{m}_1} \\text{ is the vector from the optical center } O_1 \\text{ to the image point } \\underline{m}_1 \\quad \\overrightarrow{O_1 m_1}^{1} \\\\ \u0026\\mathbf{\\underline{m}_2} \\text{ is the vector from the optical center } O_2 \\text{ to the image point } \\underline{m}_2 \\quad \\overrightarrow{O_2 m_2}^{2} \\\\ \u0026\\mathbf{t_{12}} = \\overrightarrow{O_1 O_2}^{1} \\text{ is the translation vector between the two camera optical centers} \\end{aligned} \\right.$$ 定义对极平面的法向量：\n$$\\left\\{ \\begin{aligned} \u0026\\text{In reference frame } 1, \\quad \\overrightarrow{\\mathbf{n}_1}^{1} = \\underline{\\mathbf{m}}_1 \\times \\mathbf{t}_{12} \\\\ \u0026\\text{In reference frame } 2, \\quad \\overrightarrow{\\mathbf{n}_2}^{2} = \\mathbf{R}_{21} \\overrightarrow{\\mathbf{n}_1}^{1}, \\text{ where } \\mathbf{R} \\text{ is the rotation matrix between the cameras} \\end{aligned} \\right.$$ 注意：\n其中 $\\times$ 表示两个向量之间的叉积运算。叉积的结果是一个向量，它垂直于运算的两个向量，方向由右手定则决定，大小为这两个向量构成的平行四边形的面积。 法向量的坐标系变换不用考虑平移部分，因为单位法向量并不是坐标位置，方向向量在旋转过程中大小不变，不受平移的影响。总而言之，法向量只考虑旋转矩阵，而点则需要考虑旋转加平移。 $$\\overrightarrow{\\mathbf{n}_2}^{2} = \\mathbf{R}_{21} \\cdot \\overrightarrow{\\mathbf{n}_1}^{1} = \\mathbf{R}_{21} \\cdot \\left( \\underline{\\mathbf{m}}_1 \\times \\mathbf{t}_{12} \\right) = \\mathbf{R}_{21} \\cdot \\underline{\\mathbf{m}}_1 \\times \\mathbf{R}_{21} \\cdot \\mathbf{t}_{12}$$ 由于之前我们已知 $\\mathbf{t} _{21} = \\mathbf{R} _{21} \\cdot \\mathbf{t} _{12}$，所以上式变为\n$$\\overrightarrow{\\mathbf{n}_2}^{2} = \\mathbf{t}_{21} \\times \\left( \\mathbf{R}_{21} \\cdot \\underline{\\mathbf{m}}_1 \\right)$$ 回顾叉积运算性质：\n$$\\mathbf{a} \\times \\mathbf{b} = \\begin{bmatrix} a_x \\\\ a_y \\\\ a_z \\end{bmatrix} \\times \\begin{bmatrix} b_x \\\\ b_y \\\\ b_z \\end{bmatrix} = \\begin{bmatrix} a_y b_z - a_z b_y \\\\ a_z b_x - a_x b_z \\\\ a_x b_y - a_y b_x \\end{bmatrix}_{3 \\times 1} \\Rightarrow \\left[\\mathbf{a}\\right]_{\\times} = \\begin{bmatrix} 0 \u0026 -a_z \u0026 a_y \\\\ a_z \u0026 0 \u0026 -a_x \\\\ -a_y \u0026 a_x \u0026 0 \\end{bmatrix}$$ $$\\mathbf{a} \\times \\mathbf{b} = \\left[\\mathbf{a}\\right]_{\\times} \\mathbf{b} = \\begin{bmatrix} 0 \u0026 -a_z \u0026 a_y \\\\ a_z \u0026 0 \u0026 -a_x \\\\ -a_y \u0026 a_x \u0026 0 \\end{bmatrix} \\begin{bmatrix} b_x \\\\ b_y \\\\ b_z \\end{bmatrix}$$ 利用上述性质，我们可以看出，叉积运算可以变成矩阵运算，因此我们利用以上性质得到：\n$$\\overrightarrow{\\mathbf{n}_2}^{2} = \\mathbf{t}_{21} \\times \\left( \\mathbf{R}_{21} \\cdot \\underline{\\mathbf{m}}_1 \\right) = \\left[ \\mathbf{t}_{21} \\right]_{\\times} \\cdot \\mathbf{R}_{21} \\cdot \\underline{\\mathbf{m}}_1$$ 因为 $\\overrightarrow{\\mathbf{n}_2}^{2}$ 是 $\\mathbf{m}_2$ 的法线 $\\Rightarrow \\mathbf{m}_2^\\top \\cdot \\overrightarrow{\\mathbf{n}_2}^{2} = 0$\n$$\\mathbf{m}_2^\\top \\cdot \\left[ \\mathbf{t}_{21} \\right]_{\\times} \\cdot \\mathbf{R}_{21} \\cdot \\underline{\\mathbf{m}}_1 = 0$$ $$\\mathbf{m}_2^\\top \\cdot \\left( \\left[ \\mathbf{t}_{21} \\right]_{\\times} \\cdot \\mathbf{R}_{21} \\right) \\cdot \\underline{\\mathbf{m}}_1 = 0$$ 4.4 本质矩阵（matrice essentielle） 公式\n假设 $\\mathbf{E} _{21} = \\left[ \\mathbf{t} _{21} \\right] _{\\times} \\cdot \\mathbf{R} _{21} \\quad \\Rightarrow \\quad \\text{matrice essentielle}$\n它包含了两个相机之间的相对旋转 $\\mathbf{R}$ 和平移 $\\mathbf{t}$ 的信息。\n原式 $ = \\underline{\\mathbf{m}} _2^\\top \\cdot \\mathbf{E} _{21} \\cdot \\underline{\\mathbf{m}} _1 = 0$\n自由度\n$$ 5 \\text{ degre de liberte} \\\\ \\downarrow\\\\ 5 \\text{ DDL} \\left( \\begin{array}{c} 3 , \\mathbf{R} _{21} \\quad \\text{rotation} \\\\ \\quad 2 , \\mathbf{t} _{21} \\quad \\text{translation} \\end{array} \\right)\\\\ \\downarrow\\\\ \\quad \\quad | \\mathbf{t} _{21} |_2 \\quad \\text{ inconnue} $$ 自由度：\n$$\\left\\{ \\begin{aligned} \u0026\\text{The rotation matrix } \\mathbf{R} \\text{ has 3 degrees of freedom} \\\\ \u0026\\text{The translation vector } \\mathbf{t} \\text{ has 2 degrees of freedom (since the scale is unknown)} \\\\ \u0026\\text{Therefore, } \\mathbf{E} \\text{ has 5 degrees of freedom} \\end{aligned} \\right.$$ 自由度（degree of freedom, DoF）是指描述本质矩阵所需的独立参数数量。在几何和线性代数中，自由度反映了系统在不受限制的情况下可以独立变化的方向或方式。 旋转矩阵具有 3 个自由度，描述了三维空间中的旋转。 平移向量理论上在三维空间中有 3 个自由度。但是本质矩阵中的平移向量一般只关注方向，对长度忽略（未知），所以平移向量只剩下 2 个有效的自由度，描述了平移的方向。 4.5 基础矩阵（Matrix Fundamental） 对上述公式继续变换：\n$$\\underline{\\mathbf{m}}_2^\\top \\cdot \\mathbf{E}_{21} \\cdot \\underline{\\mathbf{m}}_1 = 0$$ 已知：\n$$\\left\\{ \\begin{aligned} \\underline{\\mathbf{m}}_2 = K^{-1} \\cdot \\underline{\\mathbf{P}}_2 \\\\ \\underline{\\mathbf{m}}_1 = K^{-1} \\cdot \\underline{\\mathbf{P}}_1 \\end{aligned} \\right.$$ $$\\underline{\\mathbf{P}}_2^\\top \\cdot (K^{-1})^\\top \\cdot \\mathbf{E}_{21} \\cdot K^{-1} \\cdot \\underline{\\mathbf{P}}_1 = 0$$ 当相机内参未知或未被考虑时，我们引入一个基础矩阵 $\\mathbf{F}$ 来覆盖 $K$。\n假设 $\\mathbf{F} _{21}= (K^{-1})^\\top \\cdot \\mathbf{E} _{21} \\cdot K^{-1}$\n$$\\mathbf{F}_{21} : \\text{ matrice fondamentale} \\quad \\Rightarrow \\quad 7 \\text{ DDL}\\quad \\left\\{ \\begin{aligned} \u0026 \\text{- matrice homogène} \\\\ \u0026 \\text{- rang}(\\mathbf{F}_{21}) = 2 \\quad \\Rightarrow \\quad \\det(\\mathbf{F}_{21}) = 0 \\end{aligned} \\right.$$ 性质：\n$$\\left\\{ \\begin{aligned} \u0026\\text{齐次：基础矩阵 } \\mathbf{F} \\text{ 是齐次矩阵，可以乘以任意非零标量而不改变其性质} \\\\ \u0026\\text{秩约束：} \\mathbf{F} \\text{ 的秩为 } 2 \\end{aligned} \\right.$$ 原式 $= \\underline{\\mathbf{P}} _2^\\top \\cdot \\mathbf{F} _{21} \\cdot \\underline{\\mathbf{P}} _1 = 0$\n$$\\text{设：} \\quad \\mathbf{L}_2 = \\mathbf{F}_{21} \\cdot \\underline{\\mathbf{P}}_1 = \\begin{bmatrix} a \\\\ b \\\\ c \\end{bmatrix}$$ $$\\underline{\\mathbf{P}}_2^\\top \\cdot \\mathbf{L}_2 = 0 \\quad \\Leftrightarrow \\quad a P_{2,x} + b P_{2,y} + c = 0$$ 这就是相机 2 的图像平面中的直线方程 $\\Rightarrow$ 对极线\n4.6 本质和基础矩阵的估计 相机已经校准 $\\Rightarrow$ 本质矩阵 $\\mathbf{E}$ 的估计（5 个自由度）$\\Rightarrow$ 5 点对应算法\n相机未校准 $\\Rightarrow$ 基础矩阵 $\\mathbf{F}$ 的估计（7 个自由度）$\\Rightarrow$ 7 点对应算法\n求解 $\\Rightarrow$ 8 点对应算法 $\\Rightarrow$ 故意忽略约束条件 $\\det(\\mathbf{F}) = 0$\n4.7 算法 8 点对应算法步骤：\n收集匹配点对：\n$\\mathbf{F}$ 有 7 个自由度，但在算法中忽略了秩为 2 的约束，因此需要至少 8 对匹配点来估计 $\\mathbf{F}$。\n构建线性方程组\n对于每一对匹配点 $(\\mathbf{m} _1, \\mathbf{m} _2)$，构建方程：\n$$\\underline{\\mathbf{m}}_2^\\top \\cdot \\mathbf{E}_{21} \\cdot \\underline{\\mathbf{m}}_1 = 0$$ $$\\underline{\\mathbf{P}}_2^\\top \\cdot \\mathbf{F}_{21} \\cdot \\underline{\\mathbf{P}}_1 = 0$$ 求解：\n将方程组表示为：$\\underline{\\mathbf{P}} _2^\\top \\cdot \\mathbf{L} _2 = 0$\n$RANSAC$ 算法步骤\n处理匹配点对中的离群点（错误匹配），稳健地估计 $\\mathbf{F}$\n随机采样：利用 8 点对应算法 来估计 $\\mathbf{F}$ 评估模型：利用估计得到的 $\\mathbf{F}$ 来计算所有匹配点对的对极约束误差，即点到对应对极线的距离 判断内点：根据设定的距离阈值，判断哪些匹配点是内点 迭代：重复上述过程，直到找到内点数量最多的模型 5. Ajustement de faisceaux (束调整) 束调整是一种同时优化摄像机参数（包括位置、姿态和内参）和场景中三维点位置的技术 其核心思想是通过最小化三维点在图像上的重投影误差，使得优化后的模型与实际观测更加吻合 记住五个字：最小化投影误差 5.1 两个摄像机的情况 5.1.1 数据 $$\\left( P _{A,i}, P _{B,i} \\right) _{i=1,\\dots,N} \\implies N \\text{ correspondences}$$\n5.1.2 要估计的参数 摄像机的姿态以及三维点云数据集\n$$\\mathbf{R} _{W1} \\quad \\mathbf{t} _{W1} \\quad \\mathbf{R} _{W2} \\quad \\mathbf{t} _{W2} \\quad \\left\\{\\mathbf{U}^w_i \\right\\}_{i=1,\\dots,N}$$ 5.1.3 损失函数 $$\\mathcal{L} \\left( \\mathbf{R}_{w1}, \\mathbf{t}_{w1}, \\mathbf{R}_{w2}, \\mathbf{t}_{w2}, \\left\\{ \\mathbf{U}^w_i \\right\\}_{i=1,\\dots,N} \\right)= \\sum_{i=1}^{N} \\left( \\left\\lVert P_{1,i} - K_1 \\Pi \\left( \\mathbf{R}_{w1}^\\top \\mathbf{U}_i^{w} - \\mathbf{R}_{w1}^\\top \\mathbf{t}_{w1} \\right) \\right\\rVert_2^2 +\\left\\lVert P_{2,i} - K_2 \\Pi \\left( \\mathbf{R}_{w2}^\\top \\mathbf{U}_i^{w} - \\mathbf{R}_{w2}^\\top \\mathbf{t}_{w2} \\right) \\right\\rVert_2^2 \\right)$$ 其中：\n$K _A$ 和 $K _B$ 是摄像机 $A$ 和 $B$ 的内参矩阵。 $\\Pi(\\cdot)$ 是投影函数，将三维点投影到二维平面上。 $\\mathbf{R} _{w1}^\\top$ 和 $\\mathbf{R} _{w2}^\\top$ 等价于 $\\mathbf{R} _{1w}$ 和 $\\mathbf{R} _{2w}$，即将点从世界坐标系转换到摄像机坐标系。 $\\mathbf{R} _{w1}^\\top \\mathbf{t} _{w1}$ 等价于 $\\mathbf{t} _{1w}$，表示平移向量。 $\\mathbf{U} _i^{1}= \\mathbf{R} _{w1}^\\top \\cdot \\mathbf{U} _i^{w} - \\mathbf{R} _{w1}^\\top \\cdot \\mathbf{t} _{w1}$，也就是将 $\\mathbf{U} _i^{w}$ 变换到 $\\mathbf{U} _i^{1}$，即从世界坐标系变换到相机坐标系。 做差：相机 $A$ 或 $B$ 中的图像坐标（实际）减去三维空间旋转变换得来的估计图像坐标，等于重投影误差。 5.2 多个摄像机的情况 5.2.1 数据 每张图像中检测到的点为：\n$$\\left\\{ \\left\\{ P _{m,i} \\right\\} _{i=1,\\dots,N _m} \\right\\} _{m=1,\\dots,M}$$ 这些点在不同视角下的图像中可以形成轨迹（tracks）\n第 $m$ 个摄像机检测到的点，其中 $N _m$ 是第 $m$ 个摄像机检测到的点的数量\n$$\\left\\{ \\text{p2d-id} _m, \\ \\text{p3d-id} _m \\right\\} _{m=1,\\dots,M}$$ 其中：\n$\\text{p2d-id} _m$ 是二维点在图像中的索引 $\\text{p3d-id} _m$ 是对应的三维点在点云中的索引 它们的大小尺寸都是 $C _m \\times 1$ 5.2.2 要估计的参数 相机外参：\n$$ \\left\\{ \\left( \\mathbf{R} _{wm}, \\mathbf{t} _{wm} \\right) \\right\\} _{m=1,\\dots,M} $$ 三维点的位置：\n$$ \\left\\{ \\mathbf{U} _i^{w} \\right\\} _{i=1,\\dots,N} $$ 5.2.3 损失函数 代价函数扩展为对所有摄像机和所有检测到的点进行误差计算，将投影点与实际观测点之间的距离最小化：\n$$\\mathcal{L}(x) = \\sum_{m=1}^{M} \\sum_{c=1}^{C_m} \\left\\| P_{m,\\ \\text{p2d-id}_m(c)} - K_m \\Pi \\left( \\mathbf{R}_{wm}^\\top \\mathbf{U}_{\\text{p3d-id}_m(c)}^{w} - \\mathbf{R}_{wm}^\\top \\mathbf{t}_{wm} \\right) \\right\\|_2^2$$ $C _m$ 是第 $m$ 台摄像机的观测数量 $\\mathbf{U} _{\\text{p3d-id} _m(c)}^{w}$ 是与观测对应的三维点 我们可以简单地将上述代价函数简化成：\n$$\\mathcal{L}(x) = \\sum_{i=1}^{N} \\left\\| f_i(x) \\right\\|_2^2 \\quad \\left\\{ \\begin{array}{l} x \\in \\mathbb{R}^D \\\\ f_i : \\mathbb{R}^D \\rightarrow \\mathbb{R}^B \\end{array} \\right.$$ $x$ 是所有待优化的参数（摄像机参数和三维点坐标） $f _i(x)$ 是第 $i$ 个残差函数，表示第 $i$ 个观测的重投影误差 我们的目标是找到 $x$，使得 $\\mathcal{L}(x)$ 最小化。这是一个非线性最小二乘问题，通常使用迭代的方法求解 5.3 高斯牛顿算法 用于非线性最小二乘问题的一种迭代优化算法 $\\Rightarrow \\text{ iteratif } \\quad \\delta_{k+1} = \\delta_k + d_k$ $\\text{Linearisation de } f_i: \\quad f_i(x_k + d_k) \\approx f_i(x_k) + \\mathbf{J}_i(x_k)\\cdot d_k$\n$\\delta x$是参数的增量，需要求解\n对于每次迭代，我们在当前估计$x_k$附近对$f_i(x)$进行泰勒展开，并忽略高阶项\n$ f_i(\\delta_k + d_k) \\in \\mathbb{R}^B $\n$ f_i(\\delta_k) \\in \\mathbb{R}^B$ $\\mathbf{J}_i(\\delta_k) \\in \\mathbb{R}^{B \\times D} $ $ d_k \\in \\mathbb{R}^D $\n其中雅可比矩阵为:\n$$\\mathbf{J}_i(x_k) = \\frac{\\partial f_i(x_k + d_k)}{\\partial d_k} \\bigg|_{d_k=0}$$ 代表了在点 $x_k$ 处函数 $f_i$ 对于 $d_k$ 的偏导数，并且此偏导数是在 $d_k = 0$ 的条件下计算的 描述了在点$ x_k $处函数$ f_i $的线性变化率 线性最小二乘法 $$ L_k(d_k) = \\sum_{i=1}^{N} \\left| f_i(x_k) + \\mathbf{J}_i(x_k) \\cdot d_k \\right|_2^2 $$\n​\t$$\\quad \\mathbf{J}_k = \\begin{bmatrix} \\quad J_1(x_k) \\\\ \\quad J_2(x_k) \\\\ \\quad J_3(x_k) \\\\ ​ \\vdots \\\\ \\quad J_N(x_k) \\end{bmatrix} \\quad \\mathbf{b}_k = \\begin{bmatrix} \\quad f_1(x_k) \\\\ \\quad f_2(x_k) \\\\ \\quad \\vdots \\\\ \\quad f_N(x_k) \\end{bmatrix}$$\n$ \\mathbf{b}_k$是所有残差的组合 线性最小二乘问题变为： $$ L_k(d_k) = \\lVert b_k + J_k \\cdot d_k \\rVert_2^2 $$ 通过最小化$L_k(\\delta x)$，我们可以得到线性方程组：$J_k^T \\cdot J_k \\cdot d k = -J_k^T \\cdot b_k \\quad $\n$其中b_k ∝ \\text{ gradient}$\n左边的矩阵$\\mathbf{J}_k^T \\mathbf{J}_k$是海森矩阵的近似 右边的向量$-\\mathbf{J}_k^T \\mathbf{b}_k$是梯度的负值\n求解这个线性系统，得到参数更新$d_x$\nLevenberg-Marquardt算法\n在高斯-牛顿算法的基础上引入阻尼因子$\\lambda$，使得优化过程在接近解时具有高斯-牛顿的快速收敛特性，而在远离解时具有梯度下降的稳定性\n常用于非线性最小二乘问题的迭代优化算法\n目标函数: $L_k(d_k) = \\lVert b_k + J_k d_k \\rVert_2^2 + \\lambda \\lVert d_k \\rVert_2^2$ $\\quad \\quad \\Rightarrow (J_k^T J_k + \\lambda I_k)d_k = -J_k^T b_k$\n$\\lambda$是阻尼因子\n$$\\begin{cases} \\text{Si } \\lambda = 0 \u0026 \\Rightarrow \\text{Gauss-Newton} \\\\ \\text{Si } \\lambda \\rightarrow +\\infty \u0026 \\Rightarrow \\lambda d_k \\rightarrow -J_k^T b_k \\quad \\text{descente de gradient} \\end{cases}$$ 如果新的代价函数值降低了（说明更新有效），则减小$\\lambda$，使算法更接近高斯-牛顿法，加快收敛\n如果代价函数值没有降低， 则增大$\\lambda$，使算法更接近梯度下降法，保证稳定性\n5.4 算法步骤总结 在实际应用中，Levenberg-Marquardt算法的步骤如下：\n初始化：\n设定初始参数$x$和阻尼因子$\\lambda$ 计算初始代价函数$L_{\\min}$ 迭代：\n计算雅可比矩阵$\\mathbf{J}$和残差$\\mathbf{b}$\n求解线性系统：\n$ (J^T J + \\lambda I_d) d = -J^T b$\n更新参数：\n$x′=x+d$\n计算新的代价函数$L'$\n判断更新效果：\n如果$L’ \u003c L_{\\min}$（代价函数降低）： 接受更新：$x = x’$，$L_{\\min} = L'$ 减小$\\lambda$：$\\lambda = \\lambda / 2$ 继续迭代 否则（代价函数未降低）： 拒绝更新，不改变$x$ 增大$\\lambda$：$\\lambda = 2\\lambda$ 检查$\\lambda$是否超过最大值，若超过则停止迭代 终止条件：\n当$\\lambda$超过预设的最大值，或者参数更新的幅度小于阈值时，停止迭代 ",
  "wordCount" : "2834",
  "inLanguage": "zh",
  "image": "http://zehua.eu/images/papermod-cover.png","datePublished": "2024-10-21T16:25:17+01:00",
  "dateModified": "2024-11-12T17:12:35+08:00",
  "author":{
    "@type": "Person",
    "name": "Zehua"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://zehua.eu/zh/posts/signal_cn/3d%E9%87%8D%E5%BB%BA%E7%90%86%E8%AE%BA/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "主页",
    "logo": {
      "@type": "ImageObject",
      "url": "http://zehua.eu/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://zehua.eu/zh/" accesskey="h" title="主页 (Alt + H)">主页</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://zehua.eu/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://zehua.eu/zh/posts/" title="列表">
                    <span>列表</span>
                </a>
            </li>
            <li>
                <a href="http://zehua.eu/zh/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://zehua.eu/zh/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="http://zehua.eu/zh/about/" title="版权说明">
                    <span>版权说明</span>
                </a>
            </li>
            <li>
                <a href="http://zehua.eu/zh/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://zehua.eu/zh/">主页</a>&nbsp;»&nbsp;<a href="http://zehua.eu/zh/posts/">Posts</a>&nbsp;»&nbsp;<a href="http://zehua.eu/zh/posts/signal_cn/">信号处理</a></div>
    <h1 class="post-title entry-hint-parent">
      3D重建理论
    </h1>
    <div class="post-description">
      课程笔记，仅个人学习复习使用
    </div>
    <div class="post-meta">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/all.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/v4-shims.css"><span class="meta-tag"><span class="fa fa-calendar-plus-o"></span>&nbsp;<span title='2024-10-21 16:25:17 +0100 +0100'>10月21日, 2024</span></span>&nbsp; | &nbsp;<span class="meta-tag"><span class="fa fa-file-word-o"></span>&nbsp;<span>共2834字</span></span>&nbsp; | &nbsp;<span class="meta-tag"><span class="fa fa-user-circle-o"></span>&nbsp;<span>Zehua</span></span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#1-%e5%9b%be%e5%83%8f%e6%8a%95%e5%bd%b1%e6%a8%a1%e5%9e%8b%e4%b8%8e3d%e9%87%8d%e5%bb%ba%e7%90%86%e8%ae%ba" aria-label="1. 图像投影模型与3D重建理论"><strong>1. 图像投影模型与3D重建理论</strong></a><ul>
                            
                    <li>
                        <a href="#11-slam%e7%9a%84%e6%a6%82%e5%bf%b5" aria-label="1.1. SLAM的概念"><strong>1.1. SLAM的概念</strong></a></li>
                    <li>
                        <a href="#12-%e9%80%86%e5%90%91%e4%ba%8c%e7%bb%b4%e5%9b%be%e5%83%8f" aria-label="1.2. 逆向二维图像"><strong>1.2. 逆向二维图像</strong></a></li>
                    <li>
                        <a href="#13-%e9%92%88%e5%ad%94%e7%9b%b8%e6%9c%ba%e6%a8%a1%e5%9e%8b" aria-label="1.3 针孔相机模型"><strong>1.3 针孔相机模型</strong></a><ul>
                            
                    <li>
                        <a href="#131-%e6%a8%a1%e5%9e%8b%e6%a6%82%e8%bf%b0" aria-label="1.3.1 模型概述"><strong>1.3.1 模型概述</strong></a></li>
                    <li>
                        <a href="#132-%e5%9d%90%e6%a0%87%e7%b3%bb%e5%92%8c%e7%ac%a6%e5%8f%b7%e7%ba%a6%e5%ae%9a" aria-label="1.3.2 坐标系和符号约定"><strong>1.3.2 坐标系和符号约定</strong></a></li>
                    <li>
                        <a href="#133-%e4%b8%89%e7%bb%b4%e7%82%b9%e7%9a%84%e6%8a%95%e5%bd%b1%e5%88%b0%e5%bd%92%e4%b8%80%e5%8c%96%e7%84%a6%e5%b9%b3%e9%9d%a2" aria-label="1.3.3 三维点的投影到归一化焦平面"><strong>1.3.3 三维点的投影到归一化焦平面</strong></a></li>
                    <li>
                        <a href="#134-%e9%bd%90%e6%ac%a1%e5%9d%90%e6%a0%87%e4%b8%8e%e9%9d%9e%e9%bd%90%e6%ac%a1%e5%9d%90%e6%a0%87" aria-label="1.3.4 齐次坐标与非齐次坐标"><strong>1.3.4 齐次坐标与非齐次坐标</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#14-%e6%91%84%e5%83%8f%e6%9c%ba%e7%9a%84%e7%ba%bf%e6%80%a7%e6%a0%a1%e5%87%86" aria-label="1.4 摄像机的线性校准"><strong>1.4 摄像机的线性校准</strong></a><ul>
                            
                    <li>
                        <a href="#141-%e4%bb%8e%e5%bd%92%e4%b8%80%e5%8c%96%e7%84%a6%e5%b9%b3%e9%9d%a2%e5%88%b0%e5%9b%be%e5%83%8f%e5%b9%b3%e9%9d%a2" aria-label="1.4.1 从归一化焦平面到图像平面"><strong>1.4.1 从归一化焦平面到图像平面</strong></a></li>
                    <li>
                        <a href="#142-%e6%91%84%e5%83%8f%e6%9c%ba%e5%86%85%e5%8f%82%e7%9f%a9%e9%98%b5" aria-label="1.4.2 摄像机内参矩阵"><strong>1.4.2 摄像机内参矩阵</strong></a></li>
                    <li>
                        <a href="#143-%e9%80%86%e5%90%91%e8%bf%87%e7%a8%8b" aria-label="1.4.3 逆向过程"><strong>1.4.3 逆向过程</strong></a></li>
                    <li>
                        <a href="#144-%e5%8f%af%e8%a7%86%e9%94%a5" aria-label="1.4.4 可视锥"><strong>1.4.4 可视锥</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#15-%e7%95%b8%e5%8f%98%e5%bb%ba%e6%a8%a1%e4%b8%8e%e6%a0%a1%e6%ad%a3" aria-label="1.5 畸变建模与校正"><strong>1.5 畸变建模与校正</strong></a><ul>
                            
                    <li>
                        <a href="#151-%e7%9b%b8%e6%9c%ba%e7%95%b8%e5%8f%98%e7%9a%84%e6%9d%a5%e6%ba%90" aria-label="1.5.1 相机畸变的来源"><strong>1.5.1 相机畸变的来源</strong></a></li>
                    <li>
                        <a href="#152-%e7%95%b8%e5%8f%98%e6%a8%a1%e5%9e%8b" aria-label="1.5.2 畸变模型"><strong>1.5.2 畸变模型</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#16--%e7%95%b8%e5%8f%98%e6%a0%a1%e6%ad%a3%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="1.6 畸变校正的实现"><strong>1.6  畸变校正的实现</strong></a><ul>
                            
                    <li>
                        <a href="#161-%e4%bb%bb%e5%8a%a1%e6%8f%8f%e8%bf%b0" aria-label="1.6.1 任务描述"><strong>1.6.1 任务描述</strong></a></li>
                    <li>
                        <a href="#162-%e5%ae%9e%e7%8e%b0%e6%ad%a5%e9%aa%a4" aria-label="1.6.2 实现步骤"><strong>1.6.2 实现步骤</strong></a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#2-%e4%ba%8c%e7%bb%b4%e5%88%9a%e6%80%a7%e5%8f%98%e6%8d%a2%e5%92%8c%e5%8d%95%e5%ba%94%e6%80%a7" aria-label="2. 二维刚性变换和单应性"><strong>2. 二维刚性变换和单应性</strong></a><ul>
                            
                    <li>
                        <a href="#21-%e4%ba%8c%e7%bb%b4%e5%88%9a%e6%80%a7%e5%8f%98%e6%8d%a2" aria-label="2.1 二维刚性变换"><strong>2.1 二维刚性变换</strong></a><ul>
                            
                    <li>
                        <a href="#211-%e6%97%8b%e8%bd%ac" aria-label="2.1.1 旋转"><strong>2.1.1 旋转</strong></a></li>
                    <li>
                        <a href="#212-%e5%b9%b3%e7%a7%bb" aria-label="2.1.2 平移"><strong>2.1.2 平移</strong></a></li>
                    <li>
                        <a href="#213-%e5%88%9a%e6%80%a7%e5%8f%98%e6%8d%a2%e5%85%ac%e5%bc%8f" aria-label="2.1.3 刚性变换公式"><strong>2.1.3 刚性变换公式</strong></a></li>
                    <li>
                        <a href="#214-%e9%bd%90%e6%ac%a1%e5%9d%90%e6%a0%87" aria-label="2.1.4 齐次坐标："><strong>2.1.4 齐次坐标：</strong></a></li>
                    <li>
                        <a href="#215-%e5%8f%8d%e5%8f%98%e6%8d%a2" aria-label="2.1.5 反变换："><strong>2.1.5 反变换：</strong></a></li>
                    <li>
                        <a href="#216-%e5%8f%98%e6%8d%a2%e7%9a%84%e7%bb%84%e5%90%88%e6%80%a7" aria-label="2.1.6 变换的组合性："><strong>2.1.6 变换的组合性：</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#22-%e5%8d%95%e5%ba%94%e6%80%a7" aria-label="2.2 单应性"><strong>2.2 单应性</strong></a><ul>
                            
                    <li>
                        <a href="#221-%e5%b9%b3%e9%9d%a2%e5%9c%ba%e6%99%af%e5%81%87%e8%ae%be" aria-label="2.2.1 平面场景假设"><strong>2.2.1 平面场景假设</strong></a></li>
                    <li>
                        <a href="#222-%e5%af%bb%e6%89%be-underlinemathbfm--_ai-%e5%92%8c-underlinemathbfm--_bi-%e4%b9%8b%e9%97%b4%e7%9a%84%e5%af%b9%e5%ba%94%e5%85%b3%e7%b3%bb" aria-label="2.2.2 寻找 $\underline{\mathbf{m}} _{Ai}$ 和 $\underline{\mathbf{m}} _{Bi}$ 之间的对应关系"><strong>2.2.2 寻找 $\underline{\mathbf{m}}  _{Ai}$ 和 $\underline{\mathbf{m}}  _{Bi}$ 之间的对应关系</strong></a></li>
                    <li>
                        <a href="#223-%e5%af%bb%e6%89%be-underlinemathbfp-_ai-%e5%92%8c-underlinemathbfp-_bi-%e4%b9%8b%e9%97%b4%e7%9a%84%e5%af%b9%e5%ba%94%e5%85%b3%e7%b3%bb" aria-label="2.2.3 寻找 $\underline{\mathbf{P}} _{A,i}$ 和 $\underline{\mathbf{P}} _{B,i}$ 之间的对应关系"><strong>2.2.3 寻找 $\underline{\mathbf{P}} _{A,i}$ 和 $\underline{\mathbf{P}} _{B,i}$ 之间的对应关系</strong></a></li>
                    <li>
                        <a href="#224-%e5%be%97%e5%88%b0%e5%8d%95%e5%ba%94%e6%80%a7%e7%9f%a9%e9%98%b5-mathbfh-_ab" aria-label="2.2.4 得到单应性矩阵 $\mathbf{H} _{AB}$"><strong>2.2.4 得到单应性矩阵 $\mathbf{H} _{AB}$</strong></a></li>
                    <li>
                        <a href="#225-%e5%8d%95%e5%ba%94%e6%80%a7%e7%9f%a9%e9%98%b5%e4%bc%b0%e8%ae%a1%e6%b1%82%e8%a7%a3" aria-label="2.2.5 单应性矩阵估计求解"><strong>2.2.5 单应性矩阵估计求解</strong></a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#3-%e4%bd%bf%e7%94%a8-ransac-%e7%ae%97%e6%b3%95%e8%bf%9b%e8%a1%8c%e7%a8%b3%e5%81%a5%e7%9a%84%e5%8d%95%e5%ba%94%e6%80%a7%e4%bc%b0%e8%ae%a1" aria-label="3. 使用 RANSAC 算法进行稳健的单应性估计"><strong>3. 使用 RANSAC 算法进行稳健的单应性估计</strong></a><ul>
                            
                    <li>
                        <a href="#31-%e7%9b%ae%e6%a0%87" aria-label="3.1 目标"><strong>3.1 目标</strong></a></li>
                    <li>
                        <a href="#32-%e8%87%aa%e5%8a%a8%e5%bb%ba%e7%ab%8b%e5%af%b9%e5%ba%94%e5%85%b3%e7%b3%bb---sift-%e7%ae%97%e6%b3%95" aria-label="3.2 自动建立对应关系&mdash;SIFT 算法"><strong>3.2 自动建立对应关系&mdash;SIFT 算法</strong></a><ul>
                            
                    <li>
                        <a href="#%e5%85%b4%e8%b6%a3%e7%82%b9%e6%a3%80%e6%b5%8b" aria-label="兴趣点检测"><strong>兴趣点检测</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#33-ransac-%e7%ae%97%e6%b3%95%e8%bf%9b%e8%a1%8c%e7%a8%b3%e5%81%a5%e4%bc%b0%e8%ae%a1" aria-label="3.3 RANSAC 算法进行稳健估计"><strong>3.3 RANSAC 算法进行稳健估计</strong></a></li>
                    <li>
                        <a href="#34-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e7%94%a8%e4%bc%a0%e7%bb%9f%e7%9a%84%e4%ba%8c%e6%ac%a1%e4%bb%a3%e4%bb%b7%e5%87%bd%e6%95%b0" aria-label="3.4 为什么不用传统的二次代价函数"><strong>3.4 为什么不用传统的二次代价函数</strong></a></li>
                    <li>
                        <a href="#35-ransac-%e7%ae%97%e6%b3%95%e7%9a%84%e5%b1%80%e9%99%90%e6%80%a7" aria-label="3.5 RANSAC 算法的局限性"><strong>3.5 RANSAC 算法的局限性</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#4-%e7%ab%8b%e4%bd%93%e8%a7%86%e8%a7%89%e4%b8%ad%e7%9a%84%e5%af%b9%e6%9e%81%e5%87%a0%e4%bd%95" aria-label="4. 立体视觉中的对极几何"><strong>4. 立体视觉中的对极几何</strong></a><ul>
                            
                    <li>
                        <a href="#41-%e5%af%b9%e6%9e%81%e5%87%a0%e4%bd%95" aria-label="4.1 对极几何"><strong>4.1 对极几何</strong></a></li>
                    <li>
                        <a href="#42-%e5%af%b9%e6%9e%81%e5%b9%b3%e9%9d%a2%e5%92%8c%e5%af%b9%e6%9e%81%e7%ba%bf" aria-label="4.2 对极平面和对极线"><strong>4.2 对极平面和对极线</strong></a></li>
                    <li>
                        <a href="#43-%e5%af%b9%e6%9e%81%e7%ba%a6%e6%9d%9f" aria-label="4.3 对极约束"><strong>4.3 对极约束</strong></a></li>
                    <li>
                        <a href="#44-%e6%9c%ac%e8%b4%a8%e7%9f%a9%e9%98%b5matrice-essentielle" aria-label="4.4 本质矩阵（matrice essentielle）"><strong>4.4 本质矩阵（matrice essentielle）</strong></a></li>
                    <li>
                        <a href="#45-%e5%9f%ba%e7%a1%80%e7%9f%a9%e9%98%b5matrix-fundamental" aria-label="4.5 基础矩阵（Matrix Fundamental）"><strong>4.5 基础矩阵（Matrix Fundamental）</strong></a></li>
                    <li>
                        <a href="#46-%e6%9c%ac%e8%b4%a8%e5%92%8c%e5%9f%ba%e7%a1%80%e7%9f%a9%e9%98%b5%e7%9a%84%e4%bc%b0%e8%ae%a1" aria-label="4.6 本质和基础矩阵的估计"><strong>4.6 本质和基础矩阵的估计</strong></a></li>
                    <li>
                        <a href="#47-%e7%ae%97%e6%b3%95" aria-label="4.7 算法"><strong>4.7 算法</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#5-ajustement-de-faisceaux--%e6%9d%9f%e8%b0%83%e6%95%b4" aria-label="5. Ajustement de faisceaux (束调整)"><strong>5. Ajustement de faisceaux</strong>  (<strong>束调整</strong>)</a><ul>
                            
                    <li>
                        <a href="#51-%e4%b8%a4%e4%b8%aa%e6%91%84%e5%83%8f%e6%9c%ba%e7%9a%84%e6%83%85%e5%86%b5" aria-label="5.1 两个摄像机的情况"><strong>5.1 两个摄像机的情况</strong></a><ul>
                            
                    <li>
                        <a href="#511-%e6%95%b0%e6%8d%ae" aria-label="5.1.1 数据"><strong>5.1.1 数据</strong></a></li>
                    <li>
                        <a href="#512-%e8%a6%81%e4%bc%b0%e8%ae%a1%e7%9a%84%e5%8f%82%e6%95%b0" aria-label="5.1.2 要估计的参数"><strong>5.1.2 要估计的参数</strong></a></li>
                    <li>
                        <a href="#513-%e6%8d%9f%e5%a4%b1%e5%87%bd%e6%95%b0" aria-label="5.1.3 损失函数"><strong>5.1.3 损失函数</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#52-%e5%a4%9a%e4%b8%aa%e6%91%84%e5%83%8f%e6%9c%ba%e7%9a%84%e6%83%85%e5%86%b5" aria-label="5.2 多个摄像机的情况"><strong>5.2 多个摄像机的情况</strong></a><ul>
                            
                    <li>
                        <a href="#521-%e6%95%b0%e6%8d%ae" aria-label="5.2.1 数据"><strong>5.2.1 数据</strong></a></li>
                    <li>
                        <a href="#522-%e8%a6%81%e4%bc%b0%e8%ae%a1%e7%9a%84%e5%8f%82%e6%95%b0" aria-label="5.2.2 要估计的参数"><strong>5.2.2 要估计的参数</strong></a></li>
                    <li>
                        <a href="#523-%e6%8d%9f%e5%a4%b1%e5%87%bd%e6%95%b0" aria-label="5.2.3 损失函数"><strong>5.2.3 损失函数</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#53--%e9%ab%98%e6%96%af%e7%89%9b%e9%a1%bf%e7%ae%97%e6%b3%95" aria-label="5.3 高斯牛顿算法"><strong>5.3  高斯牛顿算法</strong></a></li>
                    <li>
                        <a href="#54-%e7%ae%97%e6%b3%95%e6%ad%a5%e9%aa%a4%e6%80%bb%e7%bb%93" aria-label="5.4 算法步骤总结"><strong>5.4 算法步骤总结</strong></a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h2 id="1-图像投影模型与3d重建理论"><strong>1. 图像投影模型与3D重建理论</strong><a hidden class="anchor" aria-hidden="true" href="#1-图像投影模型与3d重建理论">#</a></h2>
<h3 id="11-slam的概念"><strong>1.1. SLAM的概念</strong><a hidden class="anchor" aria-hidden="true" href="#11-slam的概念">#</a></h3>
<ul>
<li>SLAM（Simultaneous Localization and Mapping，即同步定位与地图构建）。</li>
<li>通过估计每个相机的位置和场景的三维点，实现对场景的重建。</li>
</ul>
<h3 id="12-逆向二维图像"><strong>1.2. 逆向二维图像</strong><a hidden class="anchor" aria-hidden="true" href="#12-逆向二维图像">#</a></h3>
<p>从二维图像中提取三维场景的信息，即进行$3D$重建</p>
<p><strong>逆向投影</strong></p>
<ul>
<li>图像是三维场景经过投影后的二维表示，要恢复三维信息，需要逆转这个投影过程。</li>
<li>建立一个数学模型，描述三维场景如何投影到二维图像中，然后尝试逆向求解。</li>
</ul>
<h3 id="13-针孔相机模型"><strong>1.3 针孔相机模型</strong><a hidden class="anchor" aria-hidden="true" href="#13-针孔相机模型">#</a></h3>
<h4 id="131-模型概述"><strong>1.3.1 模型概述</strong><a hidden class="anchor" aria-hidden="true" href="#131-模型概述">#</a></h4>
<ul>
<li><strong>定义</strong>：针孔相机模型假设所有的光线都通过一个公共点，即光心（光学中心）。</li>
<li><strong>优点</strong>：模型简单，易于逆向计算，在三维重建中广泛使用。</li>
</ul>
<h4 id="132-坐标系和符号约定"><strong>1.3.2 坐标系和符号约定</strong><a hidden class="anchor" aria-hidden="true" href="#132-坐标系和符号约定">#</a></h4>
<ul>
<li><strong>摄像机坐标系</strong>：
<ul>
<li><strong>原点 $O  _C$</strong>：光学中心，坐标为 $(0, 0, 0)$。</li>
<li><strong>轴方向</strong>：建立右手坐标系，$X  _C$ 向右，$Y  _C$ 向下，$Z  _C$ 指向后方（场景深度方向）。</li>
<li><strong>优势</strong>：$Z$ 轴指向后方，物体深度为正，符合直觉。</li>
</ul>
</li>
</ul>
<h4 id="133-三维点的投影到归一化焦平面"><strong>1.3.3 三维点的投影到归一化焦平面</strong><a hidden class="anchor" aria-hidden="true" href="#133-三维点的投影到归一化焦平面">#</a></h4>
<ul>
<li><strong>三维点表示</strong>：
<ul>
<li><strong>点 $U$</strong>：坐标为 $(U  _X, U  _Y, U  _Z)$，表示空间中的一个三维点。</li>
</ul>
</li>
<li><strong>归一化焦平面</strong>：
<ul>
<li>一个与光心 $O _C$ 距离为 $1$ 的平面（$Z _C = 1$），称为归一化聚焦平面。</li>
<li>将远处的三维点投影到此平面上。</li>
</ul>
</li>
</ul>
<h4 id="134-齐次坐标与非齐次坐标"><strong>1.3.4 齐次坐标与非齐次坐标</strong><a hidden class="anchor" aria-hidden="true" href="#134-齐次坐标与非齐次坐标">#</a></h4>
<p><strong>齐次坐标（Homogeneous Coordinates）</strong>：</p>
<ul>
<li><strong>定义</strong>：在原有坐标后增加一个维度（通常为 $1$），方便表示投影和变换。</li>
<li><strong>表示</strong>：对于二维点 $m = (m _X, m _Y)^\top$，其齐次坐标为 $\bar{m} = (m _X, m _Y, 1)^\top$</li>
</ul>
<p><strong>作用</strong>：齐次坐标方便矩阵运算，尤其是在投影和变换过程中。</p>
<ul>
<li><strong>非齐次坐标（Inhomogeneous Coordinates）</strong>：
<ul>
<li>标准的笛卡尔坐标表示法，不包含额外的维度。</li>
</ul>
</li>
</ul>
<h3 id="14-摄像机的线性校准"><strong>1.4 摄像机的线性校准</strong><a hidden class="anchor" aria-hidden="true" href="#14-摄像机的线性校准">#</a></h3>
<h4 id="141-从归一化焦平面到图像平面"><strong>1.4.1 从归一化焦平面到图像平面</strong><a hidden class="anchor" aria-hidden="true" href="#141-从归一化焦平面到图像平面">#</a></h4>
<ul>
<li>
<p><strong>图像平面</strong>：</p>
<ul>
<li><strong>坐标系</strong>：像素坐标系，通常以图像左上角为原点，向右为 $X$ 轴（列索引），向下为 $Y$ 轴。</li>
<li><strong>目的</strong>：将归一化焦平面上的点映射到实际的图像像素坐标上。</li>
</ul>
</li>
<li>
<p><strong>线性变换</strong>：</p>
</li>
<li>
<p><strong>变换公式</strong>：</p>
<div>$$\begin{cases} P _U = f \cdot m _X + U _0 \\ P _V = f \cdot m _Y + V _0 \end{cases}$$</div>
<ul>
<li><strong>焦距 $f$</strong></li>
<li>$m _X$, $m _Y$ <strong>是归一化焦平面上的点</strong></li>
</ul>
</li>
<li>
<p><strong>光学中心在图像平面中的坐标</strong> $(U _0, V _0)$</p>
</li>
</ul>
<h4 id="142-摄像机内参矩阵"><strong>1.4.2 摄像机内参矩阵</strong><a hidden class="anchor" aria-hidden="true" href="#142-摄像机内参矩阵">#</a></h4>
<ul>
<li>将上述线性变换表示为矩阵形式</li>
</ul>
<div>$$K = \begin{pmatrix} f & 0 & U _0 \\ 0 & f & V _0 \\ 0 & 0 & 1 \end{pmatrix}$$</div>
<ul>
<li><strong>矩阵映射关系</strong>：</li>
</ul>
<div>$$\underline{P} = K \cdot \underline{m}$$</div>
<p>其中，$\underline{P}$ 是图像平面中的点的齐次坐标</p>
<h4 id="143-逆向过程"><strong>1.4.3 逆向过程</strong><a hidden class="anchor" aria-hidden="true" href="#143-逆向过程">#</a></h4>
<ul>
<li><strong>从图像平面到归一化焦平面</strong>：</li>
</ul>
<div>$$\underline{M} = K^{-1} \cdot \underline{P}$$</div>
<h4 id="144-可视锥"><strong>1.4.4 可视锥</strong><a hidden class="anchor" aria-hidden="true" href="#144-可视锥">#</a></h4>
<ul>
<li>表示相机能够看到的空间范围。通过将图像的四个角点转换到归一化焦平面，然后连接光学中心，形成视锥。</li>
</ul>
<h3 id="15-畸变建模与校正"><strong>1.5 畸变建模与校正</strong><a hidden class="anchor" aria-hidden="true" href="#15-畸变建模与校正">#</a></h3>
<h4 id="151-相机畸变的来源"><strong>1.5.1 相机畸变的来源</strong><a hidden class="anchor" aria-hidden="true" href="#151-相机畸变的来源">#</a></h4>
<ul>
<li>实际相机镜头的光学缺陷，尤其在广角镜头中，导致图像出现畸变，直线变曲，图像边缘出现拉伸或压缩。</li>
</ul>
<h4 id="152-畸变模型"><strong>1.5.2 畸变模型</strong><a hidden class="anchor" aria-hidden="true" href="#152-畸变模型">#</a></h4>
<ul>
<li>
<p><strong>畸变函数</strong>：</p>
<ul>
<li>
<p>将归一化焦平面上的理想点经过畸变函数（从理想图像到畸变图像），得到畸变后的点，此点为 $2D$ 实际畸变聚焦平面</p>
<div>$$\underline{m} _d = d(\underline{m}, k)$$</div>
<p>其中，$k$ 是畸变参数</p>
</li>
</ul>
</li>
<li>
<p><strong>举个例子: 多项式径向畸变模型</strong></p>
<div>$$M _d = \left(1 + k _1 \|m\| _2^2 + k _2 \|m\| _2^4 + \dots \right) m$$</div>
<p>其中: $|m| _2^2 = m _x^2 + m _y^2$</p>
</li>
</ul>
<h3 id="16--畸变校正的实现"><strong>1.6  畸变校正的实现</strong><a hidden class="anchor" aria-hidden="true" href="#16--畸变校正的实现">#</a></h3>
<h4 id="161-任务描述"><strong>1.6.1 任务描述</strong><a hidden class="anchor" aria-hidden="true" href="#161-任务描述">#</a></h4>
<ul>
<li><strong>目标</strong>：将畸变的实际图像校正为理想的无畸变图像</li>
</ul>
<h4 id="162-实现步骤"><strong>1.6.2 实现步骤</strong><a hidden class="anchor" aria-hidden="true" href="#162-实现步骤">#</a></h4>
<p><strong>定义参数</strong>: 理想的摄像机内参矩阵 $K _{\text{ideal}}$ ; 畸变的摄像机内参矩阵 $K _{\text{real}}$; 失真参数 $k$ 。</p>
<p><strong>对于每个理想图像的像素坐标，执行以下步骤</strong></p>
<ol>
<li>
<p><strong>将像素坐标转换到归一化焦平面</strong>：</p>
<div>$$\underline{m} _{\text{ideal}} = K _{\text{ideal}}^{-1} \cdot \underline{P} _{\text{ideal}}$$</div>
</li>
<li>
<p><strong>应用畸变函数</strong>：</p>
<div>$$\underline{m} _d = d(\underline{m} _{\text{ideal}}, k)$$</div>
</li>
<li>
<p><strong>映射回实际图像坐标系</strong>：</p>
<div>$$\underline{P} _{\text{real}} = K _{\text{real}} \cdot \underline{m} _d$$</div>
</li>
<li>
<p><strong>插值</strong>：</p>
<p>对 $\underline{P} _{\text{real}}$ 进行插值（由于坐标可能为非整数，可能要用双线性插值）</p>
</li>
<li>
<p><strong>生成校正后的图像</strong></p>
</li>
</ol>
<h2 id="2-二维刚性变换和单应性"><strong>2. 二维刚性变换和单应性</strong><a hidden class="anchor" aria-hidden="true" href="#2-二维刚性变换和单应性">#</a></h2>
<h3 id="21-二维刚性变换"><strong>2.1 二维刚性变换</strong><a hidden class="anchor" aria-hidden="true" href="#21-二维刚性变换">#</a></h3>
<p>二维刚性变换包括<strong>平移</strong>和<strong>旋转</strong></p>
<h4 id="211-旋转"><strong>2.1.1 旋转</strong><a hidden class="anchor" aria-hidden="true" href="#211-旋转">#</a></h4>
<div>$$\mathbf{U}^c = \overrightarrow{O _c U}^c \quad \mathbf{U}^w = \overrightarrow{O _w U}^w$$</div>
<div>$$\mathbf{R} _{wc} \underline{\mathbf{U}}^c = \mathbf{R} _{wc} \cdot \overrightarrow{O _c U}^c = \overrightarrow{O _w U}^w$$</div>
<p>从一个参考系中选取一个向量然后转换到另一个坐标系中</p>
<p>$\mathbf{R} _{wc}$ 是一个正交矩阵</p>
<h4 id="212-平移"><strong>2.1.2 平移</strong><a hidden class="anchor" aria-hidden="true" href="#212-平移">#</a></h4>
<div>$$\mathbf{T} _{wc} = \overrightarrow{O _w O _c}^{w}$$</div>
<h4 id="213-刚性变换公式"><strong>2.1.3 刚性变换公式</strong><a hidden class="anchor" aria-hidden="true" href="#213-刚性变换公式">#</a></h4>
<div>$$\mathbf{U}^w = \mathbf{R} _{wc} \cdot \mathbf{U}^c + \mathbf{T} _{wc}$$</div>
<div
    class="alert alert-warning"    role="alert"><text><p><strong>证明：</strong></p>
<div>$$\mathbf{R} _{wc} \cdot \mathbf{U}^c + \mathbf{T} _{wc} = \mathbf{R} _{wc} \cdot \overrightarrow{O _c U}^c + \overrightarrow{O _w O _c}^w = \overrightarrow{O _c U}^w + \overrightarrow{O _w O _c}^w = \overrightarrow{O _w U}^w = \mathbf{U}^w$$</div></text></div>

<h4 id="214-齐次坐标"><strong>2.1.4 齐次坐标：</strong><a hidden class="anchor" aria-hidden="true" href="#214-齐次坐标">#</a></h4>
<div>$$\underline{\mathbf{U}}^w = \begin{bmatrix} \mathbf{U}^w \\ 1 \end{bmatrix}$$</div>
<div>$$\mathbf{M} _{wc} = \begin{bmatrix} \mathbf{R} _{wc} & \mathbf{T} _{wc} \\ 0 & 1 \end{bmatrix} = \begin{bmatrix} r _{11} & r _{12} & r _{13} & t _{x} \\ r _{21} & r _{22} & r _{23} & t _{y} \\ r _{31} & r _{32} & r _{33} & t _{z} \\ 0 & 0 & 0 & 1 \end{bmatrix}$$</div>
<h4 id="215-反变换"><strong>2.1.5 反变换：</strong><a hidden class="anchor" aria-hidden="true" href="#215-反变换">#</a></h4>
<div>$$\mathbf{M} _{cw} = \mathbf{M} _{wc}^{-1}$$</div>
<h4 id="216-变换的组合性"><strong>2.1.6 变换的组合性：</strong><a hidden class="anchor" aria-hidden="true" href="#216-变换的组合性">#</a></h4>
<div>$$\mathbf{M} _{ab} \cdot \mathbf{M} _{bc} = \mathbf{M} _{ac}$$</div>
<h3 id="22-单应性"><strong>2.2 单应性</strong><a hidden class="anchor" aria-hidden="true" href="#22-单应性">#</a></h3>
<h4 id="221-平面场景假设"><strong>2.2.1 平面场景假设</strong><a hidden class="anchor" aria-hidden="true" href="#221-平面场景假设">#</a></h4>
<div>$$\mathbf{U} _i^A = z _i^A \cdot \underline{\mathbf{m}} _{Ai}$$</div>
<p>这个方程的意思就是，$ \mathbf{U}  _i ^ A $ 这个点可以由 $ \underline{\mathbf{m}}  _{Ai}$ 来表示，怎么表示呢？$\Rightarrow$ 乘它的深度即可（因为 $\underline{\mathbf{m}}  _{Ai}$ 是单位深度）。</p>
<h4 id="222-寻找-underlinemathbfm--_ai-和-underlinemathbfm--_bi-之间的对应关系"><strong>2.2.2 寻找 $\underline{\mathbf{m}}  _{Ai}$ 和 $\underline{\mathbf{m}}  _{Bi}$ 之间的对应关系</strong><a hidden class="anchor" aria-hidden="true" href="#222-寻找-underlinemathbfm--_ai-和-underlinemathbfm--_bi-之间的对应关系">#</a></h4>
<p>光有这个方程，我们怎么找到 $\underline{\mathbf{m}}  _{Ai}$ 和 $\underline{\mathbf{m}}  _{Bi}$ 之间的对应关系呢，通俗来讲，怎么进行坐标对应变换呢？</p>
<ol>
<li>
<p><strong>法线关键公式</strong></p>
<p>我们需要先回顾一个性质，来得到一个法线和平面间的关键公式</p>
<p>在参考系 $A$ 中，平面 $P$ 的方程为：$ax + by + cz + d = 0$ 其中 $a, b, c$ 是平面法向量分量，$d$ 是常数项，代表平面 $P$ 和原点 $O _A$ 相对距离</p>
<p>在向量形式中，平面方程可以化简为：</p>
<div>$$\mathbf{n} _A^\top \mathbf{U} _i^A + d = 0$$</div>
<p>$\mathbf{n} _A^\top$ 代表：向量 $P$ 在参考系 $A$ 中的法向量</p>
<p>通过这个平面方程的向量形式，我们得到了一个带有法向量的一个很重要的公式。</p>
</li>
<li>
<p><strong>利用变量代换得到深度表达式</strong></p>
<p>将 $\mathbf{U} _i^A = z _i^A \cdot \underline{\mathbf{m}}  _{A,i}$ 带入上式中</p>
<div>$$\mathbf{n} _A^\top \cdot z _i^A \cdot \underline{\mathbf{m}} _{A,i} + d = 0 \quad \Rightarrow \quad z _i^A = -\dfrac{d}{\mathbf{n} _A^\top \cdot \underline{\mathbf{m}} _{A,i}}$$</div>
<p>这样，我们就把 $\underline{\mathbf{m}} _{Ai}$ 给引进来了，其中 $z  _i^A = -\dfrac{d}{\mathbf{n}  _A^\top \cdot \underline{\mathbf{m}}  _{A,i}}$ 代表了深度。换句话说，我们利用 $\mathbf{U} _i^A$ 的两个方程，将 $\mathbf{U} _i^A$ 替换掉了，这样就得到 $z _i^A$ 深度，可是仍然解决不了问题 $\Rightarrow$ 也就是说光有关于 $\underline{\mathbf{m}}  _{Ai}$ 的方程是不够的，还需要从 $\underline{\mathbf{m}}  _{Bi}$ 入手</p>
</li>
<li>
<p><strong>接下来我们找 $B$ 坐标系下的点 $\underline{\mathbf{m}} _{Bi}$</strong></p>
<p>我们从刚性变换公式入手 $\mathbf{U}^w = \mathbf{R} _{wc} \cdot \mathbf{U}^c + \mathbf{T} _{wc}$ 可见从 $c$ 投影到 $w$ 只需要对 $\mathbf{U}^c$ 进行变换即可，也就是说，为了得到 $\underline{\mathbf{m}}  _{Bi}$ 只需要对 $\underline{\mathbf{m}}  _{Ai}$ 进行刚性变换即可</p>
<div>$$\underline{\mathbf{m}} _{B,i} = \Pi \left( \mathbf{R} _{BA} \mathbf{U} _i^A + \mathbf{t} _{BA} \right)$$</div>
<p>其中 $\Pi(\cdot)$ 是投影函数</p>
<div>$$\underline{\mathbf{m}} _{B,i}= \Pi \left( \mathbf{R} _{BA} \left( -\dfrac{d}{\mathbf{n} _A^\top \cdot \underline{\mathbf{m}} _{A,i}} \right) \cdot \underline{\mathbf{m}} _{A,i} + \mathbf{t} _{BA} \right)$$</div>
<p>将上公式左右两边都乘 $-\dfrac{\mathbf{n} _A^\top \cdot \underline{\mathbf{m}} _{A,i}}{d}$</p>
<div>$$\underline{\mathbf{m}} _{B,i}= \Pi \left( \mathbf{R} _{BA} \cdot \underline{\mathbf{m}} _{A,i} - \dfrac{\mathbf{n} _A^\top \cdot \underline{\mathbf{m}} _{A,i}}{d} \cdot \mathbf{t} _{BA} \right)$$</div>
<div>$$\underline{\mathbf{m}} _{B,i} = \Pi \left( \left( \mathbf{R} _{BA} - \dfrac{\mathbf{t} _{BA} \cdot \mathbf{n} _A^\top}{d} \right) \cdot \underline{\mathbf{m}} _{A,i} \right)$$</div>
<p>也就得到了各自归一化平面上 $A$ 点到 $B$ 点的对应关系</p>
<p><strong>问题：上述公式中左右两边都乘了 $-\dfrac{\mathbf{n} _A^\top \cdot \underline{\mathbf{m}} _{A,i}}{d}$，为什么保持不变？</strong></p>
<p>投影函数 $\Pi(\cdot)$ 的特点是它是一个比例不变的操作（即只看方向和相对位置，不看绝对尺度）。因此，即使我们在右边乘上 $-\dfrac{\mathbf{n} _A^\top \cdot \underline{\mathbf{m}} _{A,i}}{d}$，也不会影响等式成立的条件，因为投影结果相同</p>
</li>
</ol>
<h4 id="223-寻找-underlinemathbfp-_ai-和-underlinemathbfp-_bi-之间的对应关系"><strong>2.2.3 寻找 $\underline{\mathbf{P}} _{A,i}$ 和 $\underline{\mathbf{P}} _{B,i}$ 之间的对应关系</strong><a hidden class="anchor" aria-hidden="true" href="#223-寻找-underlinemathbfp-_ai-和-underlinemathbfp-_bi-之间的对应关系">#</a></h4>
<p>我们已知：</p>
<div>$$\left\{ \begin{aligned} \underline{\mathbf{m}} _{A,i} = K _A^{-1} \cdot \underline{\mathbf{P}} _{A,i}\\ \underline{\mathbf{m}} _{B,i} = K _B^{-1} \cdot \underline{\mathbf{P}} _{B,i} \end{aligned} \right.$$</div>
<p>$\underline{\mathbf{P}} _{B,i} = K _B \cdot \underline{\mathbf{m}} _{B,i} \Rightarrow$ 将上面得到的 $\underline{\mathbf{m}} _{B,i}$ 带入</p>
<div>$$\underline{\mathbf{P}} _{B,i} = K _B \cdot \Pi \left( \left( \mathbf{R} _{BA} - \dfrac{\mathbf{t} _{BA} \cdot \mathbf{n} _A^\top}{d} \right) \cdot \underline{\mathbf{m}} _{A,i} \right)$$</div>
<div>$$\underline{\mathbf{P}} _{B,i} = K _B \cdot \Pi \left( \left( \mathbf{R} _{BA} - \dfrac{\mathbf{t} _{BA} \cdot \mathbf{n} _A^\top}{d} \right) \cdot K _A^{-1} \cdot \underline{\mathbf{P}} _{A,i} \right)$$</div>
<p>回顾性质：</p>
<div>$$K \cdot \Pi \left( \begin{bmatrix} a \\ b \\ c \end{bmatrix} \right) = \Pi \left( K \cdot \begin{bmatrix} a \\ b \\ c \end{bmatrix} \right)$$</div>
<p>利用此性质，可得：</p>
<div>$$\underline{\mathbf{P}} _{B,i} = \Pi \left( K _B \cdot \left( \mathbf{R} _{BA} - \dfrac{\mathbf{t} _{BA} \cdot \mathbf{n} _A^\top}{d} \right) \cdot K _A^{-1} \cdot \underline{\mathbf{P}} _{A,i}\right)$$</div>
<h4 id="224-得到单应性矩阵-mathbfh-_ab"><strong>2.2.4 得到单应性矩阵 $\mathbf{H} _{AB}$</strong><a hidden class="anchor" aria-hidden="true" href="#224-得到单应性矩阵-mathbfh-_ab">#</a></h4>
<p>假设</p>
<p>$$\mathbf{H} _{AB} = K _B \cdot \left( \mathbf{R} _{BA} - \dfrac{\mathbf{t} _{BA} \cdot \mathbf{n} _A^\top}{d} \right) \cdot K _A^{-1}$$</p>
<p>因此：</p>
<div>$$\left\{ \begin{aligned} &\underline{\mathbf{P}} _{B,i} = \Pi \left( \mathbf{H} _{BA} \cdot \underline{\mathbf{P}} _{A,i} \right) \quad \quad  A \Rightarrow B\\ &\underline{\mathbf{P}} _{A,i} = \Pi \left( \mathbf{H} _{BA}^{-1} \cdot \underline{\mathbf{P}} _{B,i} \right) = \Pi \left( \mathbf{H} _{AB} \cdot \underline{\mathbf{P}} _{B,i} \right) \quad \quad  B \Rightarrow A \\ \end{aligned} \right.$$</div>
<p>通过单应性矩阵我们可以将某点从一个相机图片坐标系变换到另一个相机图片坐标系，也就是点映射关系</p>
<h4 id="225-单应性矩阵估计求解"><strong>2.2.5 单应性矩阵估计求解</strong><a hidden class="anchor" aria-hidden="true" href="#225-单应性矩阵估计求解">#</a></h4>
<div>$$\mathbf{H} _{AB} = \begin{bmatrix} h _1 & h _4 & h _7 \\ h _2 & h _5 & h _8 \\ h _3 & h _6 & h _9 \end{bmatrix}$$</div>
<p>这是一个齐次矩阵，它有 $9$ 个参数 $h _1$ 到 $h _9$，齐次矩阵在尺度上具有冗余性，所以会导致自由度的丢失</p>
<ul>
<li>简单的解法&ndash;参数化（要估计的参数 = 自由参数）</li>
</ul>
<div>$$\mathbf{H} _{AB} = \begin{bmatrix} h _1 & h _4 & h _7 \\ h _2 & h _5 & h _8 \\ h _3 & h _6 & 1 \end{bmatrix}$$</div>
<div>$$\mathbf{h} = \begin{bmatrix} h _1 \\ \vdots \\ h _8 \end{bmatrix}$$</div>
<p>如何估计 $\mathbf{h}$？</p>
<ul>
<li>在这种情况下只要我们了解一个对应点就可以求得 $h _1$ 到 $h _8$</li>
</ul>
<div>$$\underline{\mathbf{P}} _{A,i} = \Pi \left( \begin{bmatrix} h _1 & h _4 & h _7 \\ h _2 & h _5 & h _8 \\ h _3 & h _6 & 1 \end{bmatrix} \cdot \underline{\mathbf{P}} _{B,i} \right)$$</div>
<p>由于 $\underline{\mathbf{P}} _{A,i}$，$\underline{\mathbf{P}} _{B,i}$ 是齐次坐标，我们将其展开：</p>
<div>$$\begin{bmatrix} P _{A,i,x} \\ P _{A,i,y} \\ 1 \end{bmatrix} = \Pi \left( \begin{bmatrix} h _1 & h _4 & h _7 \\ h _2 & h _5 & h _8 \\ h _3 & h _6 & 1 \end{bmatrix} \cdot \begin{bmatrix} P _{B,i,x} \\ P _{B,i,y} \\ 1 \end{bmatrix} \right)$$</div>
<div>$$\left\{ \begin{aligned} P _{A,i,x} = \dfrac{h _1 \cdot P _{B,i,x} + h _4 \cdot P _{B,i,y} + h _7}{h _3 \cdot P _{B,i,x} + h _6 \cdot P _{B,i,y} + 1} \\ P _{A,i,y} = \dfrac{h _2 \cdot P _{B,i,x} + h _5 \cdot P _{B,i,y} + h _8}{h _3 \cdot P _{B,i,x} + h _6 \cdot P _{B,i,y} + 1} \end{aligned} \right.$$</div>
<div>$$\left\{ \begin{aligned} P _{A,i,x} \cdot \left( h _3 \cdot P _{B,i,x} + h _6 \cdot P _{B,i,y} + 1 \right) = h _1 \cdot P _{B,i,x} + h _4 \cdot P _{B,i,y} + h _7 \\ P _{A,i,y} \cdot \left( h _3 \cdot P _{B,i,x} + h _6 \cdot P _{B,i,y} + 1 \right) = h _2 \cdot P _{B,i,x} + h _5 \cdot P _{B,i,y} + h _8 \end{aligned} \right.$$</div>
<div>$$\begin{bmatrix} P _{B,i,x} & 0 & -P _{A,i,x} \cdot P _{B,i,x} & P _{B,i,y} & 0 & -P _{A,i,x} \cdot P _{B,i,y} & 1 & 0 \\ 0 & P _{B,i,x} & -P _{A,i,y} \cdot P _{B,i,x} & 0 & P _{B,i,y} & -P _{A,i,y} \cdot P _{B,i,y} & 0 & 1 \end{bmatrix} \begin{bmatrix} h _1 \\ h _2 \\ h _3 \\ h _4 \\ h _5 \\ h _6 \\ h _7 \\ h _8 \end{bmatrix} = \begin{bmatrix} P _{A,i,x} \\ P _{A,i _y} \end{bmatrix}$$</div>
<p>因为有 $8$ 个未知数，需要八个独立的线性方程，而每对对应点可以提供两个对应方程（即方程 59），因此需要至少四对对应点。即需要四个匹配 $\left( P _{A,i}, P _{B,i} \right) \quad i = 1, 2, 3, 4$。</p>
<p>$\Rightarrow \mathbf{h}^* = \arg\min _{\mathbf{h}} \sum _{i=1}^{4} \left\lVert M _i \mathbf{h} - P _{A,i} \right\rVert _2^2 \Rightarrow$ 线性最小二乘法</p>
<h2 id="3-使用-ransac-算法进行稳健的单应性估计"><strong>3. 使用 RANSAC 算法进行稳健的单应性估计</strong><a hidden class="anchor" aria-hidden="true" href="#3-使用-ransac-算法进行稳健的单应性估计">#</a></h2>
<h3 id="31-目标"><strong>3.1 目标</strong><a hidden class="anchor" aria-hidden="true" href="#31-目标">#</a></h3>
<ul>
<li><strong>图像对齐与拼接</strong>：通过估计两幅图像之间的单应性（Homography），实现图像的自动拼接。</li>
</ul>
<h3 id="32-自动建立对应关系---sift-算法"><strong>3.2 自动建立对应关系&mdash;SIFT 算法</strong><a hidden class="anchor" aria-hidden="true" href="#32-自动建立对应关系---sift-算法">#</a></h3>
<h4 id="兴趣点检测"><strong>兴趣点检测</strong><a hidden class="anchor" aria-hidden="true" href="#兴趣点检测">#</a></h4>
<ul>
<li>使用 SIFT 等算法在两幅图像中检测特征点（这段代码由老师提供），无需手动标记对应点，利用算法自动建立图像间的对应关系。</li>
<li>因此我们可以找到两幅图像中最相似的点对，但注意，点对并不一定正确对应。</li>
<li>也就是可能会出现错误匹配（离群点），这种情况下不可以直接用对应关系，我们将使用另一种算法叫做 RANSAC 来自动评估对应点之间的正确性，并得到最理想的 $H$ 矩阵并输出。</li>
</ul>
<h3 id="33-ransac-算法进行稳健估计"><strong>3.3 RANSAC 算法进行稳健估计</strong><a hidden class="anchor" aria-hidden="true" href="#33-ransac-算法进行稳健估计">#</a></h3>
<ol>
<li>
<p>算法思想：</p>
<ul>
<li><strong>随机抽样一致性（Random Sample Consensus）</strong> 是一种在存在离群点（错误点）的情况下估计模型参数（$H$）的稳健算法。</li>
<li>通过反复随机抽样，寻找最符合的模型。</li>
</ul>
</li>
<li>
<p>$RANSAC$ 流程：</p>
<ul>
<li>
<p>重复 $N$ 次</p>
<p>（迭代次数根据经验或计算确定）：</p>
<ol>
<li>
<p>随机选取 4 对匹配点：</p>
<ul>
<li>4 是估计单应性矩阵所需的最小匹配点数。</li>
<li>从所有的匹配点中随机选四个，不确定哪个对应关系正确，所以后续中有一个估计评判标准（欧几里得距离）。</li>
</ul>
</li>
<li>
<p>估计单应性矩阵 $H^k$：</p>
<ul>
<li>使用选取的 4 对匹配点，通过 $DLT$ 算法（上个实验做过，其目的与作用是，在已知对应点的情况下，将一个相机视角转换到另一个相机视角）估计单应性矩阵。</li>
</ul>
</li>
<li>
<p>计算误差并评估模型：</p>
<ul>
<li>
<p>对于所有匹配点（包括未选取的），将第二幅图像的点 $P _{B _i}$ 通过估计的 $H^k$ 转换，即 $H^k P _{B _i}$。</p>
</li>
<li>
<p>计算变换后的点（估计点）与第一幅图像实际点 $P _{A _i}$ 之间的欧氏距离。</p>
<ul>
<li>
<p>定义代价函数</p>
<p>：使用二值核（要么为 0 要么为 1）函数 $\phi _c(d)$：</p>
<ul>
<li>当距离 $d &lt; \tau$ 时，认为匹配正确，代价为 0。</li>
<li>当距离 $d \geq \tau$ 时，认为匹配错误，代价为 1。</li>
</ul>
</li>
<li>
<p>总代价 $L^k = \sum _{i} \phi _c(|P _{A _i} - H^k P _{B _i}|)$</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>更新最佳模型：</p>
<ul>
<li>如果当前代价 $L^k$ 小于之前的最小代价 $L$，则更新 $L$ 和对应的 $H$。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>最终输出：</p>
<ul>
<li>具有最小代价的单应性矩阵 $H$。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>阈值 $\tau$ 的选择：</p>
<ul>
<li>$\tau$ 是判断匹配是否为内点的距离阈值，通常根据图像分辨率和匹配精度选择，一般在 $0.5$ 到 $3$ 个像素之间。</li>
<li>选择过大会增加错误匹配，过小会忽略正确匹配。</li>
</ul>
</li>
</ol>
<h3 id="34-为什么不用传统的二次代价函数"><strong>3.4 为什么不用传统的二次代价函数</strong><a hidden class="anchor" aria-hidden="true" href="#34-为什么不用传统的二次代价函数">#</a></h3>
<ul>
<li>敏感性问题：
<ul>
<li>二次代价函数（如最小二乘法）对离群点非常敏感，如果某个点的误差很大，会导致代价函数值过大，这时即使其他点的误差很小也没有用。</li>
</ul>
</li>
<li>稳健性：
<ul>
<li>二值核函数对那些特别大、离谱的点不敏感（都等于 1），能够有效抑制离群点的影响，使得估计结果更稳健。</li>
</ul>
</li>
<li>其他核函数：
<ul>
<li>除了二值核函数，还存在其他稳健核函数，如 $Huber$ 核、$Lorentzian$ 核等，可以在一定程度上兼顾误差大小和稳健性。</li>
</ul>
</li>
</ul>
<h3 id="35-ransac-算法的局限性"><strong>3.5 RANSAC 算法的局限性</strong><a hidden class="anchor" aria-hidden="true" href="#35-ransac-算法的局限性">#</a></h3>
<ul>
<li>参数数量影响：
<ul>
<li>当模型参数数量增加时，所需的随机采样次数会指数增长，计算成本显著提高。</li>
</ul>
</li>
<li>适用范围：
<ul>
<li>RANSAC 适用于参数数量较少的情况，如直线拟合、基础矩阵和单应性估计等。</li>
</ul>
</li>
</ul>
<h2 id="4-立体视觉中的对极几何"><strong>4. 立体视觉中的对极几何</strong><a hidden class="anchor" aria-hidden="true" href="#4-立体视觉中的对极几何">#</a></h2>
<p>到目前为止，我们已经研究了平面场景的情况，使用了单应性（Homography）来描述两个视图之间的关系。然而，对于一般的三维场景，平面假设不再成立。为此，我们引入了对极几何（Epipolar Geometry）。</p>
<h3 id="41-对极几何"><strong>4.1 对极几何</strong><a hidden class="anchor" aria-hidden="true" href="#41-对极几何">#</a></h3>
<p>对极几何可以通过一个示意图很好地解释：</p>
<ol>
<li>
<p><strong>考虑两个相机，分别位于参考系 1 和参考系 2</strong></p>
<p>相机 1 的光心为 $O _1$，相机 2 的光心为 $O _2$，空间中的一点 $U$ 投影到两个相机的图像平面上，得到点 $\underline{m} _1$ 和 $\underline{m} _2$。</p>
</li>
<li>
<p><strong>问题描述</strong>：</p>
<ul>
<li>在一般情况下，我们无法对点 $U$ 做出任何假设（与之前的平面场景不同）。</li>
<li>我们需要找到一种方法，在不知道 $U$ 的情况下，建立 $\underline{m} _1$ 和 $\underline{m} _2$ 之间的关系。</li>
</ul>
</li>
</ol>
<h3 id="42-对极平面和对极线"><strong>4.2 对极平面和对极线</strong><a hidden class="anchor" aria-hidden="true" href="#42-对极平面和对极线">#</a></h3>
<ol>
<li>
<p><strong>对极平面</strong></p>
<p>$U$ 和光心 $O _1$、$O _2$ 定义了一个平面 $\Rightarrow$ 点 $m _1$、$m _2$、$O _1$、$O _2$ 共面 $\Rightarrow$ 称为对极平面。</p>
<p>$\text{Contrainte épipolaire} = \text{coplanarité}$，即 $\underline{m} _1$、$\underline{m} _2$、$O _1$、$O _2$ 共面。</p>
<p>在立体视觉中，基础矩阵 $F$ 和本质矩阵 $E$ 都依赖于共面性条件来计算。</p>
</li>
<li>
<p><strong>对极线</strong></p>
<p>对极平面与两个相机的图像平面相交，分别得到对极线 $l _1$ 和 $l _2$。</p>
<p>$m _2$ 是三维点 $U$ 在第二个图像平面的投影，但根据对极几何的约束，$m _2$ 必须位于对极线 $l _2$ 上。</p>
<p>$\Rightarrow$ 给定点 $m _1$ 的位置，可以通过基础矩阵 $F$ 确定对应的对极线 $l _2$：$l _2 = F \cdot m _1$</p>
<p>基础矩阵 $F$ 捕捉了两个相机之间的相对姿态和内在参数信息。这个公式表明，给定点 $m _1$，可以计算出 $m _2$ 必须位于的对极线 $l _2$。</p>
</li>
</ol>
<h3 id="43-对极约束"><strong>4.3 对极约束</strong><a hidden class="anchor" aria-hidden="true" href="#43-对极约束">#</a></h3>
<p><strong>目标</strong>：利用上述几何关系，形式化对极约束，建立 $m_1$ 和 $m_2$ 之间的数学关系。</p>
<p><strong>定义向量：</strong></p>
<div>$$\left\{ \begin{aligned} 
&\mathbf{\underline{m}_1} \text{ is the vector from the optical center } O_1 \text{ to the image point } \underline{m}_1 \quad \overrightarrow{O_1 m_1}^{1} \\ 
&\mathbf{\underline{m}_2} \text{ is the vector from the optical center } O_2 \text{ to the image point } \underline{m}_2 \quad \overrightarrow{O_2 m_2}^{2} \\ 
&\mathbf{t_{12}} = \overrightarrow{O_1 O_2}^{1} \text{ is the translation vector between the two camera optical centers} 
\end{aligned} \right.$$</div>
<p><strong>定义对极平面的法向量：</strong></p>
<div>$$\left\{ \begin{aligned} 
&\text{In reference frame } 1, \quad \overrightarrow{\mathbf{n}_1}^{1} = \underline{\mathbf{m}}_1 \times \mathbf{t}_{12} \\ 
&\text{In reference frame } 2, \quad \overrightarrow{\mathbf{n}_2}^{2} = \mathbf{R}_{21} \overrightarrow{\mathbf{n}_1}^{1}, \text{ where } \mathbf{R} \text{ is the rotation matrix between the cameras} 
\end{aligned} \right.$$</div>
<p><strong>注意：</strong></p>
<ul>
<li>其中 $\times$ 表示两个向量之间的叉积运算。叉积的结果是一个向量，<strong>它垂直于运算的两个向量</strong>，方向由右手定则决定，大小为这两个向量构成的平行四边形的面积。</li>
<li>法向量的坐标系变换不用考虑平移部分，因为单位法向量并不是坐标位置，方向向量在旋转过程中大小不变，不受平移的影响。总而言之，法向量只考虑旋转矩阵，而点则需要考虑旋转加平移。</li>
</ul>
<div>$$\overrightarrow{\mathbf{n}_2}^{2} = \mathbf{R}_{21} \cdot \overrightarrow{\mathbf{n}_1}^{1} = \mathbf{R}_{21} \cdot \left( \underline{\mathbf{m}}_1 \times \mathbf{t}_{12} \right) = \mathbf{R}_{21} \cdot \underline{\mathbf{m}}_1 \times \mathbf{R}_{21} \cdot \mathbf{t}_{12}$$</div>
<p>由于之前我们已知 $\mathbf{t} _{21} = \mathbf{R} _{21} \cdot \mathbf{t} _{12}$，所以上式变为</p>
<div>$$\overrightarrow{\mathbf{n}_2}^{2} = \mathbf{t}_{21} \times \left( \mathbf{R}_{21} \cdot \underline{\mathbf{m}}_1 \right)$$</div>
<p><strong>回顾叉积运算性质：</strong></p>
<div>$$\mathbf{a} \times \mathbf{b} = \begin{bmatrix} a_x \\ a_y \\ a_z \end{bmatrix} \times \begin{bmatrix} b_x \\ b_y \\ b_z \end{bmatrix} = \begin{bmatrix} a_y b_z - a_z b_y \\ a_z b_x - a_x b_z \\ a_x b_y - a_y b_x \end{bmatrix}_{3 \times 1} \Rightarrow \left[\mathbf{a}\right]_{\times} = \begin{bmatrix} 0 & -a_z & a_y \\ a_z & 0 & -a_x \\ -a_y & a_x & 0 \end{bmatrix}$$</div>
<div>$$\mathbf{a} \times \mathbf{b} = \left[\mathbf{a}\right]_{\times} \mathbf{b} = \begin{bmatrix} 0 & -a_z & a_y \\ a_z & 0 & -a_x \\ -a_y & a_x & 0 \end{bmatrix} \begin{bmatrix} b_x \\ b_y \\ b_z \end{bmatrix}$$</div>
<p>利用上述性质，我们可以看出，叉积运算可以变成矩阵运算，因此我们利用以上性质得到：</p>
<div>$$\overrightarrow{\mathbf{n}_2}^{2} = \mathbf{t}_{21} \times \left( \mathbf{R}_{21} \cdot \underline{\mathbf{m}}_1 \right) = \left[ \mathbf{t}_{21} \right]_{\times} \cdot \mathbf{R}_{21} \cdot \underline{\mathbf{m}}_1$$</div>
<p>因为 $\overrightarrow{\mathbf{n}_2}^{2}$ 是 $\mathbf{m}_2$ 的法线 $\Rightarrow \mathbf{m}_2^\top \cdot \overrightarrow{\mathbf{n}_2}^{2} = 0$</p>
<div>$$\mathbf{m}_2^\top \cdot \left[ \mathbf{t}_{21} \right]_{\times} \cdot \mathbf{R}_{21} \cdot \underline{\mathbf{m}}_1 = 0$$</div>
<div>$$\mathbf{m}_2^\top \cdot \left( \left[ \mathbf{t}_{21} \right]_{\times} \cdot \mathbf{R}_{21} \right) \cdot \underline{\mathbf{m}}_1 = 0$$</div>
<h3 id="44-本质矩阵matrice-essentielle"><strong>4.4 本质矩阵（matrice essentielle）</strong><a hidden class="anchor" aria-hidden="true" href="#44-本质矩阵matrice-essentielle">#</a></h3>
<ol>
<li>
<p><strong>公式</strong></p>
<p>假设 $\mathbf{E} _{21} = \left[ \mathbf{t} _{21} \right] _{\times} \cdot \mathbf{R} _{21} \quad \Rightarrow \quad \text{matrice essentielle}$</p>
<p>它包含了两个相机之间的相对旋转 $\mathbf{R}$ 和平移 $\mathbf{t}$ 的信息。</p>
<p>原式 $ = \underline{\mathbf{m}} _2^\top \cdot \mathbf{E} _{21} \cdot \underline{\mathbf{m}} _1 = 0$</p>
</li>
<li>
<p><strong>自由度</strong></p>
<p>$$
5 \text{ degre de liberte} \\ \downarrow\\ 5 \text{ DDL} \left( \begin{array}{c} 3 , \mathbf{R} _{21} \quad \text{rotation} \\ \quad  2 , \mathbf{t} _{21} \quad \text{translation} \end{array} \right)\\ \downarrow\\ \quad \quad  | \mathbf{t} _{21} |_2 \quad   \text{ inconnue}
$$
<strong>自由度：</strong></p>
<div>$$\left\{ \begin{aligned} 
&\text{The rotation matrix } \mathbf{R} \text{ has 3 degrees of freedom} \\ 
&\text{The translation vector } \mathbf{t} \text{ has 2 degrees of freedom (since the scale is unknown)} \\ 
&\text{Therefore, } \mathbf{E} \text{ has 5 degrees of freedom} 
\end{aligned} \right.$$</div>
<ul>
<li>自由度（degree of freedom, DoF）是指描述本质矩阵所需的独立参数数量。在几何和线性代数中，自由度反映了系统在不受限制的情况下可以独立变化的方向或方式。</li>
<li>旋转矩阵具有 3 个自由度，描述了三维空间中的旋转。</li>
<li>平移向量理论上在三维空间中有 3 个自由度。但是本质矩阵中的平移向量一般只关注方向，对长度忽略（未知），所以平移向量只剩下 2 个有效的自由度，描述了平移的方向。</li>
</ul>
</li>
</ol>
<h3 id="45-基础矩阵matrix-fundamental"><strong>4.5 基础矩阵（Matrix Fundamental）</strong><a hidden class="anchor" aria-hidden="true" href="#45-基础矩阵matrix-fundamental">#</a></h3>
<p>对上述公式继续变换：</p>
<div>$$\underline{\mathbf{m}}_2^\top \cdot \mathbf{E}_{21} \cdot \underline{\mathbf{m}}_1 = 0$$</div>
<p>已知：</p>
<div>$$\left\{ \begin{aligned} \underline{\mathbf{m}}_2 = K^{-1} \cdot \underline{\mathbf{P}}_2 \\ \underline{\mathbf{m}}_1 = K^{-1} \cdot \underline{\mathbf{P}}_1 \end{aligned} \right.$$</div>
<div>$$\underline{\mathbf{P}}_2^\top \cdot (K^{-1})^\top \cdot \mathbf{E}_{21} \cdot K^{-1} \cdot \underline{\mathbf{P}}_1 = 0$$</div>
<p>当相机内参未知或未被考虑时，我们引入一个基础矩阵 $\mathbf{F}$ 来覆盖 $K$。</p>
<p>假设 $\mathbf{F} _{21}= (K^{-1})^\top \cdot \mathbf{E} _{21} \cdot K^{-1}$</p>
<div>$$\mathbf{F}_{21} : \text{ matrice fondamentale} \quad \Rightarrow \quad 7 \text{ DDL}\quad \left\{ \begin{aligned} & \text{- matrice homogène} \\ & \text{- rang}(\mathbf{F}_{21}) = 2 \quad \Rightarrow \quad \det(\mathbf{F}_{21}) = 0 \end{aligned} \right.$$</div>
<p><strong>性质：</strong></p>
<div>$$\left\{ \begin{aligned} &\text{齐次：基础矩阵 } \mathbf{F} \text{ 是齐次矩阵，可以乘以任意非零标量而不改变其性质} \\ &\text{秩约束：} \mathbf{F} \text{ 的秩为 } 2 \end{aligned} \right.$$</div>
<p>原式 $= \underline{\mathbf{P}} _2^\top \cdot \mathbf{F} _{21} \cdot \underline{\mathbf{P}} _1 = 0$</p>
<div>$$\text{设：} \quad \mathbf{L}_2 = \mathbf{F}_{21} \cdot \underline{\mathbf{P}}_1 = \begin{bmatrix} a \\ b \\ c \end{bmatrix}$$</div>
<div>$$\underline{\mathbf{P}}_2^\top \cdot \mathbf{L}_2 = 0 \quad \Leftrightarrow \quad a P_{2,x} + b P_{2,y} + c = 0$$</div>
<p>这就是相机 2 的图像平面中的直线方程 $\Rightarrow$ 对极线</p>
<h3 id="46-本质和基础矩阵的估计"><strong>4.6 本质和基础矩阵的估计</strong><a hidden class="anchor" aria-hidden="true" href="#46-本质和基础矩阵的估计">#</a></h3>
<ul>
<li>
<p>相机已经校准 $\Rightarrow$ 本质矩阵 $\mathbf{E}$ 的估计（5 个自由度）$\Rightarrow$ 5 点对应算法</p>
</li>
<li>
<p>相机未校准 $\Rightarrow$ 基础矩阵 $\mathbf{F}$ 的估计（7 个自由度）$\Rightarrow$ 7 点对应算法</p>
</li>
<li>
<p>求解 $\Rightarrow$ 8 点对应算法 $\Rightarrow$ 故意忽略约束条件 $\det(\mathbf{F}) = 0$</p>
</li>
</ul>
<h3 id="47-算法"><strong>4.7 算法</strong><a hidden class="anchor" aria-hidden="true" href="#47-算法">#</a></h3>
<p><strong>8 点对应算法步骤：</strong></p>
<ol>
<li>
<p><strong>收集匹配点对：</strong></p>
<p>$\mathbf{F}$ 有 7 个自由度，但在算法中忽略了秩为 2 的约束，因此需要至少 8 对匹配点来估计 $\mathbf{F}$。</p>
</li>
<li>
<p><strong>构建线性方程组</strong></p>
<p>对于每一对匹配点 $(\mathbf{m} _1, \mathbf{m} _2)$，构建方程：</p>
<div>$$\underline{\mathbf{m}}_2^\top \cdot \mathbf{E}_{21} \cdot \underline{\mathbf{m}}_1 = 0$$</div>
<div>$$\underline{\mathbf{P}}_2^\top \cdot \mathbf{F}_{21} \cdot \underline{\mathbf{P}}_1 = 0$$</div>
</li>
<li>
<p><strong>求解：</strong></p>
<p>将方程组表示为：$\underline{\mathbf{P}} _2^\top \cdot \mathbf{L} _2 = 0$</p>
</li>
<li>
<p><strong>$RANSAC$ 算法步骤</strong></p>
<p>处理匹配点对中的离群点（错误匹配），稳健地估计 $\mathbf{F}$</p>
<ul>
<li><strong>随机采样</strong>：利用 <strong>8 点对应算法</strong> 来估计 $\mathbf{F}$</li>
<li><strong>评估模型</strong>：利用估计得到的 $\mathbf{F}$ 来计算所有匹配点对的对极约束误差，即点到对应对极线的距离</li>
<li><strong>判断内点</strong>：根据设定的距离阈值，判断哪些匹配点是内点</li>
<li><strong>迭代</strong>：重复上述过程，直到找到内点数量最多的模型</li>
</ul>
</li>
</ol>
<h2 id="5-ajustement-de-faisceaux--束调整"><strong>5. Ajustement de faisceaux</strong>  (<strong>束调整</strong>)<a hidden class="anchor" aria-hidden="true" href="#5-ajustement-de-faisceaux--束调整">#</a></h2>
<ul>
<li>束调整是一种同时优化摄像机参数（包括位置、姿态和内参）和场景中三维点位置的技术</li>
<li>其核心思想是通过最小化三维点在图像上的重投影误差，使得优化后的模型与实际观测更加吻合</li>
<li>记住五个字：<strong>最小化投影误差</strong></li>
</ul>
<h3 id="51-两个摄像机的情况"><strong>5.1 两个摄像机的情况</strong><a hidden class="anchor" aria-hidden="true" href="#51-两个摄像机的情况">#</a></h3>
<h4 id="511-数据"><strong>5.1.1 数据</strong><a hidden class="anchor" aria-hidden="true" href="#511-数据">#</a></h4>
<p>$$\left( P _{A,i}, P _{B,i} \right) _{i=1,\dots,N} \implies N \text{ correspondences}$$</p>
<h4 id="512-要估计的参数"><strong>5.1.2 要估计的参数</strong><a hidden class="anchor" aria-hidden="true" href="#512-要估计的参数">#</a></h4>
<p>摄像机的姿态以及三维点云数据集</p>
<div>$$\mathbf{R} _{W1} \quad \mathbf{t} _{W1} \quad \mathbf{R} _{W2} \quad \mathbf{t} _{W2} \quad \left\{\mathbf{U}^w_i \right\}_{i=1,\dots,N}$$</div>
<h4 id="513-损失函数"><strong>5.1.3 损失函数</strong><a hidden class="anchor" aria-hidden="true" href="#513-损失函数">#</a></h4>
<div>$$\mathcal{L} \left( \mathbf{R}_{w1}, \mathbf{t}_{w1}, \mathbf{R}_{w2}, \mathbf{t}_{w2}, \left\{ \mathbf{U}^w_i \right\}_{i=1,\dots,N} \right)= \sum_{i=1}^{N} \left( \left\lVert P_{1,i} - K_1 \Pi \left( \mathbf{R}_{w1}^\top \mathbf{U}_i^{w} - \mathbf{R}_{w1}^\top \mathbf{t}_{w1} \right) \right\rVert_2^2 +\left\lVert P_{2,i} - K_2 \Pi \left( \mathbf{R}_{w2}^\top \mathbf{U}_i^{w} - \mathbf{R}_{w2}^\top \mathbf{t}_{w2} \right) \right\rVert_2^2 \right)$$</div>
<p>其中：</p>
<ul>
<li>$K _A$ 和 $K _B$ 是摄像机 $A$ 和 $B$ 的内参矩阵。</li>
<li>$\Pi(\cdot)$ 是投影函数，将三维点投影到二维平面上。</li>
<li>$\mathbf{R} _{w1}^\top$ 和 $\mathbf{R} _{w2}^\top$ 等价于 $\mathbf{R} _{1w}$ 和 $\mathbf{R} _{2w}$，即将点从世界坐标系转换到摄像机坐标系。</li>
<li>$\mathbf{R} _{w1}^\top \mathbf{t} _{w1}$ 等价于 $\mathbf{t} _{1w}$，表示平移向量。</li>
<li>$\mathbf{U} _i^{1}= \mathbf{R} _{w1}^\top \cdot \mathbf{U} _i^{w} - \mathbf{R} _{w1}^\top \cdot \mathbf{t} _{w1}$，也就是将 $\mathbf{U} _i^{w}$ 变换到 $\mathbf{U} _i^{1}$，即从世界坐标系变换到相机坐标系。</li>
<li><strong>做差</strong>：相机 $A$ 或 $B$ 中的图像坐标（实际）减去三维空间旋转变换得来的估计图像坐标，等于重投影误差。</li>
</ul>
<h3 id="52-多个摄像机的情况"><strong>5.2 多个摄像机的情况</strong><a hidden class="anchor" aria-hidden="true" href="#52-多个摄像机的情况">#</a></h3>
<h4 id="521-数据"><strong>5.2.1 数据</strong><a hidden class="anchor" aria-hidden="true" href="#521-数据">#</a></h4>
<p>每张图像中检测到的点为：</p>
<div>$$\left\{ \left\{ P _{m,i} \right\} _{i=1,\dots,N _m} \right\} _{m=1,\dots,M}$$</div>
<ul>
<li>
<p>这些点在不同视角下的图像中可以形成轨迹（tracks）</p>
</li>
<li>
<p>第 $m$ 个摄像机检测到的点，其中 $N _m$ 是第 $m$ 个摄像机检测到的点的数量</p>
<div>$$\left\{ \text{p2d-id} _m, \ \text{p3d-id} _m \right\} _{m=1,\dots,M}$$</div>
</li>
</ul>
<p>其中：</p>
<ul>
<li>$\text{p2d-id} _m$ 是二维点在图像中的索引</li>
<li>$\text{p3d-id} _m$ 是对应的三维点在点云中的索引</li>
<li>它们的大小尺寸都是 $C _m \times 1$</li>
</ul>
<h4 id="522-要估计的参数"><strong>5.2.2 要估计的参数</strong><a hidden class="anchor" aria-hidden="true" href="#522-要估计的参数">#</a></h4>
<ul>
<li>
<p><strong>相机外参</strong>：</p>
<div>$$ \left\{ \left( \mathbf{R} _{wm}, \mathbf{t} _{wm} \right) \right\} _{m=1,\dots,M} $$</div>
</li>
<li>
<p><strong>三维点的位置</strong>：</p>
<div>$$ \left\{ \mathbf{U} _i^{w} \right\} _{i=1,\dots,N} $$</div>
</li>
</ul>
<h4 id="523-损失函数"><strong>5.2.3 损失函数</strong><a hidden class="anchor" aria-hidden="true" href="#523-损失函数">#</a></h4>
<p>代价函数扩展为对所有摄像机和所有检测到的点进行误差计算，将投影点与实际观测点之间的距离最小化：</p>
<div>$$\mathcal{L}(x) = \sum_{m=1}^{M} \sum_{c=1}^{C_m} \left\| P_{m,\ \text{p2d-id}_m(c)} - K_m \Pi \left( \mathbf{R}_{wm}^\top \mathbf{U}_{\text{p3d-id}_m(c)}^{w} - \mathbf{R}_{wm}^\top \mathbf{t}_{wm} \right) \right\|_2^2$$</div>
<ul>
<li>$C _m$ 是第 $m$ 台摄像机的观测数量</li>
<li>$\mathbf{U} _{\text{p3d-id} _m(c)}^{w}$ 是与观测对应的三维点</li>
</ul>
<p>我们可以简单地将上述代价函数简化成：</p>
<div>$$\mathcal{L}(x) = \sum_{i=1}^{N} \left\| f_i(x) \right\|_2^2 \quad \left\{ \begin{array}{l} x \in \mathbb{R}^D \\ f_i : \mathbb{R}^D \rightarrow \mathbb{R}^B \end{array} \right.$$</div>
<ul>
<li>$x$ 是所有待优化的参数（摄像机参数和三维点坐标）</li>
<li>$f _i(x)$ 是第 $i$ 个残差函数，表示第 $i$ 个观测的重投影误差</li>
<li>我们的目标是找到 $x$，使得 $\mathcal{L}(x)$ 最小化。这是一个非线性最小二乘问题，通常使用迭代的方法求解</li>
</ul>
<h3 id="53--高斯牛顿算法"><strong>5.3  高斯牛顿算法</strong><a hidden class="anchor" aria-hidden="true" href="#53--高斯牛顿算法">#</a></h3>
<ul>
<li>用于非线性最小二乘问题的一种迭代优化算法      $\Rightarrow \text{ iteratif } \quad \delta_{k+1} = \delta_k + d_k$</li>
</ul>
<ol>
<li>
<p>$\text{Linearisation de } f_i: \quad f_i(x_k + d_k) \approx f_i(x_k) + \mathbf{J}_i(x_k)\cdot d_k$</p>
<ul>
<li>
<p>$\delta x$是参数的增量，需要求解</p>
</li>
<li>
<p>对于每次迭代，我们在当前估计$x_k$附近对$f_i(x)$进行泰勒展开，并忽略高阶项</p>
</li>
<li>
<p>$ f_i(\delta_k + d_k) \in \mathbb{R}^B $</p>
</li>
<li>
<p>$ f_i(\delta_k) \in \mathbb{R}^B$           $\mathbf{J}_i(\delta_k) \in \mathbb{R}^{B \times D} $            $ d_k \in \mathbb{R}^D $</p>
</li>
</ul>
</li>
<li>
<p>其中雅可比矩阵为:</p>
<div>$$\mathbf{J}_i(x_k) = \frac{\partial f_i(x_k + d_k)}{\partial d_k} \bigg|_{d_k=0}$$</div>
<ul>
<li>代表了在点 $x_k$ 处函数 $f_i$ 对于 $d_k$ 的偏导数，并且此偏导数是在 $d_k = 0$ 的条件下计算的</li>
<li>描述了在点$ x_k $处函数$ f_i $的线性变化率</li>
</ul>
</li>
<li>
<p>线性最小二乘法
$$
L_k(d_k) = \sum_{i=1}^{N} \left| f_i(x_k) + \mathbf{J}_i(x_k) \cdot d_k \right|_2^2
$$</p>
<p>​							$$\quad \mathbf{J}_k =
\begin{bmatrix}
\quad J_1(x_k) \\
\quad J_2(x_k) \\
\quad J_3(x_k) \\
​    \vdots \\
\quad J_N(x_k)
\end{bmatrix} \quad              \mathbf{b}_k =
\begin{bmatrix}
\quad  f_1(x_k) \\
\quad  f_2(x_k) \\
\quad  \vdots \\
\quad  f_N(x_k)
\end{bmatrix}$$</p>
<ul>
<li>$ \mathbf{b}_k$是所有残差的组合</li>
</ul>
<p>线性最小二乘问题变为：
$$
L_k(d_k) = \lVert b_k + J_k \cdot d_k \rVert_2^2
$$
通过最小化$L_k(\delta x)$，我们可以得到线性方程组：$J_k^T \cdot J_k \cdot d k = -J_k^T \cdot b_k \quad  $</p>
<ul>
<li>
<p>$其中b_k ∝ \text{ gradient}$</p>
</li>
<li>
<p>左边的矩阵$\mathbf{J}_k^T \mathbf{J}_k$是海森矩阵的近似              右边的向量$-\mathbf{J}_k^T \mathbf{b}_k$是梯度的负值</p>
</li>
<li>
<p>求解这个线性系统，得到参数更新$d_x$</p>
</li>
</ul>
</li>
<li>
<p><strong>Levenberg-Marquardt算法</strong></p>
<p>在高斯-牛顿算法的基础上引入阻尼因子$\lambda$，使得优化过程在接近解时具有高斯-牛顿的快速收敛特性，而在远离解时具有梯度下降的稳定性</p>
<ul>
<li>
<p>常用于非线性最小二乘问题的迭代优化算法</p>
</li>
<li>
<p>目标函数:  $L_k(d_k) = \lVert b_k + J_k d_k \rVert_2^2 + \lambda \lVert d_k \rVert_2^2$       $\quad \quad \Rightarrow (J_k^T J_k + \lambda I_k)d_k = -J_k^T b_k$</p>
</li>
<li>
<p>$\lambda$是阻尼因子</p>
<div>$$\begin{cases} 
    \text{Si } \lambda = 0 & \Rightarrow \text{Gauss-Newton} \\
    \text{Si } \lambda \rightarrow +\infty & \Rightarrow \lambda d_k \rightarrow -J_k^T b_k \quad \text{descente de gradient}
\end{cases}$$</div>
<ul>
<li>
<p><strong>如果新的代价函数值降低了</strong>（说明更新有效），则减小$\lambda$，使算法更接近高斯-牛顿法，加快收敛</p>
</li>
<li>
<p><strong>如果代价函数值没有降低</strong>， 则增大$\lambda$，使算法更接近梯度下降法，保证稳定性</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="54-算法步骤总结"><strong>5.4 算法步骤总结</strong><a hidden class="anchor" aria-hidden="true" href="#54-算法步骤总结">#</a></h3>
<p>在实际应用中，Levenberg-Marquardt算法的步骤如下：</p>
<ol>
<li>
<p><strong>初始化</strong>：</p>
<ul>
<li>设定初始参数$x$和阻尼因子$\lambda$</li>
<li>计算初始代价函数$L_{\min}$</li>
</ul>
</li>
<li>
<p><strong>迭代</strong>：</p>
<ul>
<li>
<p><strong>计算雅可比矩阵</strong>$\mathbf{J}$和残差$\mathbf{b}$</p>
</li>
<li>
<p><strong>求解线性系统</strong>：</p>
<p>$ (J^T J + \lambda I_d) d = -J^T b$</p>
</li>
<li>
<p><strong>更新参数</strong>：</p>
<p>$x′=x+d$</p>
</li>
<li>
<p><strong>计算新的代价函数</strong>$L'$</p>
</li>
</ul>
</li>
<li>
<p><strong>判断更新效果</strong>：</p>
<ul>
<li><strong>如果$L&rsquo; &lt; L_{\min}$</strong>（代价函数降低）：
<ul>
<li>接受更新：$x = x&rsquo;$，$L_{\min} = L'$</li>
<li>减小$\lambda$：$\lambda = \lambda / 2$</li>
<li>继续迭代</li>
</ul>
</li>
<li><strong>否则</strong>（代价函数未降低）：
<ul>
<li>拒绝更新，不改变$x$</li>
<li>增大$\lambda$：$\lambda = 2\lambda$</li>
<li>检查$\lambda$是否超过最大值，若超过则停止迭代</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>终止条件</strong>：</p>
<ul>
<li>当$\lambda$超过预设的最大值，或者参数更新的幅度小于阈值时，停止迭代</li>
</ul>
</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://zehua.eu/zh/posts/signal_cn/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/">
    <span class="title">« 上一页</span>
    <br>
    <span>图像处理</span>
  </a>
  <a class="next" href="http://zehua.eu/zh/posts/probability_cn/%E5%90%84%E7%B1%BB%E6%8E%A7%E5%88%B6%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/">
    <span class="title">下一页 »</span>
    <br>
    <span>各类控制方法实现思路及代码</span>
  </a>
</nav>

  </footer>
</article>

<div class="post-password"></div>
  
</div>
    </main>
    
<footer class="footer">
        <span><a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod</a></span> · 


    <span>
        
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a>  
        
    </span>
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <br>
    <span id="busuanzi_container_page_pv" style='display:none'>
        一共有<span id="busuanzi_value_page_pv"></span>人来过这里
    </span>
    · <span id="last_change">
        最后更新于2024年11月28日
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
