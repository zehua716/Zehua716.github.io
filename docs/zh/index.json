[{"content":"图像反卷积：Wiener-Hunt 方法\n主要针对图像去模糊问题，即从模糊(带噪)图像中恢复清晰图像。这属于逆问题的范畴，一半出现在处理真实测量系统时。由于每个测量系统（如温度计、CCD相机、光谱仪等）都受到基础物理学的限制，比如有限精度、有限动态范围、非零响应时间等。这意味着测得的量或多或少都有扭曲。因此这部分是对感兴趣物理量的某种扭曲程度的度量。\n大多数情况下，测量系统直接给出的测量数据通常具有足够的精度和鲁棒性。但是，也存在测量结果不准确的情况。为了解决精度问题，或者说至少部分地优化它，已经开发了特殊的信号和图像处理技术。在接下来的内容中，我们将通过一个简单的例子来展示此类方法。\n我们有一张未聚焦的图像。这种情况下，点的图像实际上会是一个斑点。捕获的图像将会因为模糊而受损，因为它是由真实图像中每个点生成的斑点的叠加结果。\n描述这种转换的最简单模型是线性不变滤波器，即卷积。示意图如下图所示。\n在上面的示意图中， $x_{n,m}$ 代表真实或原始图像，$y_{n,m}$ 代表观测到的图像，或者更确切地说，是我们通过相机拍到的未聚焦图像。添加分量 $b_{n,m}$ 是为了考虑测量和建模误差。\n描述测量过程的方程(二维)如下：\n$$ y_{n,m} = \\sum_{p=-P}^{P} \\sum_{q=-Q}^{Q} h_{p,q} x_{n-p,m-q} + b_{n,m} $$\n$y_{n,m}$ 是对于每个观测到的像素 $(n, m)$ 。在这个公式中，$P$ 和 $Q$ 是给定的整数。\n注意，滤波器通常来说都是低通滤波器，这就意味着它们无法准确地在输出中再现输入信号或图像中的所有分量，因为高频分量要么被强烈衰减，要么完全被拒绝，这也就是为什么 ‘‘恢复真实信号’‘或者说’‘图像的逆问题’’ 是如此困难：必须恢复那些要么完全不存在、要么“错误”观测到的高频分量。\n在下面的例子中，我们用线性方法来解决图像反卷积问题。这些线性方法依赖于最小二乘准则，并结合了二次惩罚。我们先介绍其理论部分，包括这些准则及其最小化器。此外，展示背后的技术细节，并提出了一种基于循环近似的方法，以实现快速的数值计算。\n1. 一维反卷积\n为了简化理论概念，我们先讨论在一维情况下的信号反卷积。这种简化情况允许对反卷积问题的分析更加深入，同时更容易掌握概念和思路。随后再引入二维情况，并将其视为一维情况的扩展。Matlab 实现部分仅涉及二维情况。\n1.1 一维建模\n在一维情况下，(1) 中给出的观测模型变为：\n$$ y_n = \\sum_{p=-P}^{P} h_p x_{n-p} + b_n $$\n如果我们有 $N$ 个样本，可以将相应的 $N$ 个方程写成矩阵形式：\n$$ \\mathbf{y} = \\mathbf{H} \\mathbf{x} + \\mathbf{b} $$\n​\t•\t向量 $\\mathbf{y}$ 包含了所有的 $N$ 个观测值（在二维情况下，它将包含模糊的图像）\n​\t•\t向量 $\\mathbf{x}$ 包含了恢复图像的样本，而 $\\mathbf{b}$ 是噪声样本。\n​\t•\t矩阵 $\\mathbf{H}$ ，称为模糊矩阵，具有以下经典结构：\n$$ H = \\begin{bmatrix} h_P \u0026amp; \\cdots \u0026amp; h_0 \u0026amp; \\cdots \u0026amp; h_{-P} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \\\\ 0 \u0026amp; h_P \u0026amp; \\cdots \u0026amp; h_0 \u0026amp; \\cdots \u0026amp; h_{-P} \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \\\\ 0 \u0026amp; 0 \u0026amp; h_P \u0026amp; \\cdots \u0026amp; h_0 \u0026amp; \\cdots \u0026amp; h_{-P} \u0026amp; 0 \u0026amp; \\cdots \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; h_P \u0026amp; \\cdots \u0026amp; h_0 \u0026amp; \\cdots \u0026amp; h_{-P} \u0026amp; \\cdots \\\\ \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \\end{bmatrix} $$\n​\t•\t$\\mathbf{H}$ 是一个 $N \\times N$ 的方阵，并且具有 Toeplitz 结构。\n因此，信号反卷积问题可以重新表述为: 在已知观测信号 $\\mathbf{y}$ 并知道卷积矩阵 $H$ 的情况下，估计向量 $\\mathbf{x}$\n1.2 带惩罚的最小二乘法\n提出的重建策略 (损失函数) 是一种带惩罚的最小二乘法。它包含两个部分：\n​\t•\t一个重构损失项，用于量化恢复信号 $\\mathbf{x}$ 与观测信号 $\\mathbf{y}$ 进行重新卷积后的相似性，从而确保恢复的信号与观测信号一致。\n​\t•\t一个惩罚项，用于限制恢复信号的连续样本之间的差异，确保其具有一定的规则性结构。\n该准则采用以下表达式：\n$$ J_{\\text{PLS}}(x) = | y - Hx |^2 + \\mu | Dx |^2 = (y - Hx)^t (y - Hx) + \\mu x^t D^t D x $$\n其中，$D$ 是阶数为 1，大小为 $(N - 1) \\times N$ 的差分矩阵，定义如下：\n$$ D = \\begin{bmatrix} \\cdots \u0026amp; -1 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \\\\ \\cdots \u0026amp; 0 \u0026amp; -1 \u0026amp; 1 \u0026amp; 0 \u0026amp; \\cdots \\\\ \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \\\\ \\cdots \u0026amp; 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 1 \u0026amp; \\cdots\\\\ \\end{bmatrix} $$\n带惩罚的最小二乘准则的最小化器为：\n$$ \\hat{x} = (H^t H + \\mu D^t D)^{-1} H^t y $$\n证明:\n$$ \\hat{x} = (H^T H + \\mu D^T D)^{-1} H^T y $$\n我们已知损失准则为:\n$$ J_{\\text{PLS}}(x) = y^T y - 2x^T H^T y + x^T H^T H x + \\mu x^T D^T D x $$\n求偏导为0:\n$$ \\hat{x} = (H^T H + \\mu D^T D)^{-1} H^T y $$\n特殊情况：\n在特定情况下 $\\mu = 0$ 时准则和最小化器的结果表达式变为 $J_{\\text{PLS}}(x) = |y - Hx|^2$\n最小化器方程为：\n$$ \\hat{x} = (H^T H)^{-1} H^T y $$\n此时准则变为经典的最小二乘问题，没有正则化项，也就是说，模型仅考虑最小化观测值与预测值之间的误差，而不会惩罚解的复杂度或平滑性。其解是经典的 最小二乘解。\n1.2.1 循环近似\n回到公式 (9) ，我们已知矩阵 $H^T H + \\mu D^T D$ 的大小为 $N \\times N$ ，当 $N$ 很大时，这种反演在计算上非常昂贵甚至不可行。\n比如说在处理图像时，比如对于 $1000 \\times 1000$ 的图像，矩阵的大小为 $10^6 \\times 10^6$ ，计算不了。在三维情况下，更复杂。\n因此为了计算 $\\hat{x}$ ，有几种方法可以克服这种大计算量的困难。\n下面我们考虑使用循环矩阵的特性，因为我们可以用对角矩阵来 “替换” 公式 (9) 中的矩阵 (通过快速傅里叶变换 FFT 可以将循环矩阵 “转化”为对角矩阵)。因此，使用对角矩阵进行计算时，乘法或反演等矩阵运算的复杂度将大大降低。\n但是，这需要先将矩阵 $H$ 和 $D$ 近似为循环矩阵 $\\tilde{H}$ 和 $\\tilde{D}$ 。\n循环近似涉及修改矩阵的右上角和/或左下角部分，使其具有循环结构。这种近似的核心假设是信号或图像在开始和结束部分是周期性的，即信号的末尾与开头相连接，形成一个环状结构。\n循环卷积矩阵 $\\tilde{H}$ 和 $\\tilde{D}$ 在傅里叶基下可以轻松对角化：\n$$ \\tilde{H} = F^T \\Lambda_h F \\quad \\text{和} \\quad \\tilde{D} = F^T \\Lambda_d F $$\n矩阵 $\\Lambda_h$ 是对角矩阵，其对角线上元素是 $H$ 的特征值。\n特征值可以通过对矩阵 $H$ 第一行进行快速傅里叶变换（FFT）获得，即计算脉冲响应的 $N$ 点 FFT，这些响应代表频率响应的样本。\n同样适用于矩阵 $\\tilde{D}$ 及其特征值，其中将脉冲响应替换为 $[-1, 1]$。\n通过在 (9) 中用 (18) 代替，并使用简单的矩阵操作，可以得到：\n$$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h} + \\mu \\Lambda_{d}^{\\dagger} \\Lambda_{d})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n在此基础上再进一步:\n$$ \\overset{\\circ}{\\hat{x}} = \\left[ \\Lambda_h^{\\dagger} \\Lambda_h + \\mu \\left( \\Lambda_{d_c}^{\\dagger} \\Lambda_{d_c} + \\Lambda_{d_r}^{\\dagger} \\Lambda_{d_r} \\right) \\right] \\Lambda_h^{\\dagger} \\dot{\\mathbf{y}} $$\n1 FT_x = 1 ./ (abs(Lambda_H).^2 + mu * (abs(Lambda_dC).^2 + abs(Lambda_dR).^2)).* (conj(Lambda_H).* FT_Data); $\\Lambda_h \\Rightarrow$ FT_IR = MyFFT2RI(IR, 256);\n$\\Lambda_{d_c} \\Rightarrow$ FT_Dc = MyFFT2RI(Dc, 256);\n$\\Lambda_{d_r} \\Rightarrow$ FT_Dr = MyFFT2RI(Dr, 256);\n回顾性质:\n$$ \\Lambda_H^{+} = (\\Lambda_H^T)^{} = \\Lambda_H^{} = \\operatorname{conj}(\\Lambda_H) $$\n因此有:\n$$ \\Lambda_H^{+} \\cdot \\Lambda_H = \\Lambda_H^{*} \\cdot \\Lambda_H = |\\Lambda_H|^2 $$\n证明：\n$$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h} + \\mu \\Lambda_{d}^{\\dagger} \\Lambda_{d})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n补充知识: $\\tilde{H}$ 是一个实矩阵，因此其复共轭等于它本身，$\\tilde{H} = \\tilde{H}^T$ 。$\\tilde{D}$ 同理\n在近似为循环矩阵后，公式 (15) 变为:\n$$ \\hat{x} = (\\tilde{H}^{T}\\tilde{H} + \\mu \\tilde{D}^{T}\\tilde{D})^{-1}\\tilde{H}^{T}y $$\n其中: $\\tilde{H} = F^T \\Lambda_h F$ 且 $\\tilde{D} = F^T \\Lambda_d F$ 将其带入上述公式，得:\n$$ \\hat{x} = ((F^{T}\\Lambda_{h}F)^{T}(F^{T}\\Lambda_{h}F) + \\mu (F^{T}\\Lambda_{d}F)^{T}(F^{T}\\Lambda_{d}F))^{-1}(F^{T}\\Lambda_{h}F)^{T}y $$\n因为傅里叶矩阵 $F$ 是一个正交矩阵，具有 $F F^{T} = I$ 的性质，即 $F^{T} = F^{-1}$\n并且我们有 $(F^{T}\\Lambda_{h}F)^{T} = F^{T}\\Lambda_{h}^{T}F$ 以及 $(F^{T}\\Lambda_{d}F)^{T} = F^{T}\\Lambda_{d}^{T}F$\n所以:\n令 $\\quad \\overset{\\circ}{\\hat{x}} = F \\hat{x}, \\quad \\overset{\\circ}{y} = F y$\n那么:\n$$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h} + \\mu \\Lambda_{d}^{\\dagger} \\Lambda_{d})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n证毕。\n特殊情况：\n当 $\\mu = 0$ 时，正则化项消失，公式简化为：\n$$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n这意味着我们仅仅执行了经典的 Wiener 去卷积，没有考虑图像的正则化。\n$$\\hat{x} = (\\tilde{H}^{T}\\tilde{H} )^{-1}\\tilde{H}^{T}y\\ $$\n没有正则化时，虽然理论上可以恢复原始信号，但是实际上收到的噪声影响很大，且没有约束来将其消除\n为了完成我们的讨论，我们首先构建向量 $g_{\\text{PLS}}$ ，其分量定义如下：\n$$ g_{PLS}^{n} = \\frac{\\overset{\\circ}{h}_{n}^{*}}{|\\overset{\\circ}h_n|^2 + \\mu |\\overset{\\circ}d_n|^2}\\quad \\text{for } n = 1, 2, \\dots, N $$\n因此，向量 $\\overset{\\circ}{\\hat{x}}$ 是通过向量 $g_{\\text{PLS}}$ 和 $\\overset{\\circ}{\\hat{y}}$ 之间逐元素相乘得到的：\n$$ \\overset{\\circ}{\\hat{x}} = g_{\\text{PLS}} .* \\overset{\\circ}{\\hat{y}} $$\n反卷积问题可以表述为在傅里叶域中进行的滤波操作，其中 $g_{\\text{PLS}}$ 代表离散传递函数。\n反卷积问题总结如下：\n​\t•\t① 构建 $\\mathring{h}$ 作为脉冲响应的 $N$ 点 FFT\n​\t•\t② 构建 $\\mathring{d}$ 作为 $[1; -1]$ 的 $N$ 点 FFT\n​\t•\t③ 构建包含传递函数 $g_{\\text{PLS}}$ 的向量\n​\t•\t④ 构建观测值的 FFT $\\mathring{y}$\n​\t•\t⑤ 计算 $\\mathring{\\hat{x}}$ ，作为传递函数 $g_{\\text{PLS}}$ 和 $\\mathring{\\hat{y}}$ 的乘积\n​\t•\t⑥ 计算 $\\mathring{\\hat{x}}$ 的 IFFT 以在空间域中获得解 $\\hat{x}$\n2 实现\n2.1 二维方法\n对于二维情况，其方程类似于一维情况。但是，所涉及的block-Tœplitz矩阵结构更加复杂: 每个块本身也具有 Tœplitz 结构。这使得在两个方向上进行循环近似变得更加困难。因此，二维情况仅作为一维情况的扩展来展示，重点是 Matlab 实现，理论部分暂不讨论。\n注意以下几点：\n​\t•\t图像、脉冲响应、正则化项都是二维的，这意味着必须使用 FFT-2D 而不是 FFT。\n​\t•\t更确切地说，如果要恢复的图像有 $N$ 行和 $N$ 列，那么 FFT-2D 必须在 $N$ 行和 $N$ 列上计算。\n​\t•\t频率传递函数也是二维的，每个空间频率有一个维度。\n特别说明 — 在任何情况下，矩阵 $H$ 和 $D$ 都不应在 Matlab 代码中构建。\n2.2 观测图像\n​\t•\t第一步是加载数据 Data1 和 Data2 。使用 load 函数来完成。每个数据文件内部包含：模糊图像 (Data)、用于比较的真实图像 (TrueIma)，以及卷积滤波器的脉冲响应 (IR)。现在分析每个数据集及其相互关系。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 clear all close all clc %% Load Data Data1 = load(\u0026#39;DataOne.mat\u0026#39;) Data2 = load(\u0026#39;DataTwo.mat\u0026#39;) % Create a window to display the image figure() subplot(1,2,1) % Display the image, grayscale imagesc(Data1.Data); colormap(\u0026#39;gray\u0026#39;); % Scale the axes and eliminate the grading axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) title(\u0026#39;Observed Image - Data1\u0026#39;); subplot(1,2,2) % Display the image, grayscale imagesc(Data2.Data); colormap(\u0026#39;gray\u0026#39;); % Scale the axes and eliminate the grading axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) title(\u0026#39;Observed Image - Data2\u0026#39;); 两观测图像都有明显的模糊，具体是边缘和结构细节处。这种模糊表明图像中的高频信息被卷积或散射了，导致图像细节的丢失，这就是由于卷积效应或低通滤波的影响而造成的。\n​\t•\t为了进一步分析，肯定要到频域看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 %% Analyse the images in the frequency domain (linear and a logarithmic scale) % % Get the sizes of the images % [M1,N1] = size(Data1.Data); % [M2,N2] = size(Data2.Data); % % Generate frequency axes for Data1 % u1 = (-M1/2:M1/2-1)/M1; % Normalized frequencies in y-direction % v1 = (-N1/2:N1/2-1)/N1; % Normalized frequencies in x-direction % % Generate frequency axes for Data2 % u2 = (-M2/2:M2/2-1)/M2; % v2 = (-N2/2:N2/2-1)/N2; % Generate normalized frequency axes using linspace Nu = linspace(-0.5, 0.5, 256); % Compute the 2D FFT of observed images and shift zero frequency to center FFT_Data1 = MyFFT2(Data1.Data); FFT_Data2 = MyFFT2(Data2.Data); % Magnitude spectra Mag_Data1 = abs(FFT_Data1) Mag_Data2 = abs(FFT_Data2) % Display magnitude spectra in linear scales figure(); subplot(1,2,1) imagesc(Nu,Nu,Mag_Data1); % Use frequency axes v1 and u1 xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); colormap(\u0026#39;gray\u0026#39;); title(\u0026#39;Magnitude (Linear Scale) - Data1\u0026#39;); subplot(1,2,2) imagesc(Nu,Nu,Mag_Data2); % Use frequency axes v2 and u2 xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); colormap(\u0026#39;gray\u0026#39;); title(\u0026#39;Magnitude (Linear Scale) - Data2\u0026#39;); % Display magnitude spectra in logarithmic scales figure; subplot(1,2,1) imagesc(Nu,Nu,log(1+Mag_Data1)); % Use log scale xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); colormap(\u0026#39;gray\u0026#39;); title(\u0026#39;Magnitude (logarithmic Scale) - Data1\u0026#39;); subplot(1,2,2) imagesc(Nu,Nu,log(1+Mag_Data2)); xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); colormap(\u0026#39;gray\u0026#39;); title(\u0026#39;Magnitude (logarithmic Scale) - Data2\u0026#39;); 可见只有两组频谱图的中心部分有强烈亮度，即低频分量较强，即图像大范围平滑信息较多，而高频部分的细节没有\n​\t•\t我们继续看两个脉冲响应 $h_{n,m}$ 及其关联的传递函数 $H(\\nu_x, \\nu_y)$ 。首先使用 imagesc 函数，然后使用 plot 函数来进行分析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 %% Calcul impulse responses and associated transfer functions using impulse % Load the impulse responses IR1 = Data1.IR; IR2 = Data2.IR; % Display the impulse responses figure; subplot(1,2,1) imagesc(IR1); colormap(\u0026#39;gray\u0026#39;); title(\u0026#39;Impulse Response - IR1\u0026#39;); subplot(1,2,2) imagesc(IR2); colormap(\u0026#39;gray\u0026#39;); title(\u0026#39;Impulse Response - IR2\u0026#39;); % Compute and display the transfer functions Long = 256; H1 = MyFFT2RI(IR1, Long); H2 = MyFFT2RI(IR2, Long); % Compute the magnitude spectra Mag_H1 = abs(H1); Mag_H2 = abs(H2); % Display the transfer functions using imagesc figure; subplot(1,2,1) imagesc(Nu, Nu, Mag_H1); xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); title(\u0026#39;Transfer Function Magnitude - H1\u0026#39;); colormap(\u0026#39;gray\u0026#39;); subplot(1,2,2) imagesc(Nu, Nu, Mag_H2); xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); title(\u0026#39;Transfer Function Magnitude - H2\u0026#39;); colormap(\u0026#39;gray\u0026#39;); 很明显，IR1 和 IR2 都是低通滤波器，只允许低频分量通过，高频分量进行衰减或完全抑制。IR1 的传递函数 H1 的分布更加平滑，说明它对低频分量的保留更为均匀。IR2 的滤波特性更倾向于选择性地保留某些低频分量，而非均匀地平滑整个低频区域。因此，相较于 IR1，IR2 对图像的细节影响更强。不过这么看看不出来具体的道道儿，还是得看下面的切片。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 %% Plot slices through the transfer functions using plot % Midpoint index (since Long = 256) mid_index = Long / 2 + 1; % This will be 129 % Plot slices for H1 figure; subplot(2,1,1) plot(Nu, Mag_H1(mid_index, :)); xlabel(\u0026#39;Normalized Frequency X\u0026#39;); ylabel(\u0026#39;Magnitude\u0026#39;); title(\u0026#39;Transfer Function along Central Row - H1\u0026#39;); grid on; subplot(2,1,2) plot(Nu, Mag_H1(:, mid_index)); xlabel(\u0026#39;Normalized Frequency Y\u0026#39;); ylabel(\u0026#39;Magnitude\u0026#39;); title(\u0026#39;Transfer Function along Central Column - H1\u0026#39;); grid on; 可见前面的结论是正确的，H1 幅值响应曲线变化相对平滑，适合图像整体的模糊处理任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 % Plot slices for H2 figure; subplot(2,1,1) plot(Nu, Mag_H2(mid_index, :)); xlabel(\u0026#39;Normalized Frequency X\u0026#39;); ylabel(\u0026#39;Magnitude\u0026#39;); title(\u0026#39;Transfer Function along Central Row - H2\u0026#39;); grid on; subplot(2,1,2) plot(Nu, Mag_H2(:, mid_index)); xlabel(\u0026#39;Normalized Frequency Y\u0026#39;); ylabel(\u0026#39;Magnitude\u0026#39;); title(\u0026#39;Transfer Function along Central Column - H2\u0026#39;); grid on; 在 H2 的切片图中，幅值响应曲线有更明显的周期性波动，适合特定方向的模糊或增强效果。\n2.3 Implementation\n我们将在二维情况下实现反卷积，并使用带有二次惩罚项的最小二乘法，同时使用循环近似进行最小化，在前面已经进行过了总结。\n关于正则化项，它依赖于图像列和行上相邻像素之间的差异。其表达式为：\n$$ | D x |^2 = \\sum_{n,m} (x_{n,m} - x_{n,m+1})^2 + (x_{n,m} - x_{n+1,m})^2 $$\n​\t•\t正则化项 $| D x |^2$ 代表了水平方向和垂直方向相邻像素值的平方差之和。\n因此它将基于两个滤波器(水平和垂直)来实现：\n$$ D_{horiz} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \u0026amp; 1 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix} \\quad D_{vert} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} $$\n这两个滤波器分别计算行和列上像素之间的差异。\n当然也可以从以下脉冲响应滤波器中选一个，它们都可以实现图像梯度的近似。\n$$ \\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0 \\\\ -1 \u0026amp; 4 \u0026amp; -1 \\\\ 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\quad \\text{或} \\quad \\begin{bmatrix} -1 \u0026amp; -1 \u0026amp; -1 \\\\ -1 \u0026amp; 8 \u0026amp; -1 \\\\ -1 \u0026amp; -1 \u0026amp; -1 \\end{bmatrix} \\quad \\text{或} \\quad \\begin{bmatrix} 1 \u0026amp; -2 \u0026amp; 1 \\\\ -2 \u0026amp; 4 \u0026amp; -2 \\\\ 1 \u0026amp; -2 \u0026amp; 1 \\end{bmatrix} $$\n回顾前面，我们得到：\n$$ \\hat{x} = (H^{T}H + \\mu D^{T}D)^{-1}H^{T}y $$\n现在进行傅里叶变换下的去卷积\n$$ \\hat{x}(\\nu_{x}, \\nu_{y}) = \\frac{\\hat{H}^{*}(\\nu_{x}, \\nu_{y}) \\hat{y}(\\nu_{x}, \\nu_{y})}{|\\hat{H}(\\nu_{x}, \\nu_{y})|^2 + \\mu |\\hat{D}(\\nu_{x}, \\nu_{y})|^2} $$\n​\t•\t$\\hat{H}(\\nu_{x}, \\nu_{y})$ 是卷积矩阵的傅里叶变换\n​\t•\t$\\hat{D}(\\nu_{x}, \\nu_{y})$ 是差分矩阵的傅里叶变换\n​\t•\t$\\hat{x}(\\nu_{x}, \\nu_{y})$ 是频域中的恢复图像\n我们先写一个反卷积函数，将观测数据 (Data)、脉冲响应 (IR) 和正则化参数 (mu) 作为输入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 function [x] = deconvolve_image(Data,IR,mu) Long = length(Data); Nu = linspace(-0.5, 0.5, Long); TF_Data = MyFFT2(Data); TF_IR = MyFFT2RI(IR,Long); % figure(1) % subplot(2, 1, 1) % imagesc(Nu, Nu, abs(TF_IR)) % title(\u0026#39;Frequency response\u0026#39;) % xlabel(\u0026#39;\\nu_x\u0026#39;) % ylabel(\u0026#39;\\nu_y\u0026#39;) % axis square % subplot(2, 1, 2) % plot(Nu, abs(TF_IR(round(length(TF_IR)/2), :))) % Define the regularization filters (difference operators) % Horizontal difference filter Dh = [0 0 0; 0 -1 1; 0 0 0]; % Vertical difference filter Dv = [0 0 0; 0 -1 0; 0 1 0]; % Compute the FFTs of the regularization filters using MyFFT2RI TF_Dh = MyFFT2RI(Dh, Long); TF_Dv = MyFFT2RI(Dv, Long); % Compute |Dh|^2 and |Dv|^2 abs_Dh_squared = abs(TF_Dh).^2; abs_Dv_squared = abs(TF_Dv).^2; % Total regularization term |D|^2 = |Dh|^2 + |Dv|^2 abs_D_squared = abs_Dh_squared + abs_Dv_squared; % Compute the denominator of the Wiener filter denom = abs(TF_IR).^2 + mu * abs_D_squared; % Compute the numerator numerator = conj(TF_IR) .* TF_Data; % Compute X_hat in the frequency domain TF_X = numerator ./ denom; % Compute the inverse FFT to get the deconvolved image % Since MyFFT2 uses fftshift, we need to use ifftshift before ifft2 x = MyIFFT2(TF_X); end ​\t•\t然后应用这个逆卷积函数，查看反卷积后的图像去噪效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 %% Question 5 mu = 0.004; % Deconvolve Data1 x_1 = deconvolve_image(Data1.Data, Data1.IR, mu); % Display the deconvolved image figure; subplot(1,2,1) % Display the image, grayscale imagesc(Data1.Data); colormap(\u0026#39;gray\u0026#39;); % Scale the axes and eliminate the grading axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) title([\u0026#39;Observed Image - Data1, \\mu = \u0026#39;, num2str(mu)]); subplot(1,2,2) imagesc(x_1); colormap(\u0026#39;gray\u0026#39;); title([\u0026#39;Deconvolved Image - Data1, \\mu = \u0026#39;, num2str(mu)]); axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) % Deconvolve Data2 x_2 = deconvolve_image(Data2.Data, Data2.IR, mu); % Display the deconvolved image figure; subplot(1,2,1) % Display the image, grayscale imagesc(Data2.Data); colormap(\u0026#39;gray\u0026#39;); % Scale the axes and eliminate the grading axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) title([\u0026#39;Observed Image - Data2, \\mu = \u0026#39;, num2str(mu)]); subplot(1,2,2) imagesc(x_2); colormap(\u0026#39;gray\u0026#39;); title([\u0026#39;Observed Image - Data2, \\mu = \u0026#39;, num2str(mu)]); axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) 可见效果挺理想，但是之前这个 $\\mu$ 是随便设的，现在探讨这个 $\\mu$ 值对结果的影响。\n​\t•\t首先考虑简单的逆滤波器情况，即 $\\mu = 0$ 。\n前面我们得到： $\\hat{x} = (H^{T}H + \\mu D^{T}D)^{-1}H^{T}y$\n现在变成： $\\hat{x} = (H^{T}H)^{-1}H^{T}y$\n$$ \\hat{x}(\\nu_{x}, \\nu_{y}) = \\frac{\\hat{H}^{*}(\\nu_{x}, \\nu_{y}) \\hat{y}(\\nu_{x}, \\nu_{y})}{|\\hat{H}(\\nu_{x}, \\nu_{y})|^2 } $$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 %% Question 6 Simple Inverse Filter (μ = 0) mu = 0; % Deconvolve Data1 x_1 = deconvolve_image(Data1.Data, Data1.IR, mu); % Display the deconvolved image figure; subplot(1,2,1) % Display the image, grayscale imagesc(Data1.Data); colormap(\u0026#39;gray\u0026#39;); % Scale the axes and eliminate the grading axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) title([\u0026#39;Observed Image - Data1, \\mu = \u0026#39;, num2str(mu)]); subplot(1,2,2) imagesc(x_1); colormap(\u0026#39;gray\u0026#39;); title([\u0026#39;Deconvolved Image - Data1, \\mu = \u0026#39;, num2str(mu)]); axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) 由于 $\\mu = 0$ 等价于丢失了正则化项，反卷积结果会直接依赖于卷积核 $H$ 的傅里叶系数 $|\\hat{H}(\\nu_{x}, \\nu_{y})|^2$ ，如果 $H$ 的某些频率分量（尤其是高频）接近零，那么在这些频率上，分母 $|\\hat{H}(\\nu_{x}, \\nu_{y})|^2$ 会非常小，导致反卷积结果中放大这些频率分量的噪声。反卷积图像中可以看到明显的颗粒状噪声。这是由于直接逆滤波在某些频率分量上产生了极大值，放大了噪声。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 % Deconvolve Data2 x_2 = deconvolve_image(Data2.Data, Data2.IR, mu); % Display the deconvolved image figure; subplot(1,2,1) % Display the image, grayscale imagesc(Data2.Data); colormap(\u0026#39;gray\u0026#39;); % Scale the axes and eliminate the grading axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) title([\u0026#39;Observed Image - Data2, \\mu = \u0026#39;, num2str(mu)]); subplot(1,2,2) imagesc(x_2); colormap(\u0026#39;gray\u0026#39;); title([\u0026#39;Observed Image - Data2, \\mu = \u0026#39;, num2str(mu)]); axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) ​\t•\t我们因此取不同的 $\\mu$ 值(在 $\\log_{10}$ 刻度上取值)。并且根据结果，确定合适的 $\\mu$ 值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 %% Effect of Varying μ on Deconvolution Results % Define a range of mu values on a log scale mu_values = logspace(-11, 0, 12); % From 1e-10 to 1 % Deconvolution and display for Data1 figure(\u0026#39;Name\u0026#39;, \u0026#39;Deconvolution Results for Data1\u0026#39;); for i = 1:length(mu_values) mu = mu_values(i); x_1 = deconvolve_image(Data1.Data, Data1.IR, mu); subplot(3,4,i); imagesc(x_1); colormap(\u0026#39;gray\u0026#39;); axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;); title([\u0026#39;\\mu = \u0026#39;, num2str(mu, \u0026#39;%.1e\u0026#39;)]); end sgtitle(\u0026#39;Deconvolved Images - Data1 with Different \\mu Values\u0026#39;); % Deconvolution and display for Data2 figure(\u0026#39;Name\u0026#39;, \u0026#39;Deconvolution Results for Data2\u0026#39;); for i = 1:length(mu_values) mu = mu_values(i); x_2 = deconvolve_image(Data2.Data, Data2.IR, mu); subplot(3,4,i); imagesc(x_2); colormap(\u0026#39;gray\u0026#39;); axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;); title([\u0026#39;\\mu = \u0026#39;, num2str(mu, \u0026#39;%.1e\u0026#39;)]); end sgtitle(\u0026#39;Deconvolved Images - Data2 with Different \\mu Values\u0026#39;); 小的 $\\mu$ 值时，可见图像噪声多，甚至都有可能完全被噪声埋没; 中等 $\\mu$ 值 时，图像细节和噪声之间达到了较好的平衡; 当 $\\mu$ 值过大时，图像变得过于平滑，细节逐渐丢失，尤其是当 $\\mu = 1$ 时。我们目前只能通过视觉方法来选出较好的 $\\mu$ 值，两数据最优 $\\mu$ 值都大约等于 0.01，但是这样肯定是不行的，是不严谨的，是无法成为一名科研奇才的，因此我们和真实图像做数学比较。\n2.4 超参数的作用\n上一点使我们能够评估与反卷积问题相关的内在难度。它还表明，考虑重建图像期望正则性的先验信息可以获得更好的结果。这种方法因此使我们能够在两种信息源之间进行折衷：观测数据和可用的先验信息（关于正则性）。这是通过参数 $\\mu$ 的值来实现的。在下面的研究中，选择一个最合适的 $\\mu$ 值，以使反卷积图像既不过于平滑也不过于不规则。\n因此，可以计算反卷积图像 $\\hat{x}$ 和真实图像 $x^\\star$ 之间的数值差异，作为正则化参数 $\\mu$ 的函数。\n为此，考虑以下三种距离函数：\n$$\\Delta_2(\\mu) = \\frac{\\sum_{p,q} (\\hat{x}_{p,q}(\\mu) - x^{\\star}_{p,q})^2}{\\sum_{p,q} (x^{\\star}_{p,q})^2} = \\frac{\\|\\hat{x}(\\mu) - x^{\\star}\\|_2^2}{\\|x^{\\star}\\|_2^2}$$ $$\\Delta_1(\\mu) = \\frac{\\sum_{p,q} |\\hat{x}_{p,q}(\\mu) - x^{\\star}_{p,q}|}{\\sum_{p,q} |x^{\\star}_{p,q}|} = \\frac{\\|\\hat{x}(\\mu) - x^{\\star}\\|_1}{\\|x^{\\star}\\|_1}$$ $$\\Delta_\\infty(\\mu) = \\frac{\\max_{p,q} |\\hat{x}_{p,q}(\\mu) - x^{\\star}_{p,q}|}{\\max_{p,q} |x^{\\star}_{p,q}|} = \\frac{\\|\\hat{x}(\\mu) - x^{\\star}\\|_\\infty}{\\|x^{\\star}\\|_\\infty}$$ 当恢复的图像类似于真实图像时，这些距离接近于 0，当恢复的图像为零时，它们接近 1。\n​\t•\t我们设定 $\\mu$ 值在 $10^{-10}$ 和 $10^{10}$ 之间取对数间隔值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 %% Question 8 % Load TrueImage (focus on Data2) TrueImage = Data2.TrueImage; mu=logspace(-10, 10, 100); for i=1:length(mu) val_mu=mu(i); % Deconvolve image with current mu x_hat_temp = deconvolve_image(Data2.Data, Data2.IR, val_mu); delta_2(i)=norm(x_hat_temp-TrueImage,2)/norm(TrueImage,2); delta_1(i)=norm(x_hat_temp-TrueImage,1)/norm(TrueImage,1); delta_inf(i)=norm(x_hat_temp-TrueImage,Inf)/norm(TrueImage,Inf); end % Find mu that minimizes each distance [min_delta_2,ind_min_delta_2]=min(delta_2); [min_delta_1,ind_min_delta_1]=min(delta_1); [min_delta_inf,ind_min_delta_inf]=min(delta_inf); mu_min_delta_2 = mu(ind_min_delta_2); mu_min_delta_1 = mu(ind_min_delta_1); mu_min_delta_inf = mu(ind_min_delta_inf); % Display the results fprintf(\u0026#39;Delta_2 的最小值为: %e，对应的 mu 为: %e\\n\u0026#39;, min_delta_2, mu_min_delta_2); fprintf(\u0026#39;Delta_1 的最小值为: %e，对应的 mu 为: %e\\n\u0026#39;, min_delta_1, mu_min_delta_1); fprintf(\u0026#39;Delta_inf 的最小值为: %e，对应的 mu 为: %e\\n\u0026#39;, min_delta_inf, mu_min_delta_inf); % Plot the distances as functions of mu figure; subplot(3,1,1) loglog(mu, delta_2, \u0026#39;b-\u0026#39;, \u0026#39;LineWidth\u0026#39;, 2); hold on; loglog(mu(ind_min_delta_2), min_delta_2, \u0026#39;ro\u0026#39;, \u0026#39;MarkerSize\u0026#39;, 8, \u0026#39;LineWidth\u0026#39;, 2); xlabel(\u0026#39;\\mu\u0026#39;); ylabel(\u0026#39;\\Delta_2(\\mu)\u0026#39;); title(\u0026#39;\\Delta_2 vs \\mu\u0026#39;); grid on; legend(\u0026#39;\\Delta_2(\\mu)\u0026#39;, [\u0026#39;Min at \\mu = \u0026#39;, num2str(mu_min_delta_2, \u0026#39;%.1e\u0026#39;)]); subplot(3,1,2) loglog(mu, delta_1, \u0026#39;g-\u0026#39;, \u0026#39;LineWidth\u0026#39;, 2); hold on; loglog(mu(ind_min_delta_1), min_delta_1, \u0026#39;ro\u0026#39;, \u0026#39;MarkerSize\u0026#39;, 8, \u0026#39;LineWidth\u0026#39;, 2); xlabel(\u0026#39;\\mu\u0026#39;); ylabel(\u0026#39;\\Delta_1(\\mu)\u0026#39;); title(\u0026#39;\\Delta_1 vs \\mu\u0026#39;); grid on; legend(\u0026#39;\\Delta_1(\\mu)\u0026#39;, [\u0026#39;Min at \\mu = \u0026#39;, num2str(mu_min_delta_1, \u0026#39;%.1e\u0026#39;)]); subplot(3,1,3) loglog(mu, delta_inf, \u0026#39;m-\u0026#39;, \u0026#39;LineWidth\u0026#39;, 2); hold on; loglog(mu(ind_min_delta_inf), min_delta_inf, \u0026#39;ro\u0026#39;, \u0026#39;MarkerSize\u0026#39;, 8, \u0026#39;LineWidth\u0026#39;, 2); xlabel(\u0026#39;\\mu\u0026#39;); ylabel(\u0026#39;\\Delta_\\infty(\\mu)\u0026#39;); title(\u0026#39;\\Delta_\\infty vs \\mu\u0026#39;); grid on; legend(\u0026#39;\\Delta_\\infty(\\mu)\u0026#39;, [\u0026#39;Min at \\mu = \u0026#39;, num2str(mu_min_delta_inf, \u0026#39;%.1e\u0026#39;)]); 1 2 3 4 5 Delta_2 的最小值为: 4.887066e-02，对应的 mu 为: 2.983647e-03 Delta_1 的最小值为: 1.337040e-01，对应的 mu 为: 1.204504e-02 Delta_inf 的最小值为: 1.855954e-01，对应的 mu 为: 7.564633e-03 和之前肉眼观察得到的 $\\mu$ 值相比，可见差距还是挺大的。\n​\t本文内容均为 ’ Problème inverse ’ 课程下的实验部分。\n​\t具体实验PDF文稿见 Jean-François Giovanelli 老师官方网站: http://giovannelli.free.fr\n","permalink":"http://localhost:1313/zh/posts/signal_cn/test/","summary":"摘要","title":"反问题 TP1"},{"content":"图像反卷积：Wiener-Hunt 方法\n主要针对图像去模糊问题，即从模糊(带噪)图像中恢复清晰图像。这属于逆问题的范畴，一半出现在处理真实测量系统时。由于每个测量系统（如温度计、CCD相机、光谱仪等）都受到基础物理学的限制，比如有限精度、有限动态范围、非零响应时间等。这意味着测得的量或多或少都有扭曲。因此这部分是对感兴趣物理量的某种扭曲程度的度量。\n大多数情况下，测量系统直接给出的测量数据通常具有足够的精度和鲁棒性。但是，也存在测量结果不准确的情况。为了解决精度问题，或者说至少部分地优化它，已经开发了特殊的信号和图像处理技术。在接下来的内容中，我们将通过一个简单的例子来展示此类方法。\n我们有一张未聚焦的图像。这种情况下，点的图像实际上会是一个斑点。捕获的图像将会因为模糊而受损，因为它是由真实图像中每个点生成的斑点的叠加结果。\n描述这种转换的最简单模型是线性不变滤波器，即卷积。示意图如下图所示。\n在上面的示意图中， $x_{n,m}$ 代表真实或原始图像，$y_{n,m}$ 代表观测到的图像，或者更确切地说，是我们通过相机拍到的未聚焦图像。添加分量 $b_{n,m}$ 是为了考虑测量和建模误差。\n描述测量过程的方程(二维)如下：\n$$ y_{n,m} = \\sum_{p=-P}^{P} \\sum_{q=-Q}^{Q} h_{p,q} x_{n-p,m-q} + b_{n,m} $$\n$y_{n,m}$ 是对于每个观测到的像素 $(n, m)$ 。在这个公式中，$P$ 和 $Q$ 是给定的整数。\n注意，滤波器通常来说都是低通滤波器，这就意味着它们无法准确地在输出中再现输入信号或图像中的所有分量，因为高频分量要么被强烈衰减，要么完全被拒绝，这也就是为什么 ‘‘恢复真实信号’‘或者说’‘图像的逆问题’’ 是如此困难：必须恢复那些要么完全不存在、要么“错误”观测到的高频分量。\n在下面的例子中，我们用线性方法来解决图像反卷积问题。这些线性方法依赖于最小二乘准则，并结合了二次惩罚。我们先介绍其理论部分，包括这些准则及其最小化器。此外，展示背后的技术细节，并提出了一种基于循环近似的方法，以实现快速的数值计算。\n1. 一维反卷积\n为了简化理论概念，我们先讨论在一维情况下的信号反卷积。这种简化情况允许对反卷积问题的分析更加深入，同时更容易掌握概念和思路。随后再引入二维情况，并将其视为一维情况的扩展。Matlab 实现部分仅涉及二维情况。\n1.1 一维建模\n在一维情况下，(1) 中给出的观测模型变为：\n$$ y_n = \\sum_{p=-P}^{P} h_p x_{n-p} + b_n $$\n如果我们有 $N$ 个样本，可以将相应的 $N$ 个方程写成矩阵形式：\n$$ \\mathbf{y} = \\mathbf{H} \\mathbf{x} + \\mathbf{b} $$\n​\t•\t向量 $\\mathbf{y}$ 包含了所有的 $N$ 个观测值（在二维情况下，它将包含模糊的图像）\n​\t•\t向量 $\\mathbf{x}$ 包含了恢复图像的样本，而 $\\mathbf{b}$ 是噪声样本。\n​\t•\t矩阵 $\\mathbf{H}$ ，称为模糊矩阵，具有以下经典结构：\n$$ H = \\begin{bmatrix} h_P \u0026amp; \\cdots \u0026amp; h_0 \u0026amp; \\cdots \u0026amp; h_{-P} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \\\\ 0 \u0026amp; h_P \u0026amp; \\cdots \u0026amp; h_0 \u0026amp; \\cdots \u0026amp; h_{-P} \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \\\\ 0 \u0026amp; 0 \u0026amp; h_P \u0026amp; \\cdots \u0026amp; h_0 \u0026amp; \\cdots \u0026amp; h_{-P} \u0026amp; 0 \u0026amp; \\cdots \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; h_P \u0026amp; \\cdots \u0026amp; h_0 \u0026amp; \\cdots \u0026amp; h_{-P} \u0026amp; \\cdots \\\\ \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \\end{bmatrix} $$\n​\t•\t$\\mathbf{H}$ 是一个 $N \\times N$ 的方阵，并且具有 Toeplitz 结构。\n因此，信号反卷积问题可以重新表述为: 在已知观测信号 $\\mathbf{y}$ 并知道卷积矩阵 $H$ 的情况下，估计向量 $\\mathbf{x}$\n1.2 带惩罚的最小二乘法\n提出的重建策略 (损失函数) 是一种带惩罚的最小二乘法。它包含两个部分：\n​\t•\t一个重构损失项，用于量化恢复信号 $\\mathbf{x}$ 与观测信号 $\\mathbf{y}$ 进行重新卷积后的相似性，从而确保恢复的信号与观测信号一致。\n​\t•\t一个惩罚项，用于限制恢复信号的连续样本之间的差异，确保其具有一定的规则性结构。\n该准则采用以下表达式：\n$$ J_{\\text{PLS}}(x) = | y - Hx |^2 + \\mu | Dx |^2 = (y - Hx)^t (y - Hx) + \\mu x^t D^t D x $$\n其中，$D$ 是阶数为 1，大小为 $(N - 1) \\times N$ 的差分矩阵，定义如下：\n$$ D = \\begin{bmatrix} \\cdots \u0026amp; -1 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \\\\ \\cdots \u0026amp; 0 \u0026amp; -1 \u0026amp; 1 \u0026amp; 0 \u0026amp; \\cdots \\\\ \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; \\cdots \\\\ \\cdots \u0026amp; 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 1 \u0026amp; \\cdots\\\\ \\end{bmatrix} $$\n带惩罚的最小二乘准则的最小化器为：\n$$ \\hat{x} = (H^t H + \\mu D^t D)^{-1} H^t y $$\n证明:\n$$ \\hat{x} = (H^T H + \\mu D^T D)^{-1} H^T y $$\n我们已知损失准则为:\n$$ J_{\\text{PLS}}(x) = y^T y - 2x^T H^T y + x^T H^T H x + \\mu x^T D^T D x $$\n求偏导为0:\n$$ \\hat{x} = (H^T H + \\mu D^T D)^{-1} H^T y $$\n特殊情况：\n在特定情况下 $\\mu = 0$ 时准则和最小化器的结果表达式变为 $J_{\\text{PLS}}(x) = |y - Hx|^2$\n最小化器方程为：\n$$ \\hat{x} = (H^T H)^{-1} H^T y $$\n此时准则变为经典的最小二乘问题，没有正则化项，也就是说，模型仅考虑最小化观测值与预测值之间的误差，而不会惩罚解的复杂度或平滑性。其解是经典的 最小二乘解。\n1.2.1 循环近似\n回到公式 (9) ，我们已知矩阵 $H^T H + \\mu D^T D$ 的大小为 $N \\times N$ ，当 $N$ 很大时，这种反演在计算上非常昂贵甚至不可行。\n比如说在处理图像时，比如对于 $1000 \\times 1000$ 的图像，矩阵的大小为 $10^6 \\times 10^6$ ，计算不了。在三维情况下，更复杂。\n因此为了计算 $\\hat{x}$ ，有几种方法可以克服这种大计算量的困难。\n下面我们考虑使用循环矩阵的特性，因为我们可以用对角矩阵来 “替换” 公式 (9) 中的矩阵 (通过快速傅里叶变换 FFT 可以将循环矩阵 “转化”为对角矩阵)。因此，使用对角矩阵进行计算时，乘法或反演等矩阵运算的复杂度将大大降低。\n但是，这需要先将矩阵 $H$ 和 $D$ 近似为循环矩阵 $\\tilde{H}$ 和 $\\tilde{D}$ 。\n循环近似涉及修改矩阵的右上角和/或左下角部分，使其具有循环结构。这种近似的核心假设是信号或图像在开始和结束部分是周期性的，即信号的末尾与开头相连接，形成一个环状结构。\n循环卷积矩阵 $\\tilde{H}$ 和 $\\tilde{D}$ 在傅里叶基下可以轻松对角化：\n$$ \\tilde{H} = F^T \\Lambda_h F \\quad \\text{和} \\quad \\tilde{D} = F^T \\Lambda_d F $$\n矩阵 $\\Lambda_h$ 是对角矩阵，其对角线上元素是 $H$ 的特征值。\n特征值可以通过对矩阵 $H$ 第一行进行快速傅里叶变换（FFT）获得，即计算脉冲响应的 $N$ 点 FFT，这些响应代表频率响应的样本。\n同样适用于矩阵 $\\tilde{D}$ 及其特征值，其中将脉冲响应替换为 $[-1, 1]$。\n通过在 (9) 中用 (18) 代替，并使用简单的矩阵操作，可以得到：\n$$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h} + \\mu \\Lambda_{d}^{\\dagger} \\Lambda_{d})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n在此基础上再进一步:\n$$ \\overset{\\circ}{\\hat{x}} = \\left[ \\Lambda_h^{\\dagger} \\Lambda_h + \\mu \\left( \\Lambda_{d_c}^{\\dagger} \\Lambda_{d_c} + \\Lambda_{d_r}^{\\dagger} \\Lambda_{d_r} \\right) \\right] \\Lambda_h^{\\dagger} \\dot{\\mathbf{y}} $$\n1 FT_x = 1 ./ (abs(Lambda_H).^2 + mu * (abs(Lambda_dC).^2 + abs(Lambda_dR).^2)).* (conj(Lambda_H).* FT_Data); $\\Lambda_h \\Rightarrow$ FT_IR = MyFFT2RI(IR, 256);\n$\\Lambda_{d_c} \\Rightarrow$ FT_Dc = MyFFT2RI(Dc, 256);\n$\\Lambda_{d_r} \\Rightarrow$ FT_Dr = MyFFT2RI(Dr, 256);\n回顾性质:\n$$ \\Lambda_H^{+} = (\\Lambda_H^T)^{} = \\Lambda_H^{} = \\operatorname{conj}(\\Lambda_H) $$\n因此有:\n$$ \\Lambda_H^{+} \\cdot \\Lambda_H = \\Lambda_H^{*} \\cdot \\Lambda_H = |\\Lambda_H|^2 $$\n证明：\n$$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h} + \\mu \\Lambda_{d}^{\\dagger} \\Lambda_{d})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n补充知识: $\\tilde{H}$ 是一个实矩阵，因此其复共轭等于它本身，$\\tilde{H} = \\tilde{H}^T$ 。$\\tilde{D}$ 同理\n在近似为循环矩阵后，公式 (15) 变为:\n$$ \\hat{x} = (\\tilde{H}^{T}\\tilde{H} + \\mu \\tilde{D}^{T}\\tilde{D})^{-1}\\tilde{H}^{T}y $$\n其中: $\\tilde{H} = F^T \\Lambda_h F$ 且 $\\tilde{D} = F^T \\Lambda_d F$ 将其带入上述公式，得:\n$$ \\hat{x} = ((F^{T}\\Lambda_{h}F)^{T}(F^{T}\\Lambda_{h}F) + \\mu (F^{T}\\Lambda_{d}F)^{T}(F^{T}\\Lambda_{d}F))^{-1}(F^{T}\\Lambda_{h}F)^{T}y $$\n因为傅里叶矩阵 $F$ 是一个正交矩阵，具有 $F F^{T} = I$ 的性质，即 $F^{T} = F^{-1}$\n并且我们有 $(F^{T}\\Lambda_{h}F)^{T} = F^{T}\\Lambda_{h}^{T}F$ 以及 $(F^{T}\\Lambda_{d}F)^{T} = F^{T}\\Lambda_{d}^{T}F$\n所以:\n令 $\\quad \\overset{\\circ}{\\hat{x}} = F \\hat{x}, \\quad \\overset{\\circ}{y} = F y$\n那么:\n$$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h} + \\mu \\Lambda_{d}^{\\dagger} \\Lambda_{d})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n证毕。\n特殊情况：\n当 $\\mu = 0$ 时，正则化项消失，公式简化为：\n$$ \\overset{\\circ}{\\hat{x}} = (\\Lambda_{h}^{\\dagger} \\Lambda_{h})^{-1} \\Lambda_{h}^{\\dagger} \\overset{\\circ}{y} $$\n这意味着我们仅仅执行了经典的 Wiener 去卷积，没有考虑图像的正则化。\n$$\\hat{x} = (\\tilde{H}^{T}\\tilde{H} )^{-1}\\tilde{H}^{T}y\\ $$\n没有正则化时，虽然理论上可以恢复原始信号，但是实际上收到的噪声影响很大，且没有约束来将其消除\n为了完成我们的讨论，我们首先构建向量 $g_{\\text{PLS}}$ ，其分量定义如下：\n$$ g_{PLS}^{n} = \\frac{\\overset{\\circ}{h}_{n}^{*}}{|\\overset{\\circ}h_n|^2 + \\mu |\\overset{\\circ}d_n|^2}\\quad \\text{for } n = 1, 2, \\dots, N $$\n因此，向量 $\\overset{\\circ}{\\hat{x}}$ 是通过向量 $g_{\\text{PLS}}$ 和 $\\overset{\\circ}{\\hat{y}}$ 之间逐元素相乘得到的：\n$$ \\overset{\\circ}{\\hat{x}} = g_{\\text{PLS}} .* \\overset{\\circ}{\\hat{y}} $$\n反卷积问题可以表述为在傅里叶域中进行的滤波操作，其中 $g_{\\text{PLS}}$ 代表离散传递函数。\n反卷积问题总结如下：\n​\t•\t① 构建 $\\mathring{h}$ 作为脉冲响应的 $N$ 点 FFT\n​\t•\t② 构建 $\\mathring{d}$ 作为 $[1; -1]$ 的 $N$ 点 FFT\n​\t•\t③ 构建包含传递函数 $g_{\\text{PLS}}$ 的向量\n​\t•\t④ 构建观测值的 FFT $\\mathring{y}$\n​\t•\t⑤ 计算 $\\mathring{\\hat{x}}$ ，作为传递函数 $g_{\\text{PLS}}$ 和 $\\mathring{\\hat{y}}$ 的乘积\n​\t•\t⑥ 计算 $\\mathring{\\hat{x}}$ 的 IFFT 以在空间域中获得解 $\\hat{x}$\n2 实现\n2.1 二维方法\n对于二维情况，其方程类似于一维情况。但是，所涉及的block-Tœplitz矩阵结构更加复杂: 每个块本身也具有 Tœplitz 结构。这使得在两个方向上进行循环近似变得更加困难。因此，二维情况仅作为一维情况的扩展来展示，重点是 Matlab 实现，理论部分暂不讨论。\n注意以下几点：\n​\t•\t图像、脉冲响应、正则化项都是二维的，这意味着必须使用 FFT-2D 而不是 FFT。\n​\t•\t更确切地说，如果要恢复的图像有 $N$ 行和 $N$ 列，那么 FFT-2D 必须在 $N$ 行和 $N$ 列上计算。\n​\t•\t频率传递函数也是二维的，每个空间频率有一个维度。\n特别说明 — 在任何情况下，矩阵 $H$ 和 $D$ 都不应在 Matlab 代码中构建。\n2.2 观测图像\n​\t•\t第一步是加载数据 Data1 和 Data2 。使用 load 函数来完成。每个数据文件内部包含：模糊图像 (Data)、用于比较的真实图像 (TrueIma)，以及卷积滤波器的脉冲响应 (IR)。现在分析每个数据集及其相互关系。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 clear all close all clc %% Load Data Data1 = load(\u0026#39;DataOne.mat\u0026#39;) Data2 = load(\u0026#39;DataTwo.mat\u0026#39;) % Create a window to display the image figure() subplot(1,2,1) % Display the image, grayscale imagesc(Data1.Data); colormap(\u0026#39;gray\u0026#39;); % Scale the axes and eliminate the grading axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) title(\u0026#39;Observed Image - Data1\u0026#39;); subplot(1,2,2) % Display the image, grayscale imagesc(Data2.Data); colormap(\u0026#39;gray\u0026#39;); % Scale the axes and eliminate the grading axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) title(\u0026#39;Observed Image - Data2\u0026#39;); 两观测图像都有明显的模糊，具体是边缘和结构细节处。这种模糊表明图像中的高频信息被卷积或散射了，导致图像细节的丢失，这就是由于卷积效应或低通滤波的影响而造成的。\n​\t•\t为了进一步分析，肯定要到频域看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 %% Analyse the images in the frequency domain (linear and a logarithmic scale) % % Get the sizes of the images % [M1,N1] = size(Data1.Data); % [M2,N2] = size(Data2.Data); % % Generate frequency axes for Data1 % u1 = (-M1/2:M1/2-1)/M1; % Normalized frequencies in y-direction % v1 = (-N1/2:N1/2-1)/N1; % Normalized frequencies in x-direction % % Generate frequency axes for Data2 % u2 = (-M2/2:M2/2-1)/M2; % v2 = (-N2/2:N2/2-1)/N2; % Generate normalized frequency axes using linspace Nu = linspace(-0.5, 0.5, 256); % Compute the 2D FFT of observed images and shift zero frequency to center FFT_Data1 = MyFFT2(Data1.Data); FFT_Data2 = MyFFT2(Data2.Data); % Magnitude spectra Mag_Data1 = abs(FFT_Data1) Mag_Data2 = abs(FFT_Data2) % Display magnitude spectra in linear scales figure(); subplot(1,2,1) imagesc(Nu,Nu,Mag_Data1); % Use frequency axes v1 and u1 xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); colormap(\u0026#39;gray\u0026#39;); title(\u0026#39;Magnitude (Linear Scale) - Data1\u0026#39;); subplot(1,2,2) imagesc(Nu,Nu,Mag_Data2); % Use frequency axes v2 and u2 xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); colormap(\u0026#39;gray\u0026#39;); title(\u0026#39;Magnitude (Linear Scale) - Data2\u0026#39;); % Display magnitude spectra in logarithmic scales figure; subplot(1,2,1) imagesc(Nu,Nu,log(1+Mag_Data1)); % Use log scale xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); colormap(\u0026#39;gray\u0026#39;); title(\u0026#39;Magnitude (logarithmic Scale) - Data1\u0026#39;); subplot(1,2,2) imagesc(Nu,Nu,log(1+Mag_Data2)); xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); colormap(\u0026#39;gray\u0026#39;); title(\u0026#39;Magnitude (logarithmic Scale) - Data2\u0026#39;); 可见只有两组频谱图的中心部分有强烈亮度，即低频分量较强，即图像大范围平滑信息较多，而高频部分的细节没有\n​\t•\t我们继续看两个脉冲响应 $h_{n,m}$ 及其关联的传递函数 $H(\\nu_x, \\nu_y)$ 。首先使用 imagesc 函数，然后使用 plot 函数来进行分析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 %% Calcul impulse responses and associated transfer functions using impulse % Load the impulse responses IR1 = Data1.IR; IR2 = Data2.IR; % Display the impulse responses figure; subplot(1,2,1) imagesc(IR1); colormap(\u0026#39;gray\u0026#39;); title(\u0026#39;Impulse Response - IR1\u0026#39;); subplot(1,2,2) imagesc(IR2); colormap(\u0026#39;gray\u0026#39;); title(\u0026#39;Impulse Response - IR2\u0026#39;); % Compute and display the transfer functions Long = 256; H1 = MyFFT2RI(IR1, Long); H2 = MyFFT2RI(IR2, Long); % Compute the magnitude spectra Mag_H1 = abs(H1); Mag_H2 = abs(H2); % Display the transfer functions using imagesc figure; subplot(1,2,1) imagesc(Nu, Nu, Mag_H1); xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); title(\u0026#39;Transfer Function Magnitude - H1\u0026#39;); colormap(\u0026#39;gray\u0026#39;); subplot(1,2,2) imagesc(Nu, Nu, Mag_H2); xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); title(\u0026#39;Transfer Function Magnitude - H2\u0026#39;); colormap(\u0026#39;gray\u0026#39;); 很明显，IR1 和 IR2 都是低通滤波器，只允许低频分量通过，高频分量进行衰减或完全抑制。IR1 的传递函数 H1 的分布更加平滑，说明它对低频分量的保留更为均匀。IR2 的滤波特性更倾向于选择性地保留某些低频分量，而非均匀地平滑整个低频区域。因此，相较于 IR1，IR2 对图像的细节影响更强。不过这么看看不出来具体的道道儿，还是得看下面的切片。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 %% Plot slices through the transfer functions using plot % Midpoint index (since Long = 256) mid_index = Long / 2 + 1; % This will be 129 % Plot slices for H1 figure; subplot(2,1,1) plot(Nu, Mag_H1(mid_index, :)); xlabel(\u0026#39;Normalized Frequency X\u0026#39;); ylabel(\u0026#39;Magnitude\u0026#39;); title(\u0026#39;Transfer Function along Central Row - H1\u0026#39;); grid on; subplot(2,1,2) plot(Nu, Mag_H1(:, mid_index)); xlabel(\u0026#39;Normalized Frequency Y\u0026#39;); ylabel(\u0026#39;Magnitude\u0026#39;); title(\u0026#39;Transfer Function along Central Column - H1\u0026#39;); grid on; 可见前面的结论是正确的，H1 幅值响应曲线变化相对平滑，适合图像整体的模糊处理任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 % Plot slices for H2 figure; subplot(2,1,1) plot(Nu, Mag_H2(mid_index, :)); xlabel(\u0026#39;Normalized Frequency X\u0026#39;); ylabel(\u0026#39;Magnitude\u0026#39;); title(\u0026#39;Transfer Function along Central Row - H2\u0026#39;); grid on; subplot(2,1,2) plot(Nu, Mag_H2(:, mid_index)); xlabel(\u0026#39;Normalized Frequency Y\u0026#39;); ylabel(\u0026#39;Magnitude\u0026#39;); title(\u0026#39;Transfer Function along Central Column - H2\u0026#39;); grid on; 在 H2 的切片图中，幅值响应曲线有更明显的周期性波动，适合特定方向的模糊或增强效果。\n2.3 Implementation\n我们将在二维情况下实现反卷积，并使用带有二次惩罚项的最小二乘法，同时使用循环近似进行最小化，在前面已经进行过了总结。\n关于正则化项，它依赖于图像列和行上相邻像素之间的差异。其表达式为：\n$$ | D x |^2 = \\sum_{n,m} (x_{n,m} - x_{n,m+1})^2 + (x_{n,m} - x_{n+1,m})^2 $$\n​\t•\t正则化项 $| D x |^2$ 代表了水平方向和垂直方向相邻像素值的平方差之和。\n因此它将基于两个滤波器(水平和垂直)来实现：\n$$ D_{horiz} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \u0026amp; 1 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix} \\quad D_{vert} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} $$\n这两个滤波器分别计算行和列上像素之间的差异。\n当然也可以从以下脉冲响应滤波器中选一个，它们都可以实现图像梯度的近似。\n$$ \\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0 \\\\ -1 \u0026amp; 4 \u0026amp; -1 \\\\ 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\quad \\text{或} \\quad \\begin{bmatrix} -1 \u0026amp; -1 \u0026amp; -1 \\\\ -1 \u0026amp; 8 \u0026amp; -1 \\\\ -1 \u0026amp; -1 \u0026amp; -1 \\end{bmatrix} \\quad \\text{或} \\quad \\begin{bmatrix} 1 \u0026amp; -2 \u0026amp; 1 \\\\ -2 \u0026amp; 4 \u0026amp; -2 \\\\ 1 \u0026amp; -2 \u0026amp; 1 \\end{bmatrix} $$\n回顾前面，我们得到：\n$$ \\hat{x} = (H^{T}H + \\mu D^{T}D)^{-1}H^{T}y $$\n现在进行傅里叶变换下的去卷积\n$$ \\hat{x}(\\nu_{x}, \\nu_{y}) = \\frac{\\hat{H}^{*}(\\nu_{x}, \\nu_{y}) \\hat{y}(\\nu_{x}, \\nu_{y})}{|\\hat{H}(\\nu_{x}, \\nu_{y})|^2 + \\mu |\\hat{D}(\\nu_{x}, \\nu_{y})|^2} $$\n​\t•\t$\\hat{H}(\\nu_{x}, \\nu_{y})$ 是卷积矩阵的傅里叶变换\n​\t•\t$\\hat{D}(\\nu_{x}, \\nu_{y})$ 是差分矩阵的傅里叶变换\n​\t•\t$\\hat{x}(\\nu_{x}, \\nu_{y})$ 是频域中的恢复图像\n我们先写一个反卷积函数，将观测数据 (Data)、脉冲响应 (IR) 和正则化参数 (mu) 作为输入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 function [x] = deconvolve_image(Data,IR,mu) Long = length(Data); Nu = linspace(-0.5, 0.5, Long); TF_Data = MyFFT2(Data); TF_IR = MyFFT2RI(IR,Long); % figure(1) % subplot(2, 1, 1) % imagesc(Nu, Nu, abs(TF_IR)) % title(\u0026#39;Frequency response\u0026#39;) % xlabel(\u0026#39;\\nu_x\u0026#39;) % ylabel(\u0026#39;\\nu_y\u0026#39;) % axis square % subplot(2, 1, 2) % plot(Nu, abs(TF_IR(round(length(TF_IR)/2), :))) % Define the regularization filters (difference operators) % Horizontal difference filter Dh = [0 0 0; 0 -1 1; 0 0 0]; % Vertical difference filter Dv = [0 0 0; 0 -1 0; 0 1 0]; % Compute the FFTs of the regularization filters using MyFFT2RI TF_Dh = MyFFT2RI(Dh, Long); TF_Dv = MyFFT2RI(Dv, Long); % Compute |Dh|^2 and |Dv|^2 abs_Dh_squared = abs(TF_Dh).^2; abs_Dv_squared = abs(TF_Dv).^2; % Total regularization term |D|^2 = |Dh|^2 + |Dv|^2 abs_D_squared = abs_Dh_squared + abs_Dv_squared; % Compute the denominator of the Wiener filter denom = abs(TF_IR).^2 + mu * abs_D_squared; % Compute the numerator numerator = conj(TF_IR) .* TF_Data; % Compute X_hat in the frequency domain TF_X = numerator ./ denom; % Compute the inverse FFT to get the deconvolved image % Since MyFFT2 uses fftshift, we need to use ifftshift before ifft2 x = MyIFFT2(TF_X); end ​\t•\t然后应用这个逆卷积函数，查看反卷积后的图像去噪效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 %% Question 5 mu = 0.004; % Deconvolve Data1 x_1 = deconvolve_image(Data1.Data, Data1.IR, mu); % Display the deconvolved image figure; subplot(1,2,1) % Display the image, grayscale imagesc(Data1.Data); colormap(\u0026#39;gray\u0026#39;); % Scale the axes and eliminate the grading axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) title([\u0026#39;Observed Image - Data1, \\mu = \u0026#39;, num2str(mu)]); subplot(1,2,2) imagesc(x_1); colormap(\u0026#39;gray\u0026#39;); title([\u0026#39;Deconvolved Image - Data1, \\mu = \u0026#39;, num2str(mu)]); axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) % Deconvolve Data2 x_2 = deconvolve_image(Data2.Data, Data2.IR, mu); % Display the deconvolved image figure; subplot(1,2,1) % Display the image, grayscale imagesc(Data2.Data); colormap(\u0026#39;gray\u0026#39;); % Scale the axes and eliminate the grading axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) title([\u0026#39;Observed Image - Data2, \\mu = \u0026#39;, num2str(mu)]); subplot(1,2,2) imagesc(x_2); colormap(\u0026#39;gray\u0026#39;); title([\u0026#39;Observed Image - Data2, \\mu = \u0026#39;, num2str(mu)]); axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) 可见效果挺理想，但是之前这个 $\\mu$ 是随便设的，现在探讨这个 $\\mu$ 值对结果的影响。\n​\t•\t首先考虑简单的逆滤波器情况，即 $\\mu = 0$ 。\n前面我们得到： $\\hat{x} = (H^{T}H + \\mu D^{T}D)^{-1}H^{T}y$\n现在变成： $\\hat{x} = (H^{T}H)^{-1}H^{T}y$\n$$ \\hat{x}(\\nu_{x}, \\nu_{y}) = \\frac{\\hat{H}^{*}(\\nu_{x}, \\nu_{y}) \\hat{y}(\\nu_{x}, \\nu_{y})}{|\\hat{H}(\\nu_{x}, \\nu_{y})|^2 } $$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 %% Question 6 Simple Inverse Filter (μ = 0) mu = 0; % Deconvolve Data1 x_1 = deconvolve_image(Data1.Data, Data1.IR, mu); % Display the deconvolved image figure; subplot(1,2,1) % Display the image, grayscale imagesc(Data1.Data); colormap(\u0026#39;gray\u0026#39;); % Scale the axes and eliminate the grading axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) title([\u0026#39;Observed Image - Data1, \\mu = \u0026#39;, num2str(mu)]); subplot(1,2,2) imagesc(x_1); colormap(\u0026#39;gray\u0026#39;); title([\u0026#39;Deconvolved Image - Data1, \\mu = \u0026#39;, num2str(mu)]); axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) 由于 $\\mu = 0$ 等价于丢失了正则化项，反卷积结果会直接依赖于卷积核 $H$ 的傅里叶系数 $|\\hat{H}(\\nu_{x}, \\nu_{y})|^2$ ，如果 $H$ 的某些频率分量（尤其是高频）接近零，那么在这些频率上，分母 $|\\hat{H}(\\nu_{x}, \\nu_{y})|^2$ 会非常小，导致反卷积结果中放大这些频率分量的噪声。反卷积图像中可以看到明显的颗粒状噪声。这是由于直接逆滤波在某些频率分量上产生了极大值，放大了噪声。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 % Deconvolve Data2 x_2 = deconvolve_image(Data2.Data, Data2.IR, mu); % Display the deconvolved image figure; subplot(1,2,1) % Display the image, grayscale imagesc(Data2.Data); colormap(\u0026#39;gray\u0026#39;); % Scale the axes and eliminate the grading axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) title([\u0026#39;Observed Image - Data2, \\mu = \u0026#39;, num2str(mu)]); subplot(1,2,2) imagesc(x_2); colormap(\u0026#39;gray\u0026#39;); title([\u0026#39;Observed Image - Data2, \\mu = \u0026#39;, num2str(mu)]); axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;) ​\t•\t我们因此取不同的 $\\mu$ 值(在 $\\log_{10}$ 刻度上取值)。并且根据结果，确定合适的 $\\mu$ 值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 %% Effect of Varying μ on Deconvolution Results % Define a range of mu values on a log scale mu_values = logspace(-11, 0, 12); % From 1e-10 to 1 % Deconvolution and display for Data1 figure(\u0026#39;Name\u0026#39;, \u0026#39;Deconvolution Results for Data1\u0026#39;); for i = 1:length(mu_values) mu = mu_values(i); x_1 = deconvolve_image(Data1.Data, Data1.IR, mu); subplot(3,4,i); imagesc(x_1); colormap(\u0026#39;gray\u0026#39;); axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;); title([\u0026#39;\\mu = \u0026#39;, num2str(mu, \u0026#39;%.1e\u0026#39;)]); end sgtitle(\u0026#39;Deconvolved Images - Data1 with Different \\mu Values\u0026#39;); % Deconvolution and display for Data2 figure(\u0026#39;Name\u0026#39;, \u0026#39;Deconvolution Results for Data2\u0026#39;); for i = 1:length(mu_values) mu = mu_values(i); x_2 = deconvolve_image(Data2.Data, Data2.IR, mu); subplot(3,4,i); imagesc(x_2); colormap(\u0026#39;gray\u0026#39;); axis(\u0026#39;square\u0026#39;,\u0026#39;off\u0026#39;); title([\u0026#39;\\mu = \u0026#39;, num2str(mu, \u0026#39;%.1e\u0026#39;)]); end sgtitle(\u0026#39;Deconvolved Images - Data2 with Different \\mu Values\u0026#39;); 小的 $\\mu$ 值时，可见图像噪声多，甚至都有可能完全被噪声埋没; 中等 $\\mu$ 值 时，图像细节和噪声之间达到了较好的平衡; 当 $\\mu$ 值过大时，图像变得过于平滑，细节逐渐丢失，尤其是当 $\\mu = 1$ 时。我们目前只能通过视觉方法来选出较好的 $\\mu$ 值，两数据最优 $\\mu$ 值都大约等于 0.01，但是这样肯定是不行的，是不严谨的，是无法成为一名科研奇才的，因此我们和真实图像做数学比较。\n2.4 超参数的作用\n上一点使我们能够评估与反卷积问题相关的内在难度。它还表明，考虑重建图像期望正则性的先验信息可以获得更好的结果。这种方法因此使我们能够在两种信息源之间进行折衷：观测数据和可用的先验信息（关于正则性）。这是通过参数 $\\mu$ 的值来实现的。在下面的研究中，选择一个最合适的 $\\mu$ 值，以使反卷积图像既不过于平滑也不过于不规则。\n因此，可以计算反卷积图像 $\\hat{x}$ 和真实图像 $x^\\star$ 之间的数值差异，作为正则化参数 $\\mu$ 的函数。\n为此，考虑以下三种距离函数：\n$$\\Delta_2(\\mu) = \\frac{\\sum_{p,q} (\\hat{x}_{p,q}(\\mu) - x^{\\star}_{p,q})^2}{\\sum_{p,q} (x^{\\star}_{p,q})^2} = \\frac{\\|\\hat{x}(\\mu) - x^{\\star}\\|_2^2}{\\|x^{\\star}\\|_2^2}$$ $$\\Delta_1(\\mu) = \\frac{\\sum_{p,q} |\\hat{x}_{p,q}(\\mu) - x^{\\star}_{p,q}|}{\\sum_{p,q} |x^{\\star}_{p,q}|} = \\frac{\\|\\hat{x}(\\mu) - x^{\\star}\\|_1}{\\|x^{\\star}\\|_1}$$ $$\\Delta_\\infty(\\mu) = \\frac{\\max_{p,q} |\\hat{x}_{p,q}(\\mu) - x^{\\star}_{p,q}|}{\\max_{p,q} |x^{\\star}_{p,q}|} = \\frac{\\|\\hat{x}(\\mu) - x^{\\star}\\|_\\infty}{\\|x^{\\star}\\|_\\infty}$$ 当恢复的图像类似于真实图像时，这些距离接近于 0，当恢复的图像为零时，它们接近 1。\n​\t•\t我们设定 $\\mu$ 值在 $10^{-10}$ 和 $10^{10}$ 之间取对数间隔值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 %% Question 8 % Load TrueImage (focus on Data2) TrueImage = Data2.TrueImage; mu=logspace(-10, 10, 100); for i=1:length(mu) val_mu=mu(i); % Deconvolve image with current mu x_hat_temp = deconvolve_image(Data2.Data, Data2.IR, val_mu); delta_2(i)=norm(x_hat_temp-TrueImage,2)/norm(TrueImage,2); delta_1(i)=norm(x_hat_temp-TrueImage,1)/norm(TrueImage,1); delta_inf(i)=norm(x_hat_temp-TrueImage,Inf)/norm(TrueImage,Inf); end % Find mu that minimizes each distance [min_delta_2,ind_min_delta_2]=min(delta_2); [min_delta_1,ind_min_delta_1]=min(delta_1); [min_delta_inf,ind_min_delta_inf]=min(delta_inf); mu_min_delta_2 = mu(ind_min_delta_2); mu_min_delta_1 = mu(ind_min_delta_1); mu_min_delta_inf = mu(ind_min_delta_inf); % Display the results fprintf(\u0026#39;Delta_2 的最小值为: %e，对应的 mu 为: %e\\n\u0026#39;, min_delta_2, mu_min_delta_2); fprintf(\u0026#39;Delta_1 的最小值为: %e，对应的 mu 为: %e\\n\u0026#39;, min_delta_1, mu_min_delta_1); fprintf(\u0026#39;Delta_inf 的最小值为: %e，对应的 mu 为: %e\\n\u0026#39;, min_delta_inf, mu_min_delta_inf); % Plot the distances as functions of mu figure; subplot(3,1,1) loglog(mu, delta_2, \u0026#39;b-\u0026#39;, \u0026#39;LineWidth\u0026#39;, 2); hold on; loglog(mu(ind_min_delta_2), min_delta_2, \u0026#39;ro\u0026#39;, \u0026#39;MarkerSize\u0026#39;, 8, \u0026#39;LineWidth\u0026#39;, 2); xlabel(\u0026#39;\\mu\u0026#39;); ylabel(\u0026#39;\\Delta_2(\\mu)\u0026#39;); title(\u0026#39;\\Delta_2 vs \\mu\u0026#39;); grid on; legend(\u0026#39;\\Delta_2(\\mu)\u0026#39;, [\u0026#39;Min at \\mu = \u0026#39;, num2str(mu_min_delta_2, \u0026#39;%.1e\u0026#39;)]); subplot(3,1,2) loglog(mu, delta_1, \u0026#39;g-\u0026#39;, \u0026#39;LineWidth\u0026#39;, 2); hold on; loglog(mu(ind_min_delta_1), min_delta_1, \u0026#39;ro\u0026#39;, \u0026#39;MarkerSize\u0026#39;, 8, \u0026#39;LineWidth\u0026#39;, 2); xlabel(\u0026#39;\\mu\u0026#39;); ylabel(\u0026#39;\\Delta_1(\\mu)\u0026#39;); title(\u0026#39;\\Delta_1 vs \\mu\u0026#39;); grid on; legend(\u0026#39;\\Delta_1(\\mu)\u0026#39;, [\u0026#39;Min at \\mu = \u0026#39;, num2str(mu_min_delta_1, \u0026#39;%.1e\u0026#39;)]); subplot(3,1,3) loglog(mu, delta_inf, \u0026#39;m-\u0026#39;, \u0026#39;LineWidth\u0026#39;, 2); hold on; loglog(mu(ind_min_delta_inf), min_delta_inf, \u0026#39;ro\u0026#39;, \u0026#39;MarkerSize\u0026#39;, 8, \u0026#39;LineWidth\u0026#39;, 2); xlabel(\u0026#39;\\mu\u0026#39;); ylabel(\u0026#39;\\Delta_\\infty(\\mu)\u0026#39;); title(\u0026#39;\\Delta_\\infty vs \\mu\u0026#39;); grid on; legend(\u0026#39;\\Delta_\\infty(\\mu)\u0026#39;, [\u0026#39;Min at \\mu = \u0026#39;, num2str(mu_min_delta_inf, \u0026#39;%.1e\u0026#39;)]); 1 2 3 4 5 Delta_2 的最小值为: 4.887066e-02，对应的 mu 为: 2.983647e-03 Delta_1 的最小值为: 1.337040e-01，对应的 mu 为: 1.204504e-02 Delta_inf 的最小值为: 1.855954e-01，对应的 mu 为: 7.564633e-03 和之前肉眼观察得到的 $\\mu$ 值相比，可见差距还是挺大的。\n​\t本文内容均为 ’ Problème inverse ’ 课程下的实验部分。\n​\t具体实验PDF文稿见 Jean-François Giovanelli 老师官方网站: http://giovannelli.free.fr\n","permalink":"http://localhost:1313/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98tp1/","summary":"实验内容","title":"反问题 TP1"},{"content":"Wiener-Hunt 方法：无监督方面\n在上一个实践内容中，我们介绍了去卷积问题的困难，即在应用卷积或者低通滤波器后所导致的观测数据缺失高频相关信息的情况。我们使用了 $Wiener$-$Hunt$ 方法：将量化解的误差的二次项和数据相结合，并在损失函数中使用带有正则化系数的二次惩罚标准以量化解的粗糙度。我们得到了相对来说不错的结果。但是这个方法的缺点是它需要调节一个参数，即正则化参数 $\\mu$。我们最开始由经验选择到观察选择，一直到最后循环找到 $\\mu$ 的最优值，使得去卷积后的图像既不过于不规则也不过于平滑。下面的工作重点在于介绍一种自动调节超参数的方法。\n1. 超参数与全后验分布\n这个方法基于 $Wiener$-$Hunt$ 解的贝叶斯解释。该解释本身基于关于误差 $e$ 和关于图像 $x$ 的两个高斯概率模型。\n1.1 误差分布\n误差被建模为 $blanc$、零均值同质高斯向量。$blanc$ 指的是像白噪音一样，在其频谱特性中，所有频率分量有相同的功率密度，即信号在不同频率上的能量分布是均匀的。在数学层面，它具有零相关性，即不同时间点的误差值是统计独立的（不相关的）。\n对于高斯分布，选择了一个涉及所谓精度参数 $\\gamma_e$（方差的倒数）的替代参数化。根据这种参数化，其表达式可写为：\n$$f(e \\mid \\gamma_e) = (2\\pi)^{-N/2} \\gamma_e^{N/2} \\exp\\left( -\\frac{\\gamma_e \\| e \\|^2 }{2} \\right)$$ 根据 $y = Hx + e$，数据 $y$ 和感兴趣信号 $x$ 的似然函数表达式：\n$$f(y \\mid x, \\gamma_e) = (2\\pi)^{-N/2} \\gamma_e^{N/2} \\exp\\left( -\\frac{\\gamma_e \\| y - Hx \\|^2 }{2} \\right)$$ 根据所给的似然表达式 $f(y \\mid x, \\gamma_e)$，量化重建物体 $x$ 相对于观测数据 $y$ 的充分性可以通过协对数（log-likelihood）的形式表示。这种表达经常用于概率模型中，特别是最大似然估计（MLE）或贝叶斯推断中，用于评估模型参数的适配程度。\n再补充一下协对数相关内容，就是似然函数取对数，对于上述似然函数表达式，取其对数后为：\n$$\\log f(y \\mid x, \\gamma_e) = \\log\\left( (2\\pi)^{-N/2} \\gamma_e^{N/2} \\exp\\left( -\\frac{\\gamma_e \\| y - Hx \\|^2 }{2} \\right) \\right)$$ 利用对数的性质：$\\ln(a \\cdot b) = \\ln a + \\ln b$，将三部分拆分开：\n$$\\log f(y \\mid x, \\gamma_e) = \\log\\left( (2\\pi)^{-N/2} \\right) + \\log\\left( \\gamma_e^{N/2} \\right) + \\log\\left( \\exp\\left( -\\frac{\\gamma_e \\| y - Hx \\|^2 }{2} \\right) \\right)$$ 逐项计算：\n$$\\log\\left( (2\\pi)^{-N/2} \\right) = -\\frac{N}{2} \\log(2\\pi)$$ $$\\log\\left( \\gamma_e^{N/2} \\right) = \\frac{N}{2} \\log(\\gamma_e)$$ $$\\log\\left( \\exp\\left( -\\frac{\\gamma_e \\| y - Hx \\|^2 }{2} \\right) \\right) = -\\frac{\\gamma_e}{2} \\| y - Hx \\|^2$$ 合并后：\n$$\\log f(y \\mid x, \\gamma_e) = -\\frac{N}{2} \\log(2\\pi) + \\frac{N}{2} \\log(\\gamma_e) - \\frac{\\gamma_e}{2} \\| y - Hx \\|^2$$ 回到之前的内容，我们使用了协对数来表达数据能否充分重建原信号，我们给出这种拟合程度的量化指标：\n$$\\mathcal{J}_{LS}(x) = \\| y - Hx \\|^2 = -k_y \\log f(y \\mid x, \\gamma_e) + C_y$$ ​\t•\t$| y - Hx |^2$ 是重建信号（模型参数 $x$）与观测数据 $y$ 的误差平方和，称为残差平方和（Residual Sum of Squares, RSS）。\n​\t•\t$-k_y \\log f(y \\mid x, \\gamma_e)$ 是协对数的负加权形式，其中 $k_y \u0026gt; 0$，是一个常数。\n​\t•\t$C_y$ 也是一个常数。\n我们现在给出两个常数 $k_y$ 和 $C_y$ 的对应表达式：\n前面得到：\n$$\\log f(y \\mid x, \\gamma_e) = -\\frac{N}{2} \\log(2\\pi) + \\frac{N}{2} \\log(\\gamma_e) - \\frac{\\gamma_e}{2} \\| y - Hx \\|^2$$ 将上述结果带入 $J_{LS}(x) = -k_y \\log f(y \\mid x, \\gamma_e) + C_y$ 得：\n$$J_{LS}(x) = -k_y \\left( -\\frac{N}{2} \\log(2\\pi) + \\frac{N}{2} \\log(\\gamma_e) - \\frac{\\gamma_e}{2} \\| y - Hx \\|^2 \\right) + C_y$$ 展开并整理：\n$$J_{LS}(x) = k_y \\left( \\frac{N}{2} \\log(2\\pi) - \\frac{N}{2} \\log(\\gamma_e) + \\frac{\\gamma_e}{2} \\| y - Hx \\|^2 \\right) + C_y$$ 将上述结果和原公式 $\\mathcal{J}_{LS}(x) = | y - Hx |^2$ 对比，得到结果：\n$$k_y = \\frac{2}{\\gamma_e} \\quad\\quad\\quad C_y = -\\frac{N}{\\gamma_e} \\left( \\log(2\\pi) - \\log(\\gamma_e) \\right)$$ 1.2 感兴趣信号的分布\n贝叶斯解释要求为感兴趣的信号 $x$ 提供一个概率分布。其模型也是高斯分布，只是这里它不是白色的，也就是说，它的各组成部分之间存在相关性。在接下来的内容中，相关性实际上是通过协方差矩阵 $R$ 来建模的。\n贝叶斯解释的核心思想是为感兴趣的信号 $x$ 提供一个概率分布，而不是一个确定值。这种概率分布反映了我们对 $x$ 的不确定性以及其任何可能的取值。因此我们假设在模型中，$x$ 服从一个高斯分布。\n但是它是一个非白色的高斯分布，也就是它的各组成部分之间存在相关性，协方差矩阵 $R$ 是一个非对角矩阵，其非零非对角元素表示信号的不同分量之间的相关性。后续我们就使用这个协方差矩阵 $R$ 在贝叶斯框架中建模信号的相关性。\n补充一下关于协方差矩阵的相关内容\n协方差矩阵 $R$ 提供了对信号相关性的精确描述。元素 $R_{ij}$ 表示信号第 $i$ 和第 $j$ 个分量之间的协方差：\n$$R_{ij} = \\mathbb{E}\\left[ (x_i - \\mu_i)(x_j - \\mu_j) \\right]$$ 根据相关性，$R$ 可能是一个稀疏矩阵或者满矩阵。\n在贝叶斯建模中：\n​\t1.\t信号 $x$ 的先验分布 $p(x)$ 使用协方差矩阵 $R$ 的描述公式为：\n$$p(x) = \\frac{1}{(2\\pi)^{N/2} |R|^{1/2}} \\exp\\left( -\\frac{1}{2} x^T R^{-1} x \\right)$$ 其中，$R^{-1}$ 是协方差矩阵的逆，也称为精度矩阵，定义了 $x$ 的相关性强度。\n​\t2.\t最大后验估计（MAP）：\n利用先验分布 $p(x)$ 和观测数据 $y$ 的似然函数 $p(y \\mid x)$，可以通过贝叶斯法则计算 $x$ 的后验概率分布 $p(x \\mid y)$，并基于该分布选择最优解。\n回到之前，我们通过逆矩阵 $R^{-1} = \\gamma_x \\Pi$ 来表示建模信号的相关性，\n其中：\n​\t•\t精度参数 $\\gamma_x$ 控制相关性的强度\n​\t•\t矩阵 $\\Pi$ 决定了相关性的结构\n我们将 $R^{-1} = \\gamma_x \\Pi$ 带入之前的 $f(x \\mid \\gamma_x)$ 公式可得：\n$$f(x \\mid \\gamma_x) = (2\\pi)^{-N/2} \\det(\\Pi)^{1/2} \\gamma_x^{N/2} \\exp\\left( -\\frac{\\gamma_x}{2} x^T \\Pi x \\right)$$ 也就是说：\n$$f(x \\mid \\gamma_x) \\propto \\exp\\left( -\\frac{\\gamma_x}{2} x^T \\Pi x \\right)$$ 量化物体相对于先验信息充分性的项表现为密度的协对数：\n$$\\mathcal{J}_0(x) = -k_x \\log f(x \\mid \\gamma_x) + C_x = x^T \\Pi x$$ 其中：\n​\t•\t$\\mathcal{J}_0(x)$ 是对信号 $x$ 的量化，用来描述 $x$ 相对于先验信息（即对 $x$ 的已知假设或统计特性）是否充分匹配。其形式以密度的协对数（具体是取对数的负数）表示，结合了贝叶斯模型中的先验分布。\n​\t•\t$f(x \\mid \\gamma_x)$ 是 $x$ 的先验概率密度函数，反映了 $x$ 如何符合假设的先验模型，我们之前在假设 $x$ 服从高斯分布的前提下，得到了其表达式（见上面）。\n​\t•\t正则化项 $x^T \\Pi x$ 描述了信号 $x$ 的“复杂度”或“平滑性”，由 $\\Pi$ 决定其结构，精度参数 $\\gamma_x$ 控制正则化的强度，当 $\\gamma_x$ 较大时，正则化约束更强。\n同样，在上述公式中，我们添加了加法常数 $C_x$ 和乘法常数 $k_x$。为了与之前已经计算过的 Wiener-Hunt 方法联系起来，只需选择 $\\Pi = D^T D$。\n现在我们要给出两个常数的对应表达式。\n已知原公式：\n$$f(x \\mid \\gamma_x) = (2\\pi)^{-N/2} \\det(\\Pi)^{1/2} \\gamma_x^{N/2} \\exp\\left( -\\frac{\\gamma_x}{2} x^T \\Pi x \\right)$$ 两边取对数：\n$$\\log f(x \\mid \\gamma_x) = -\\frac{N}{2} \\log(2\\pi) + \\frac{1}{2} \\log\\det(\\Pi) + \\frac{N}{2} \\log(\\gamma_x) - \\frac{\\gamma_x}{2} x^T \\Pi x$$ 根据公式：\n$$\\mathcal{J}_0(x) = -k_x \\log f(x \\mid \\gamma_x) + C_x$$ 将上述结果带入其中得到：\n$$\\mathcal{J}_0(x) = -k_x \\left( -\\frac{N}{2} \\log(2\\pi) + \\frac{1}{2} \\log\\det(\\Pi) + \\frac{N}{2} \\log(\\gamma_x) - \\frac{\\gamma_x}{2} x^T \\Pi x \\right) + C_x$$ 展开并整理：\n$$\\mathcal{J}_0(x) = k_x \\left( \\frac{N}{2} \\log(2\\pi) - \\frac{1}{2} \\log\\det(\\Pi) - \\frac{N}{2} \\log(\\gamma_x) + \\frac{\\gamma_x}{2} x^T \\Pi x \\right) + C_x$$ 对比：\n$$\\mathcal{J}_0(x) = x^T \\Pi x$$ 得到：\n$$k_x = \\frac{2}{\\gamma_x} \\quad\\quad\\quad C_x = \\frac{N}{\\gamma_x} \\log(2\\pi) - \\frac{1}{\\gamma_x} \\log\\det(\\Pi) - \\frac{N}{\\gamma_x} \\log(\\gamma_x)$$ 但是严格来说，上述解释并不完全正确，因为 $D^T D$ 中常量图像只不过是对应于特征值为零的特征向量（这对应于零频率）。严格的发展要求引入一个用于零频率下能量的惩罚项（通过一个可以设定为任意小值的参数）。这一点在此不做深入讨论。\n上面提到的这个 $f(x \\mid \\gamma_x) = (2\\pi)^{-N/2} \\det(\\Pi)^{1/2} \\gamma_x^{N/2} \\exp\\left( -\\frac{\\gamma_x}{2} x^T \\Pi x \\right)$ 是先验分布（a priori），因为它使人们能够处理先验信息，从而更倾向于具有更高规则性的图像。对于给定图像的概率越高，则图像越规则。\n其中的 $\\gamma_x$ 精度参数我们非常关注，因为它控制着图像的平滑度，进而影响着概率分布的整体趋势。\n​\t•\t当 $\\gamma_x$ 较大时，指数项中的 $x^T \\Pi x$ 会被放大。\n​\t•\t当 $\\gamma_x$ 较小时，指数项中的 $x^T \\Pi x$ 对总的概率密度的影响较小。\n1.3 后验分布\n借助前面定义的两个成分，并使用概率的乘法规则，现在可以构造重构信号 $x$ 和数据 $y$ 的联合密度：\n$$f(x, y \\mid \\gamma_e, \\gamma_x) = f(y \\mid x, \\gamma_e) \\, f(x \\mid \\gamma_x)$$ 将之前得到的结果代入：\n$$f(x, y \\mid \\gamma_e, \\gamma_x) = (2\\pi)^{-N} \\det(\\Pi)^{1/2} \\gamma_e^{N/2} \\gamma_x^{N/2} \\exp\\left( -\\frac{1}{2} \\left[ \\gamma_e \\| y - Hx \\|^2 + \\gamma_x x^T \\Pi x \\right] \\right)$$ 这个表达式由两个精度参数 $\\gamma_e$ 和 $\\gamma_x$ 参数化。可以注意到在指数项内部，我们得到了加权最小二乘准则的表达式：\n$$\\mathcal{J}_{PLS}(x) = \\mathcal{J}_{LS}(x) + \\mu \\mathcal{J}_0(x)$$ $$\\mathcal{J}_{PLS}(x) = \\| y - Hx \\|^2 + \\mu x^T \\Pi x$$ 其中，正则化参数 $\\mu$ 表示为信噪比的倒数 $\\mu = \\gamma_x / \\gamma_e$。\n通过贝叶斯定理可以确定感兴趣信号的后验分布（后验概率分布）：\n$$f(x \\mid y, \\gamma_e, \\gamma_x) = \\frac{f(x, y \\mid \\gamma_e, \\gamma_x)}{f(y \\mid \\gamma_e, \\gamma_x)} \\propto \\exp\\left( -\\frac{\\gamma_e}{2} \\mathcal{J}_{PLS}(x) \\right)$$ 这就是给定数据（已观测到的）和参数下的感兴趣信号的分布。\n我们希望为感兴趣信号构造的任何估计器都基于上述分布。最常见的估计器是后验分布的均值、中位数或众数（即后验的最大化者）。在当前情况下，当后验分布是高斯分布时，这三者是相等的。众数或后验最大化者（MAP），记为 $\\hat{x}{MAP}$，是最小化准则 $\\mathcal{J}{PLS}(x)$ 的解：\n$$\\hat{x}_{MAP} = \\arg\\max_{x} f(x \\mid y, \\gamma_e, \\gamma_x) = \\arg\\min_{x} \\mathcal{J}_{PLS}(x) = \\hat{x}_{PLS}$$ 结论是，最小二乘准则的解 $\\hat{x}{PLS}$，就是之前的工作中推导出来的后验分布的众数 $\\hat{x}{MAP}$。\n1.4 扩展的后验分布\n到目前为止，贝叶斯方法只允许我们对已经存在的超参数值的估计给出概率解释。将之前的框架扩展到包含超参数的估计，需要为两个精度参数 $\\gamma_e$ 和 $\\gamma_x$ 引入一个先验分布。在多种可选方案中，接下来我们将重点关注伽马分布：\n$$f(\\gamma) = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} \\gamma^{\\alpha - 1} \\exp\\left( -\\beta \\gamma \\right) \\cdot 1_{\\mathbb{R}^+}(\\gamma)$$ 它由两个正实数参数 $(\\alpha, \\beta)$ 驱动，具有均值 $\\alpha / \\beta$ 和方差 $\\alpha / \\beta^2$。这种选择的理由如下：\n​\t•\t选择伽马分布作为先验分布确保了条件后验分布也是伽马分布（即共轭先验）。在算法上，这意味着只需要更新分布参数的值（具体见下面）。\n​\t•\t这种选择允许在参数值的信息较少（也称为“非信息先验”）或精确（如名义值或某种不确定性）的情况下进行处理。该工作中特别感兴趣的是“非信息先验”的极限情况，即 $(\\alpha, \\beta) = (0, 0)$。\n此外，关于变量 $\\gamma_e$ 和 $\\gamma_x$ 的组合，它们被建模为独立的。\n从伽马分布：\n$$f(\\gamma) = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} \\gamma^{\\alpha - 1} \\exp\\left( -\\beta \\gamma \\right) \\cdot 1_{\\mathbb{R}^+}(\\gamma)$$ 和部分联合分布：\n$$f(x, y \\mid \\gamma_e, \\gamma_x) = f(y \\mid x, \\gamma_e) \\, f(x \\mid \\gamma_x) = (2\\pi)^{-N} \\det(\\Pi)^{1/2} \\gamma_e^{N/2} \\gamma_x^{N/2} \\exp\\left( -\\frac{1}{2} \\left[ \\gamma_e \\| y - Hx \\|^2 + \\gamma_x x^T \\Pi x \\right] \\right)$$ 的表达式出发，我们推导出对于 $y, x, \\gamma_e$ 和 $\\gamma_x$ 的完整联合分布的表达式为：\n$$f(y, x, \\gamma_e, \\gamma_x) = f(x, y \\mid \\gamma_e, \\gamma_x) \\, f(\\gamma_e) \\, f(\\gamma_x)$$ $$f(x, y, \\gamma_e, \\gamma_x) = (2\\pi)^{-N} \\det(\\Pi)^{1/2} \\frac{\\beta_e^{\\alpha_e} \\beta_x^{\\alpha_x}}{\\Gamma(\\alpha_e) \\Gamma(\\alpha_x)} \\gamma_e^{\\alpha_e + N/2 - 1} \\gamma_x^{\\alpha_x + N/2 - 1} \\exp\\left( -\\gamma_e \\left( \\beta_e + \\frac{\\| y - Hx \\|^2 }{2} \\right) - \\gamma_x \\left( \\beta_x + \\frac{x^T \\Pi x}{2} \\right) \\right)$$ 注意：这个密度非常重要，因为它允许推导出所有相关的联合、边缘和条件密度。\n现在我们可以通过贝叶斯规则推导出完整的后验分布，即给定观测数据时，感兴趣信号和超参数的分布：\n$$f(x, \\gamma_e, \\gamma_x \\mid y) = \\frac{f(x, y, \\gamma_e, \\gamma_x)}{f(y)}$$ 省略分母 $f(y)$，我们有：\n$$f(x, \\gamma_e, \\gamma_x \\mid y) \\propto \\gamma_e^{\\alpha_e + N/2 - 1} \\gamma_x^{\\alpha_x + N/2 - 1} \\exp\\left( -\\gamma_e \\left( \\beta_e + \\frac{\\| y - Hx \\|^2 }{2} \\right) - \\gamma_x \\left( \\beta_x + \\frac{x^T \\Pi x}{2} \\right) \\right)$$ 这汇总了所有关于感兴趣信号和超参数在数据视角下的可用信息：对于三重项 $x, \\gamma_e, \\gamma_x$，它量化了后验密度，即在给定观测数据下三重项的概率。感兴趣信号和超参数的估计器是从这个分布中构造出来的。我们可以查看后验分布的均值、中位数或众数。每种方法都有其优缺点。在接下来的内容中，我们将重点讨论均值。\n1.5 后验均值\n考虑到后验分布（上面这个）的复杂性，获得均值的解析公式是不可行的。为了计算后验均值，有几种方法可用，在这里我们将重点关注随机采样技术。最终，它归结为对后验分布进行随机采样，然后取样本的经验均值，从而近似后验均值。\n后验分布的采样可以通过马尔可夫链蒙特卡洛（MCMC）方法来实现。它要求构建一个迭代过程，以生成随机样本，经过一定的时间（称为 burn-in），这些样本将根据目标分布进行分布。构建这样一个过程并不容易，但在当前情况下，存在一个标准算法可以轻松使用：Gibbs 采样算法。它将对三重项 $x, \\gamma_e, \\gamma_x$ 的后验分布进行采样的问题，转换为它们三个各自的更简单分布的采样问题。每个分布实际上是条件分布，给定其余参数的条件下对其中一个参数进行采样。该算法的工作原理在下表中给出，接下来的部分我们将详细说明这些步骤。\n$$\\begin{aligned}\u0026\\bullet \\, \\text{Initialize } x^{[0]} = y \\\\\u0026\\bullet \\, \\text{For } k = 1, 2, \\dots \\, \\text{repeat} \\\\\u0026\\quad \\text{(a) sample } \\gamma_e^{[k]} \\text{ under } f(\\gamma_e \\mid \\gamma_x^{[k-1]}, x^{[k-1]}, y) \\\\\u0026\\quad \\text{(b) sample } \\gamma_x^{[k]} \\text{ under } f(\\gamma_x \\mid \\gamma_e^{[k]}, x^{[k-1]}, y) \\\\\u0026\\quad \\text{(c) sample } x^{[k]} \\text{ under } f(x \\mid \\gamma_e^{[k]}, \\gamma_x^{[k]}, y)\\end{aligned}$$ ","permalink":"http://localhost:1313/zh/posts/signal_cn/%E5%8F%8D%E9%97%AE%E9%A2%98-tp2/","summary":"实验内容","title":"反问题 TP2"},{"content":"所有理论内容均为相关课程记录，课上手写记录，课后转为电子版，并对内容作出了进一步的翻译和解释，因此本人只有劳动成果，所有学术成果均归指导教师所有，每篇文章的最后均有标注指导教师以及对应的个人网站(如果有的话)。\n所有实践内容均为实验课后报告的中文版，理论和代码部分基本都是由我完成的。\n","permalink":"http://localhost:1313/zh/about/","summary":"\u003cp\u003e所有理论内容均为相关课程记录，课上手写记录，课后转为电子版，并对内容作出了进一步的翻译和解释，因此本人只有劳动成果，所有学术成果均归指导教师所有，每篇文章的最后均有标注指导教师以及对应的个人网站(如果有的话)。\u003c/p\u003e\n\u003cp\u003e所有实践内容均为实验课后报告的中文版，理论和代码部分基本都是由我完成的。\u003c/p\u003e","title":""}]